<!doctype html><html lang=en dir=" auto"><head><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=DotGothic16&family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel=stylesheet><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rustメモ（20-11-20～) | neuromantic</title><meta name=keywords content><meta name=description content="Smart Pointerのあらゆる実装分析 1. Deref trait Box<T>などは基本的にDeref traitを実装している。また、Box<T&g"><meta name=author content="Jongmin Yun, Neu."><link rel=canonical href=https://liliilli.github.io/posts/rust_2_memo/><link crossorigin=anonymous href=/assets/css/stylesheet.min.80dbcc80c00cba63b71a6526cb77f5aab60620dd3fecc491bc3a5da1af3d4c62.css integrity="sha256-gNvMgMAMumO3GmUmy3f1qrYGIN0/7MSRvDpdoa89TGI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://liliilli.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://liliilli.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://liliilli.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://liliilli.github.io/apple-touch-icon.png><link rel=mask-icon href=https://liliilli.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.0"><meta property="og:title" content="Rustメモ（20-11-20～)"><meta property="og:description" content="Smart Pointerのあらゆる実装分析 1. Deref trait Box<T>などは基本的にDeref traitを実装している。また、Box<T&g"><meta property="og:type" content="article"><meta property="og:url" content="https://liliilli.github.io/posts/rust_2_memo/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-19T22:21:23+09:00"><meta property="article:modified_time" content="2020-12-02T15:08:25+09:00"><meta property="og:site_name" content="neuromantic"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rustメモ（20-11-20～)"><meta name=twitter:description content="Smart Pointerのあらゆる実装分析 1. Deref trait Box<T>などは基本的にDeref traitを実装している。また、Box<T&g"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://liliilli.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Rustメモ（20-11-20～)","item":"https://liliilli.github.io/posts/rust_2_memo/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rustメモ（20-11-20～)","name":"Rustメモ（20-11-20～)","description":"Smart Pointerのあらゆる実装分析 1. Deref trait Box\u0026lt;T\u0026gt;などは基本的にDeref traitを実装している。また、Box\u0026lt;T\u0026g","keywords":[],"articleBody":"Smart Pointerのあらゆる実装分析 1. Deref trait Boxなどは基本的にDeref traitを実装している。また、Boxだけじゃなくて基本タイプの\u0026または\u0026mutも中身ロジックとしてはDerefを実装する。Deref traitはdereference operatorを指して、シンボルの前に*を置くことで参照に接近出来るようになる。\n 厳密にいうと、DerefとDerefMutというのがそれぞれあり、\u0026mutはDerefMutを実装している。\n BoxはDerefとDerefMutを実装しているため、次のようなコードが書ける。\nfn main(){letx=5;lety=Box::new(x);assert_eq!(5,x);assert_eq!(5,*y);// Derefを実装しているため、コンパイルが通る。 }上のassert_eq!(5, *y)は実はこう紐解かれてビルドするようになる。\nassert_eq!(5,*(y.deref()));2. Deref coercion Deref coercionとは、メソッドまたは関数などに入れる引数に自動で行うRustの機能で、\u0026Stringが\u0026strに変わるようにDerefを実装した型に参照型を置換できる他の方に変換することを指す。\nstd::string::StringはDerefの実装でAnnotation TypeのTargetをstrにしたので、Coercionで\u0026strに変わることが出来る。\nDeref coercionで、次のようなコードの書き方が出来る。\nfn hello(name: \u0026str){println!(\"Hello, {}\",name);}pubstruct MyBox{string: String }implMyBox{fn new(string: String)- Self{MyBox{string}}}implDerefforMyBox{type Target=str;fn deref(\u0026self)- \u0026Self::Target{self.string.deref()}}fn main(){letm=MyBox::new(String::from(\"Rust\"));hello(\u0026m);}3. DerefMutとの動作の違い  \u0026Tから\u0026UにするにはT: Derefで実装すること \u0026mut Tから\u0026mut UにするにはT: DerefMutで実装すること \u0026mut Tから\u0026UにするにはT: Derefで実装すること。  4. Drop trait  https://doc.rust-lang.org/std/ops/trait.Drop.html\n BoxをウィッシュとしたSmart PointerはDeref以外にもDropというtraitも実装する。これを実装することにより変数が今のスコープから離れてしまうと任意ロジックが動作するようにさせることが出来る。いわゆるC++のDestructorなもので、RAIIを実装するものだと思っても良さそう。\nDrop traitはfn drop(\u0026mut self)を実装することにより、デストラクタロジックの実装が可能になる。\nstruct CustomPointer{data: String,}implDropforCustomPointer{fn drop(\u0026mutself){println!(\"BlahBlah.\");}}ちなみにスコープの中に複数の変数がある時、変数のfn drop()が呼ばれる順は上から変数が初期化された順の逆で呼ばれる。\nまた、C++のデストラクタとは違ってDrop::dropは手動で読んでスコープを離れて自動で消されるより速く消すのは出来ない。しかし、std::mem::drop(T)にDropしたい変数を入れるとこの関数が代わりに早めにdrop()させるようにしてくれる。\n https://doc.rust-lang.org/std/mem/fn.drop.html\n またこの関数はPreludeに属しているのでuseを使わず使用できる。\nfn main(){letc=CustomPointer{data: String::from(\"Hello world!\")};drop(c);println!(\"CustomPoitner dropped before the end of main.\");}$ cargo run \"BlahBlah.\" \"CustomPoitner dropped before the end of main.\" 5. Rc  https://doc.rust-lang.org/std/rc/\n RcはC++のsmart_ptrのようなもので、次のようなものが通るようにする。\nenum List{Cons(i32,RcList),Nil,}usecrate::List::{Cons,Nil};usestd::rc::Rc;fn main(){leta=Rc::new(Cons(5,Rc::new(Cons(10,Rc::new(Nil)))));letb=Cons(3,Rc::clone(\u0026a));letc=Cons(4,Rc::clone(\u0026a));}しかしRcの問題としては、複数の変数が一つのメモリ空間を共同所有しているので自然に発生するしかないデータ競合を避けるため、基本的に\u0026（変更出来ない参照）だけをサポートする。もし\u0026mutを返すRcを作りたいとしたら、型引数をCellかRefCellにするしかない。\nまた、shared_ptrとは違ってRc自体はアトミック演算ではないカウントを使用する。なのでオーバーヘッドは少ないが、スレッド実行のための引数としては送ることが出来ない。すなわち、Rc自体はSend　traitを実装しない。\nもし、アトミック演算のカウントを使って、またマルチスレッドでスレッドの間でデータ共有をさせようとしたらstd::Arcを使うほうが良いらしい。\nまた、RcはStrongカウント（Rcとして共有されている数）とWeakカウント（Weakとして共有されている数）を参照することが出来る。\n6. RefCellとInterior Mutability  https://doc.rust-lang.org/std/cell/struct.RefCell.html\n Interior Mutabilityはデータへの不変な\u0026があるにも関わらず、データの更新が出来るようにするコードパターンだ。一般的にはRust自体のBorrowingルールによって禁止されているが、上のように\u0026になるはずのデータに更新を掛けようとすると、中身でunsafe{}を使うしかなくなる。\n中身でunsafe{}を使ってInterior Mutabilityパターンをさせようとすると、Borrowingルールはビルド時ではなく、ランタイムでやることになってビルドが通るようになる。ただし、そうなるとC++のように各自データ競合が起こさないように注意しなければならない。\n実はRefCellはそのままで使うと一つの所有権だけを持つことになる。しかし、\u0026状態なのに\u0026mutのように中身のデータを更新することが出来る。これをRcと使って、Rcのようにすれば…？\nA. 例 pubtraitMessenger{fn send(\u0026self,msg: \u0026str);}pubstruct LimitTracker'a,T: Messenger{messenger: \u0026'aTvalue: usize,max: usize,}impl'a,T: MessengerLimitTracker'a,T{pubfn new(messenger: \u0026T,max: usize)- LimiTrackerT{LimitTracker{messenger,value: 0,max}}pubfn set_value(\u0026mutself,value: usize){self.value=value;// ... }}のようなコードに\nstruct MockMessenger{sent_message: VecString,}implMockMessenger{/* ... */}implMessengerforMockMessenger{fn send(\u0026self,message: \u0026str){self.sent_message.push(String::from(message));}}MockMessenger::send()は\u0026sent_message自体が不変の参照型になるので、今のコードじゃメッセージを入れることができないことがわかる。安全な方法としてはsend()の最初の参照を\u0026mut selfに変えることだけど、あらゆる理由でそう出来ないときにはRefCellを使う。\nstruct MockMessenger{sent_message: RefCellVecString,}implMockMessenger{fn new()- Self{MockMessenger{sent_messenger: RefCell::new(vec![]),}// すこしコードが煩雑になるのはしかたない… }}implMessengerforMockMessenger{fn send(\u0026self,message: \u0026str){self.sent_message.borrow_mut().push(String::from(message));}// 上のコードでborrowing ruleはランタイムで動くようになる。 // マルチスレッドだとすると、CRITICAL_SECTIONなどを貼るなど工夫が必要になってしまう。。。 }RefCell::borrow_mut()またはRefCell::borrow()メソッドを呼ぶことにより、ラッピングされた\u0026または\u0026mutに準ずるインスタンスが返され、そしてそれを媒体として中身のデータが更新できるか、接近できるようになる。\nB. ランタイム使用での注意点 注意すべき点としては、RefCellを使ったらBorrowingルールのコンパイル時チェックが出来なくなり、代わりにランタイムでルールチェックが動くようになる。なので以下のようなコードはコンパイルは通るけどランタイムでpanic!になってしまう。\nimplMessengerforMockMessenger{fn send(\u0026self,message: \u0026str){letmutone_borrow=self.sent_message.borrow_mut();letmuterr_borrow=self.sent_message.borrow_mut();// ... }}Borrowingルール上、同じスコープでは複数の不変の\u0026だけにするか、それとも可変の単一の\u0026mutしかないとビルドまたはランタイムの動作が出来なくなる。なのでRefCellを使う時には注意が必要だ。\n7. Rc RcとRefCellを混ぜて使うことにより、複数の所有権を持たせながらデータの中身が変更できるようになる。ただ、Borrowingルールはランタイム動作に切り替わるので注意が必要だ。\n#[derive(Debug)]enum List{Cons(RcRefCelli32,RcList),Nil,}fn main(){letvalue=Rc::new(RefCell::new(5));// 5 leta=Rc::new(Cons(Rc::clone(\u0026value),Rc::new(Nil)));// 5, Nil letb=Cons(Rc::new(RefCell::new(3)),Rc::clone(\u0026a));// 3, 5, Nil letc=Cons(Rc::new(RefCell::new(4)),Rc::clone(\u0026a));// 4, 5, Nil *value.borrow_mut()+=10;// 15 | 15, Nil | 3, 15, Nil | 4, 15, Nil. // ... }8. WeakでReference Cyclesを防ぐ  https://doc.rust-lang.org/std/rc/struct.Weak.html\n Rc::cloneはRcのstrong_countを増加させる。なので、もしRcが２つあって、それがお互いに強参照として参照されているとしたら、カウントが落ちなくなるので結果的にはメモリリークになる。これを防ぐためにはRcをWeakとして変換して、使うしかない。\nRcからWeakに変換するためには、Rc::downgrade()を使う。Weakが生成されるとRcの弱参照のカウントが増加する。しかし弱参照は実質インスタンスの開放には関係がなくて０にならなくてもインスタンスが開放される。\nWeakの中身のデータを使うためには、Weak::upgrade()をしてRcに変換してから使うことが必要だ。しかし、Rcはすでに開放されてなくなっている可能性があるので、リターン型はOptionに包んだ形になる。\nConcurrency 1. Thread  https://doc.rust-lang.org/std/thread/\n Rustでスレッドを生成するためにはthread::spawn(P)を使う。\nusestd::thread;usestd::time::Duration;fn main(){lethandle=thread::spawn(||{foriin1..10{println!(\"hi number {} from spawned thread!\",i);thread::sleep(Duration::from_milis(1));}});foriin1..5{println!(\"hi number {} from main thread!\",i);thread::sleep(Duration::from_millis(1));}handle.join().unwrap();}注意点としては、生成されたスレッドは消滅する時にjoinをしないので、手動でjoin()を呼ぶ必要がある。\n2. Message Passing  https://doc.rust-lang.org/std/sync/index.html\n スレッドの間の安全な処理モデルとして、メッセージキューを使わせて処理をさせるものがある。これをチャンネル（Channel）というけど、Rustはstdで基本的なチャンネルを提供している。\nusestd::sync::mpsc;fn main(){let(tx,rx)=mpsc::channel();thread::spawn(move||{letval=String::from(\"Hi\");tx.send(val).unwrap();})letreceived=rx.recv().unwrap();println!(\"Got: {}\",received);}mpscチャンネルはMulti-Producer Single-Consumerのためのチャンネルである。mpscチャンネルは生成するとき、送信する側のtxと受信する側のrxをTuple形式で生成してくれる。mpscなので、txの方はclone()などで複数作ることが出来る。（rxは出来ない）\ntx: Sender側はsend()メソッドを実装していて、そこに受信側に送りたいものを送ることが出来る。send()メソッド自体は、中で何かが起こるかがわからないため、リターン型としてはResultになる。もし受信側がもうすでになくなっているか、送り先がなくなっている時にはエラーが起こる。\nrx: Receiver側ではrecv()またはtry_recv()メソッドがあって、送信されたなにかを受信することが出来る。違いとしては、recv()は送信側が消されてエラーになるか、それとも何かの値が受信されるまでスレッドをブロック状態に入らせる。try_recv()はそうではなく、失敗したらそのまま再開するようになっている。\nまた、送信するときの引数は必ず所有権が移動しなければならない。\nまた、次のようにイテレータを使って受信側でメッセージを連続的に処理することも可能だ。\nusestd::sync::mpsc;usestd::thread;usestd::time::Duration;fn main(){let(tx,rx)=mpsc::channel();letsender=thread::spawn(move||{letvals=vec![String::from(\"hi\"),String::from(\"from\"),String::from(\"the\"),String::from(\"thread\"),];forvalinvals{tx.send(val).unwrap();thread::sleep(Duration::from_secs(1));}});sender.join().unwrap();// 安全策 forreceivedinrx{println!(\"Got: {}\",received);}}上のコードで下の結果が取れる。\n$ cargo run Got: hi Got: from Got: the Got: thread 3. Mutex  https://doc.rust-lang.org/std/sync/struct.Mutex.html\n Mutexはmutual exclusionの略語として、マルチスレッド上で共有メモリに決まった時間内で一つのスレッドしか接近できないようにする。Rustで提供しているMutexはC++のものとはちょっと違って、データを中に含んでいてそれをlock()することによりラッパーを吐き出すようにして、最終的にはデータに接近させる感じとなる。\nまた、MutexはC++のlock_guardを自動で生成してRAIIのような仕組みをするようになっていて、lock()するとMutexGuardが返されてDerefすることでデータに接近させるようにしている。\nusestd::sync::Mutex;fn main(){letm=Mutex::new(5);{letmutdat: LockResult'_,i32=m.lock().unwrap();*dat*=6;}println!(\"m = {:?}\",m);// 30 }Mutexをマルチスレッドに対応する時に注意すべき点としては、Rcを使わずArcを使うべきであることだ。なぜなら、Rcのカウンターはアトミック演算をしていないため、スレッドにCloneした変数を渡すとしてもコンパイルエラーが起こってしまう。\nその反面、Arcはアトミック演算を使って参照カウントを実装しているため、渡すことが出来る。\n https://doc.rust-lang.org/std/sync/struct.Arc.html\n usestd::sync::{Arc,Mutex};usestd::thread;fn main(){letam_counter=Arc::new(Mutex::new(0));letmuthandles=vec![];for_in1..10{letam_counter_cloned=Arc::clone(\u0026am_counter);lethandle=thread::spawn(move||{letmutnum=am_counter_cloned.lock().unwrap();*mut+=1;})handles.push(handle);}forhandleinhandles{handle.join().unwrap();}assert_eq!(*am_counter.lock().unwrap(),10);}4. Sync、Send marker traits 実は上のArcかMutex、またmpsc::Channel()などはライブラリの機能で、Rust自体の文法的な機能ではない。しかし言語自他が内部的に定義しているコンセプトはあって、それがSyncとSend traitである。\na. Send  https://doc.rust-lang.org/std/marker/trait.Send.htmlThis trait is automatically implemented when the compiler determines it’s appropriate.\n Send marker traitは実装した型のデータはスレッド間転送できるようになる。ほぼ全てのRustのタイプはSendを実装しているが、RcのようにSendできないタイプも存在する。\n上でも書かれたように、ある構造体のすべての変数がSendを実装していれば、その構造体自体も自動にSendを実装したことになる。ほぼ全てのunsafeなpointerタイプを除外したPrimitive TypeはSendをサポートする。\nb. Sync Syncを実装したデータ型は、マルチスレッド環境で複数のスレッドから接近されても安全であることを示す。つまり上のSendと合わせて、もし\u0026TがSendで、そしてTがSyncならば別のスレッドにRefを転送してその中で使わせることが出来るということである。\nちなみにPrimitive TypeはSyncで、このTraitも構造体の変数が全てSyncならば自動にSyncが実装される。\nまた、MutexはSyncだけどRefCellかCellはBorrowingルールがランタイムで動作することもあり、スレッドセーフではないためSyncが実装されない。なので他のスレッドに同時接近させることが出来ない。\nc. SendとSyncの自前実装はunsafe SendとSync marker traitを自前で実装するのはunsafeになる。基本的にはコンパイラが自動で実装してくれる。\nPattern Matching 1. Function Parameters 関数のパラメータもパターンに成れる。以下のコードがあったとすると、\nfn foo(x: i32){// ... }xの部分はmatchかif let, while letのようにパターンとして扱うことが出来る。\nfn print_coordinates(\u0026(x,y): \u0026(i32,i32)){println!(\"Current Location : ({}, {})\",x,y);}fn main(){letpoint=(3,5);print_coordinates(\u0026point);}2. refutable、irrefutable  refutable pattern：パターンマッチングで、パターンが合わなく該当するロジックがなかったことに見なすことが出来るコードのパターンを指す。例えば、if letとかwhile letのようなマッチングパターンが含まれる。 irrefutable pattern：パターンマッチングで、パターンが必ず合って関連したロジックが実行されるか評価される。let、forが含まえる。  例えば、Optionになにかの値がある時にletを使って以下の構文を作るのは出来ない。なぜならletは必ずirrefutable patternにならなければならないからだ。\nletSome(x)=some_option_value;しかし、it letを使ったらビルドが通る。\nifletSome(x)=some_option_value{// ... }だが、irrefutable patternをrefutable patternに当てはめることは出来ない。\nifletx=5{// BUILD ERROR! }/* $ cargo run warning: irrefutable if-let pattern -- src/main.rs:2:5 | 2 | / if let x = 5 { 3 | | println!(\"{}\", x); 4 | | }; | |_____^ | = note: `#[warn(irrefutable_let_patterns)]` on by default Finished dev [unoptimized + debuginfo] target(s) in 0.39s Running `target/debug/patterns` 5 */3. Pattern Syntax a. Matching Named Variables letx=Some(5);lety=10;matchx{Some(50)=println!(\"Got 50\"),Some(y)=println!(\"Matched, y = {:?}\",y),// ...(1) Some(new_var)=println!(\"Matched, new = {:?}\",new_var),_=println!(\"Default case. None.\"),}...(1)のように既存の変数を使ってパターンマッチングに使わせることも出来る。\nb. Multiple Patterns Virtical Pipe文法（|）を使って、複数のパターンをORでマッチングをさせることも出来る。\nletx=1;matchx{1|2=println!(\"one or two\"),3=println!(\"three!\"),_=println!(\"whatever\"),}c. ..=を使ってInclusiveな範囲マッチング ..=文法は値の範囲を決めるようにする。しかし、制限があってPrimitive Typeの数型またはcharタイプしか範囲を決めることが出来ない。\nletx='c';matchx{'a'..='j'=println!(\"early ASCII letters\"),'k'..='z'=println!(\"late ASCII letters\"),_=println!(\"something else\"),}ちなみにRustのstable版では..=じゃなく..を使ってパターンマッチングさせる文法は実験機能として使えない。\n error[E0658]: exclusive range pattern syntax is experimental https://github.com/rust-lang/rust/issues/37854\n d. 構造体の変数の分解 構造体と中の変数が見えてる限り（pub）、構造体の変数を分解することが出来る。\nstruct Point{x: i32,y: i32 }fn main(){letp=Point{x: 0,y: 7};letPoint{x: a,y: b}=p;assert_eq!(a,0);assert_eq!(b,7);}または変数の名前をそのまま使ってパターンマッチングさせることも出来る。（irrefutable patternになること）\nfn main(){letp=Point{x: 0,y: 7};letPoint{x,y}=p;assert_eq!(x,0);assert_eq!(y,7);}このような文法を使って、matchにも活かせる。\nfn main(){letp=Point{x: 0,y: 7};matchp{Point{x,y: 0}=/* ... */,Point{x: 0,y}=/* ... */,Point{x,y}=/* ... */,}}e. 多重の構造体またはenumの分解 enum Color{Rgb(u8,u8,u8),Hsv(u8,u8,u8),}enum Message{Quit,Move{x: i32,y: i32 },Write(std::String),ChangeColor(Color),}fn main(){letmsg=Message::ChangeColor(Color::Hsv(15,128,255));matchmsg{Message::Move{x,y}=/* ... */,Message::ChangeColor(Color::Hsv(h,s,v))=/* ... */,Message::ChangeColor(Color::Rgb(r,g,b))=/* ... */,_=(),}}f. ..を使って使わない変数たちを無視する _は単一変数を無視することで、..は変数組を無視する効果を持つ。ただし、..を使う際にはどの変数まで無視して使わないようにするかがはっきりしていなければならない。\nstruct Point{x: i32,y: i32,z: i32 }fn main(){letorigin=Point{x: 0,y: 1,z: 2};matchorigin{Point{x,..}=println!(\"x is {}\",x),}letnumbers=(2,4,8,16,32);matchnumbers{(x,y,..,h)={println!(\"Some numbers: {}, {}, and {}\",x,y,h);},// (.., w, ..) = ERROR STATEMENTS. }}g. match guardを使って条件の追加提示 letnum=Some(4);matchnum{Some(x)if(x5\u0026\u0026x4)=println!(\"less than five: {}\",x),Some(x)=println!(\"{}\",x),None=(),}h. @ at operatorを使って同時に変数を生成 at演算子（@）はパターンマッチングをやりながら、マッチングされた時に変数を生成して中身で活用するようにする。\nenum Message{Hello{id: i32 },}letmsg=Message::Hello{id: 5};matchmsg{Message::Hello{id: id_variable@3..=7,}=println!(\"Found an id in range: {}\",id_variable),Message::Hello{id: 10..=12}={println!(\"Found an id in another range\")}Message::Hello{id}=println!(\"Found some other id: {}\",id),}","wordCount":"7392","inLanguage":"en","datePublished":"2020-11-19T22:21:23+09:00","dateModified":"2020-12-02T15:08:25+09:00","author":{"@type":"Person","name":"Jongmin Yun, Neu."},"mainEntityOfPage":{"@type":"WebPage","@id":"https://liliilli.github.io/posts/rust_2_memo/"},"publisher":{"@type":"Organization","name":"neuromantic","logo":{"@type":"ImageObject","url":"https://liliilli.github.io/favicon.ico"}}}</script></head><body id=" top"><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://liliilli.github.io accesskey=h title="neuromantic (Alt + H)">neuromantic</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://liliilli.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://liliilli.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://liliilli.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://liliilli.github.io/series/ title=Series><span>Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://liliilli.github.io>Home</a>&nbsp;»&nbsp;<a href=https://liliilli.github.io/posts/>Posts</a></div><h1 class=post-title>Rustメモ（20-11-20～)</h1><div class=post-meta>2020, November 19&nbsp;·&nbsp;Jongmin Yun, Neu.</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#smart-pointer%e3%81%ae%e3%81%82%e3%82%89%e3%82%86%e3%82%8b%e5%ae%9f%e8%a3%85%e5%88%86%e6%9e%90 aria-label="Smart Pointerのあらゆる実装分析">Smart Pointerのあらゆる実装分析</a><ul><li><a href=#1-deref-trait aria-label="1. Deref trait">1. <code>Deref</code> trait</a></li><li><a href=#2-deref-coercion aria-label="2. Deref coercion">2. <code>Deref</code> coercion</a></li><li><a href=#3-derefmut%e3%81%a8%e3%81%ae%e5%8b%95%e4%bd%9c%e3%81%ae%e9%81%95%e3%81%84 aria-label="3. DerefMutとの動作の違い">3. <code>DerefMut</code>との動作の違い</a></li><li><a href=#4-drop-trait aria-label="4. Drop trait">4. <code>Drop</code> trait</a></li><li><a href=#5-rct aria-label="5. Rc&amp;lt;T&amp;gt;">5. <code>Rc&lt;T></code></a></li><li><a href=#6-refcellt%e3%81%a8interior-mutability aria-label="6. RefCell&amp;lt;T&amp;gt;とInterior Mutability">6. <code>RefCell&lt;T></code>とInterior Mutability</a><ul><li><a href=#a-%e4%be%8b aria-label="A. 例">A. 例</a></li><li><a href=#b-%e3%83%a9%e3%83%b3%e3%82%bf%e3%82%a4%e3%83%a0%e4%bd%bf%e7%94%a8%e3%81%a7%e3%81%ae%e6%b3%a8%e6%84%8f%e7%82%b9 aria-label="B. ランタイム使用での注意点">B. ランタイム使用での注意点</a></li></ul></li><li><a href=#7-rcrefcellt aria-label="7. Rc&amp;lt;RefCell&amp;lt;T&amp;gt;&amp;gt;">7. <code>Rc&lt;RefCell&lt;T>></code></a></li><li><a href=#8-weakt%e3%81%a7reference-cycles%e3%82%92%e9%98%b2%e3%81%90 aria-label="8. Weak&amp;lt;T&amp;gt;でReference Cyclesを防ぐ">8. <code>Weak&lt;T></code>でReference Cyclesを防ぐ</a></li></ul></li><li><a href=#concurrency aria-label=Concurrency>Concurrency</a><ul><li><a href=#1-thread aria-label="1. Thread">1. Thread</a></li><li><a href=#2-message-passing aria-label="2. Message Passing">2. Message Passing</a></li><li><a href=#3-mutext aria-label="3. Mutex&amp;lt;T&amp;gt;">3. <code>Mutex&lt;T></code></a></li><li><a href=#4-syncsend-marker-traits aria-label="4. Sync、Send marker traits">4. <code>Sync</code>、<code>Send</code> marker traits</a><ul><li><a href=#a-send aria-label="a. Send">a. <code>Send</code></a></li><li><a href=#b-sync aria-label="b. Sync">b. <code>Sync</code></a></li><li><a href=#c-send%e3%81%a8sync%e3%81%ae%e8%87%aa%e5%89%8d%e5%ae%9f%e8%a3%85%e3%81%afunsafe aria-label="c. SendとSyncの自前実装はunsafe">c. <code>Send</code>と<code>Sync</code>の自前実装は<code>unsafe</code></a></li></ul></li></ul></li><li><a href=#pattern-matching aria-label="Pattern Matching">Pattern Matching</a><ul><li><a href=#1-function-parameters aria-label="1. Function Parameters">1. Function Parameters</a></li><li><a href=#2-refutableirrefutable aria-label="2. refutable、irrefutable">2. refutable、irrefutable</a></li><li><a href=#3-pattern-syntax aria-label="3. Pattern Syntax">3. Pattern Syntax</a><ul><li><a href=#a-matching-named-variables aria-label="a. Matching Named Variables">a. Matching Named Variables</a></li><li><a href=#b-multiple-patterns aria-label="b. Multiple Patterns">b. Multiple Patterns</a></li><li><a href=#c-%e3%82%92%e4%bd%bf%e3%81%a3%e3%81%a6inclusive%e3%81%aa%e7%af%84%e5%9b%b2%e3%83%9e%e3%83%83%e3%83%81%e3%83%b3%e3%82%b0 aria-label="c. ..=を使ってInclusiveな範囲マッチング">c. <code>..=</code>を使ってInclusiveな範囲マッチング</a></li><li><a href=#d-%e6%a7%8b%e9%80%a0%e4%bd%93%e3%81%ae%e5%a4%89%e6%95%b0%e3%81%ae%e5%88%86%e8%a7%a3 aria-label="d. 構造体の変数の分解">d. 構造体の変数の分解</a></li><li><a href=#e-%e5%a4%9a%e9%87%8d%e3%81%ae%e6%a7%8b%e9%80%a0%e4%bd%93%e3%81%be%e3%81%9f%e3%81%afenum%e3%81%ae%e5%88%86%e8%a7%a3 aria-label="e. 多重の構造体またはenumの分解">e. 多重の構造体または<code>enum</code>の分解</a></li><li><a href=#f-%e3%82%92%e4%bd%bf%e3%81%a3%e3%81%a6%e4%bd%bf%e3%82%8f%e3%81%aa%e3%81%84%e5%a4%89%e6%95%b0%e3%81%9f%e3%81%a1%e3%82%92%e7%84%a1%e8%a6%96%e3%81%99%e3%82%8b aria-label="f. ..を使って使わない変数たちを無視する">f. <code>..</code>を使って使わない変数たちを無視する</a></li><li><a href=#g-match-guard%e3%82%92%e4%bd%bf%e3%81%a3%e3%81%a6%e6%9d%a1%e4%bb%b6%e3%81%ae%e8%bf%bd%e5%8a%a0%e6%8f%90%e7%a4%ba aria-label="g. match guardを使って条件の追加提示">g. <em>match guard</em>を使って条件の追加提示</a></li><li><a href=#h--at-operator%e3%82%92%e4%bd%bf%e3%81%a3%e3%81%a6%e5%90%8c%e6%99%82%e3%81%ab%e5%a4%89%e6%95%b0%e3%82%92%e7%94%9f%e6%88%90 aria-label="h. @ at operatorを使って同時に変数を生成">h. <code>@</code> at operatorを使って同時に変数を生成</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h2 id=smart-pointerのあらゆる実装分析>Smart Pointerのあらゆる実装分析<a hidden class=anchor aria-hidden=true href=#smart-pointerのあらゆる実装分析>#</a></h2><h3 id=1-deref-trait>1. <code>Deref</code> trait<a hidden class=anchor aria-hidden=true href=#1-deref-trait>#</a></h3><p><code>Box&lt;T></code>などは基本的に<code>Deref</code> traitを実装している。また、<code>Box&lt;T></code>だけじゃなくて基本タイプの<code>&</code>または<code>&mut</code>も中身ロジックとしては<code>Deref</code>を実装する。<code>Deref</code> traitは<em>dereference operator</em>を指して、シンボルの前に<code>*</code>を置くことで参照に接近出来るようになる。</p><blockquote><p>厳密にいうと、<code>Deref</code>と<code>DerefMut</code>というのがそれぞれあり、<code>&mut</code>は<code>DerefMut</code>を実装している。</p></blockquote><p><code>Box&lt;T></code>は<code>Deref</code>と<code>DerefMut</code>を実装しているため、次のようなコードが書ける。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>x</span><span class=p>);</span><span class=w>
</span><span class=w>    
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=n>y</span><span class=p>);</span><span class=w> </span><span class=c1>// Derefを実装しているため、コンパイルが通る。
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>上の<code>assert_eq!(5, *y)</code>は実はこう紐解かれてビルドするようになる。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=p>(</span><span class=n>y</span><span class=p>.</span><span class=n>deref</span><span class=p>()));</span><span class=w>
</span></code></pre></div><h3 id=2-deref-coercion>2. <code>Deref</code> coercion<a hidden class=anchor aria-hidden=true href=#2-deref-coercion>#</a></h3><p><code>Deref</code> coercionとは、メソッドまたは関数などに入れる引数に自動で行うRustの機能で、<code>&String</code>が<code>&str</code>に変わるように<code>Deref</code>を実装した型に参照型を置換できる他の方に変換することを指す。</p><p><code>std::string::String</code>は<code>Deref</code>の実装でAnnotation Typeの<code>Target</code>を<code>str</code>にしたので、Coercionで<code>&str</code>に変わることが出来る。</p><p><code>Deref</code> coercionで、次のようなコードの書き方が出来る。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>hello</span><span class=p>(</span><span class=n>name</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Hello, {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>MyBox</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>string</span>: <span class=nb>String</span>
<span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>MyBox</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>string</span>: <span class=nb>String</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>MyBox</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>string</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Deref</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>MyBox</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Target</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kt>str</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>deref</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>Self</span>::<span class=n>Target</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>string</span><span class=p>.</span><span class=n>deref</span><span class=p>()</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>MyBox</span>::<span class=n>new</span><span class=p>(</span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;Rust&#34;</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=n>hello</span><span class=p>(</span><span class=o>&amp;</span><span class=n>m</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h3 id=3-derefmutとの動作の違い>3. <code>DerefMut</code>との動作の違い<a hidden class=anchor aria-hidden=true href=#3-derefmutとの動作の違い>#</a></h3><ul><li><code>&T</code>から<code>&U</code>にするには<code>T: Deref&lt;Target=U></code>で実装すること</li><li><code>&mut T</code>から<code>&mut U</code>にするには<code>T: DerefMut&lt;Target=U></code>で実装すること</li><li><code>&mut T</code>から<code>&U</code>にするには<code>T: Deref&lt;Target=U></code>で実装すること。</li></ul><h3 id=4-drop-trait>4. <code>Drop</code> trait<a hidden class=anchor aria-hidden=true href=#4-drop-trait>#</a></h3><blockquote><p><a href=https://doc.rust-lang.org/std/ops/trait.Drop.html>https://doc.rust-lang.org/std/ops/trait.Drop.html</a></p></blockquote><p><code>Box&lt;T></code>をウィッシュとしたSmart Pointerは<code>Deref</code>以外にも<code>Drop</code>というtraitも実装する。これを実装することにより変数が今のスコープから離れてしまうと任意ロジックが動作するようにさせることが出来る。いわゆるC++のDestructorなもので、RAIIを実装するものだと思っても良さそう。</p><p><code>Drop</code> traitは<code>fn drop(&mut self)</code>を実装することにより、デストラクタロジックの実装が可能になる。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>struct</span> <span class=nc>CustomPointer</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>data</span>: <span class=nb>String</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=nb>Drop</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>CustomPointer</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>drop</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;BlahBlah.&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>ちなみにスコープの中に複数の変数がある時、変数の<code>fn drop()</code>が呼ばれる順は上から変数が初期化された順の逆で呼ばれる。</p><p>また、C++のデストラクタとは違って<code>Drop::drop</code>は手動で読んでスコープを離れて自動で消されるより速く消すのは出来ない。しかし、<code>std::mem::drop&lt;T: Drop>(T)</code>にDropしたい変数を入れるとこの関数が代わりに早めに<code>drop()</code>させるようにしてくれる。</p><blockquote><p><a href=https://doc.rust-lang.org/std/mem/fn.drop.html>https://doc.rust-lang.org/std/mem/fn.drop.html</a></p></blockquote><p>またこの関数はPreludeに属しているので<code>use</code>を使わず使用できる。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>CustomPointer</span><span class=p>{</span><span class=w> </span><span class=n>data</span>: <span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;Hello world!&#34;</span><span class=p>)</span><span class=w> </span><span class=p>};</span><span class=w>
</span><span class=w>    </span><span class=n>drop</span><span class=p>(</span><span class=n>c</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;CustomPoitner dropped before the end of main.&#34;</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ cargo run
<span class=s2>&#34;BlahBlah.&#34;</span>
<span class=s2>&#34;CustomPoitner dropped before the end of main.&#34;</span>
</code></pre></div><h3 id=5-rct>5. <code>Rc&lt;T></code><a hidden class=anchor aria-hidden=true href=#5-rct>#</a></h3><blockquote><p><a href=https://doc.rust-lang.org/std/rc/>https://doc.rust-lang.org/std/rc/</a></p></blockquote><p><code>Rc&lt;T></code>はC++の<code>smart_ptr&lt;T></code>のようなもので、次のようなものが通るようにする。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>enum</span> <span class=nc>List</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>Cons</span><span class=p>(</span><span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span><span class=o>&lt;</span><span class=n>List</span><span class=o>&gt;</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=n>Nil</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>List</span>::<span class=p>{</span><span class=n>Cons</span><span class=p>,</span><span class=w> </span><span class=n>Nil</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>rc</span>::<span class=n>Rc</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Cons</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Cons</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Nil</span><span class=p>)))));</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Cons</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span>::<span class=n>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Cons</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span>::<span class=n>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>));</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>しかし<code>Rc&lt;T></code>の問題としては、複数の変数が一つのメモリ空間を共同所有しているので自然に発生するしかないデータ競合を避けるため、基本的に<code>&</code>（変更出来ない参照）だけをサポートする。もし<code>&mut</code>を返す<code>Rc&lt;T></code>を作りたいとしたら、型引数を<code>Cell&lt;T></code>か<code>RefCell&lt;T></code>にするしかない。</p><p>また、<code>shared_ptr&lt;T></code>とは違って<code>Rc&lt;T></code>自体はアトミック演算ではないカウントを使用する。なのでオーバーヘッドは少ないが、スレッド実行のための引数としては送ることが出来ない。すなわち、<code>Rc&lt;T></code>自体は<code>Send</code>　traitを実装しない。</p><p>もし、アトミック演算のカウントを使って、またマルチスレッドでスレッドの間でデータ共有をさせようとしたら<code>std::Arc&lt;T></code>を使うほうが良いらしい。</p><p>また、<code>Rc&lt;T></code>はStrongカウント（<code>Rc&lt;T></code>として共有されている数）とWeakカウント（<code>Weak&lt;T></code>として共有されている数）を参照することが出来る。</p><h3 id=6-refcelltとinterior-mutability>6. <code>RefCell&lt;T></code>とInterior Mutability<a hidden class=anchor aria-hidden=true href=#6-refcelltとinterior-mutability>#</a></h3><blockquote><p><a href=https://doc.rust-lang.org/std/cell/struct.RefCell.html>https://doc.rust-lang.org/std/cell/struct.RefCell.html</a></p></blockquote><p><em>Interior Mutability</em>はデータへの不変な<code>&</code>があるにも関わらず、データの更新が出来るようにするコードパターンだ。一般的にはRust自体のBorrowingルールによって禁止されているが、上のように<code>&</code>になるはずのデータに更新を掛けようとすると、中身で<code>unsafe{}</code>を使うしかなくなる。</p><p>中身で<code>unsafe{}</code>を使ってInterior Mutabilityパターンをさせようとすると、Borrowingルールはビルド時ではなく、ランタイムでやることになってビルドが通るようになる。ただし、そうなるとC++のように各自データ競合が起こさないように注意しなければならない。</p><p>実は<code>RefCell&lt;T></code>はそのままで使うと一つの所有権だけを持つことになる。しかし、<code>&</code>状態なのに<code>&mut</code>のように中身のデータを更新することが出来る。これを<code>Rc&lt;T></code>と使って、<code>Rc&lt;RefCell&lt;T>></code>のようにすれば…？</p><h4 id=a-例>A. 例<a hidden class=anchor aria-hidden=true href=#a-例>#</a></h4><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>Messenger</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>send</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>msg</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>LimitTracker</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span>: <span class=nc>Messenger</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>messenger</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=n>T</span><span class=w>
</span><span class=w>    </span><span class=n>value</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>max</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span>: <span class=nc>Messenger</span><span class=o>&gt;</span><span class=w> </span><span class=n>LimitTracker</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>messenger</span>: <span class=kp>&amp;</span><span class=nc>T</span><span class=p>,</span><span class=w> </span><span class=n>max</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>LimiTracker</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>LimitTracker</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>messenger</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>value</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>max</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>set_value</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>value</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w> 
</span><span class=w>        </span><span class=c1>// ...
</span><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>のようなコードに</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>struct</span> <span class=nc>MockMessenger</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>sent_message</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>MockMessenger</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=cm>/* ... */</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Messenger</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>MockMessenger</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>send</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>message</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>sent_message</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=n>message</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p><code>MockMessenger::send()</code>は<code>&sent_message</code>自体が不変の参照型になるので、今のコードじゃメッセージを入れることができないことがわかる。安全な方法としては<code>send()</code>の最初の参照を<code>&mut self</code>に変えることだけど、あらゆる理由でそう出来ないときには<code>RefCell&lt;T></code>を使う。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>struct</span> <span class=nc>MockMessenger</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>sent_message</span>: <span class=nc>RefCell</span><span class=o>&lt;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>MockMessenger</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>new</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>MockMessenger</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>sent_messenger</span>: <span class=nc>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=n>vec</span><span class=o>!</span><span class=p>[]),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=c1>// すこしコードが煩雑になるのはしかたない…
</span><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Messenger</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>MockMessenger</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>send</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>message</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>sent_message</span><span class=p>.</span><span class=n>borrow_mut</span><span class=p>().</span><span class=n>push</span><span class=p>(</span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=n>message</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=c1>// 上のコードでborrowing ruleはランタイムで動くようになる。
</span><span class=c1></span><span class=w>    </span><span class=c1>// マルチスレッドだとすると、CRITICAL_SECTIONなどを貼るなど工夫が必要になってしまう。。。
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p><code>RefCell::borrow_mut()</code>または<code>RefCell::borrow()</code>メソッドを呼ぶことにより、ラッピングされた<code>&</code>または<code>&mut</code>に準ずるインスタンスが返され、そしてそれを媒体として中身のデータが更新できるか、接近できるようになる。</p><h4 id=b-ランタイム使用での注意点>B. ランタイム使用での注意点<a hidden class=anchor aria-hidden=true href=#b-ランタイム使用での注意点>#</a></h4><p>注意すべき点としては、<code>RefCell&lt;T></code>を使ったらBorrowingルールのコンパイル時チェックが出来なくなり、代わりにランタイムでルールチェックが動くようになる。なので以下のようなコードはコンパイルは通るけどランタイムで<code>panic!</code>になってしまう。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>Messenger</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>MockMessenger</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>send</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>message</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>one_borrow</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>sent_message</span><span class=p>.</span><span class=n>borrow_mut</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>err_borrow</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>sent_message</span><span class=p>.</span><span class=n>borrow_mut</span><span class=p>();</span><span class=w>
</span><span class=w>        
</span><span class=w>        </span><span class=c1>// ...
</span><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Borrowingルール上、同じスコープでは複数の不変の<code>&</code>だけにするか、それとも可変の単一の<code>&mut</code>しかないとビルドまたはランタイムの動作が出来なくなる。なので<code>RefCell&lt;T></code>を使う時には注意が必要だ。</p><h3 id=7-rcrefcellt>7. <code>Rc&lt;RefCell&lt;T>></code><a hidden class=anchor aria-hidden=true href=#7-rcrefcellt>#</a></h3><p><code>Rc&lt;T></code>と<code>RefCell&lt;T></code>を混ぜて使うことにより、複数の所有権を持たせながらデータの中身が変更できるようになる。ただ、Borrowingルールはランタイム動作に切り替わるので注意が必要だ。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[derive(Debug)]</span><span class=w>
</span><span class=w></span><span class=k>enum</span> <span class=nc>List</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>Cons</span><span class=p>(</span><span class=n>Rc</span><span class=o>&lt;</span><span class=n>RefCell</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span><span class=o>&lt;</span><span class=n>List</span><span class=o>&gt;</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=n>Nil</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=mi>5</span><span class=p>));</span><span class=w> </span><span class=c1>// 5
</span><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Cons</span><span class=p>(</span><span class=n>Rc</span>::<span class=n>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=n>value</span><span class=p>),</span><span class=w> </span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Nil</span><span class=p>)));</span><span class=w> </span><span class=c1>// 5, Nil
</span><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Cons</span><span class=p>(</span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=mi>3</span><span class=p>)),</span><span class=w> </span><span class=n>Rc</span>::<span class=n>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>));</span><span class=w>  </span><span class=c1>// 3, 5, Nil
</span><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Cons</span><span class=p>(</span><span class=n>Rc</span>::<span class=n>new</span><span class=p>(</span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=mi>4</span><span class=p>)),</span><span class=w> </span><span class=n>Rc</span>::<span class=n>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>));</span><span class=w>  </span><span class=c1>// 4, 5, Nil
</span><span class=c1></span><span class=w>    
</span><span class=w>    </span><span class=o>*</span><span class=n>value</span><span class=p>.</span><span class=n>borrow_mut</span><span class=p>()</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w> </span><span class=c1>// 15 | 15, Nil | 3, 15, Nil | 4, 15, Nil.
</span><span class=c1></span><span class=w>    </span><span class=c1>// ...
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><h3 id=8-weaktでreference-cyclesを防ぐ>8. <code>Weak&lt;T></code>でReference Cyclesを防ぐ<a hidden class=anchor aria-hidden=true href=#8-weaktでreference-cyclesを防ぐ>#</a></h3><blockquote><p><a href=https://doc.rust-lang.org/std/rc/struct.Weak.html>https://doc.rust-lang.org/std/rc/struct.Weak.html</a></p></blockquote><p><code>Rc&lt;T>::clone</code>は<code>Rc&lt;T></code>の<code>strong_count</code>を増加させる。なので、もし<code>Rc&lt;T></code>が２つあって、それがお互いに強参照として参照されているとしたら、カウントが落ちなくなるので結果的にはメモリリークになる。これを防ぐためには<code>Rc&lt;T></code>を<code>Weak&lt;T></code>として変換して、使うしかない。</p><p><code>Rc&lt;T></code>から<code>Weak&lt;T></code>に変換するためには、<code>Rc::downgrade()</code>を使う。<code>Weak&lt;T></code>が生成されると<code>Rc&lt;T></code>の弱参照のカウントが増加する。しかし弱参照は実質インスタンスの開放には関係がなくて０にならなくてもインスタンスが開放される。</p><p><code>Weak&lt;T></code>の中身のデータを使うためには、<code>Weak::upgrade()</code>をして<code>Rc&lt;T></code>に変換してから使うことが必要だ。しかし、<code>Rc&lt;T></code>はすでに開放されてなくなっている可能性があるので、リターン型は<code>Option&lt;></code>に包んだ形になる。</p><h2 id=concurrency>Concurrency<a hidden class=anchor aria-hidden=true href=#concurrency>#</a></h2><h3 id=1-thread>1. Thread<a hidden class=anchor aria-hidden=true href=#1-thread>#</a></h3><blockquote><p><a href=https://doc.rust-lang.org/std/thread/>https://doc.rust-lang.org/std/thread/</a></p></blockquote><p>Rustでスレッドを生成するためには<code>thread::spawn(P)</code>を使う。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>thread</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>time</span>::<span class=n>Duration</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>1</span><span class=p>..</span><span class=mi>10</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;hi number {} from spawned thread!&#34;</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span><span class=w>            </span><span class=n>thread</span>::<span class=n>sleep</span><span class=p>(</span><span class=n>Duration</span>::<span class=n>from_milis</span><span class=p>(</span><span class=mi>1</span><span class=p>));</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>});</span><span class=w>
</span><span class=w>    
</span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>1</span><span class=p>..</span><span class=mi>5</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;hi number {} from main thread!&#34;</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>thread</span>::<span class=n>sleep</span><span class=p>(</span><span class=n>Duration</span>::<span class=n>from_millis</span><span class=p>(</span><span class=mi>1</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    
</span><span class=w>    </span><span class=n>handle</span><span class=p>.</span><span class=n>join</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>注意点としては、生成されたスレッドは消滅する時に<code>join</code>をしないので、手動で<code>join()</code>を呼ぶ必要がある。</p><h3 id=2-message-passing>2. Message Passing<a hidden class=anchor aria-hidden=true href=#2-message-passing>#</a></h3><blockquote><p><a href=https://doc.rust-lang.org/std/sync/index.html>https://doc.rust-lang.org/std/sync/index.html</a></p></blockquote><p>スレッドの間の安全な処理モデルとして、メッセージキューを使わせて処理をさせるものがある。これをチャンネル（Channel）というけど、Rustは<code>std</code>で基本的なチャンネルを提供している。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=n>mpsc</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>tx</span><span class=p>,</span><span class=w> </span><span class=n>rx</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mpsc</span>::<span class=n>channel</span><span class=p>();</span><span class=w>
</span><span class=w>    
</span><span class=w>    </span><span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>val</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;Hi&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>tx</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=n>val</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=p>})</span><span class=w>
</span><span class=w>    
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>received</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rx</span><span class=p>.</span><span class=n>recv</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Got: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>received</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p><code>mpsc</code>チャンネルはMulti-Producer Single-Consumerのためのチャンネルである。<code>mpsc</code>チャンネルは生成するとき、送信する側の<code>tx</code>と受信する側の<code>rx</code>をTuple形式で生成してくれる。<code>mpsc</code>なので、<code>tx</code>の方は<code>clone()</code>などで複数作ることが出来る。（<code>rx</code>は出来ない）</p><p><code>tx: Sender&lt;T></code>側は<code>send()</code>メソッドを実装していて、そこに受信側に送りたいものを送ることが出来る。<code>send()</code>メソッド自体は、中で何かが起こるかがわからないため、リターン型としては<code>Result&lt;T, E></code>になる。もし受信側がもうすでになくなっているか、送り先がなくなっている時にはエラーが起こる。</p><p><code>rx: Receiver&lt;T></code>側では<code>recv()</code>または<code>try_recv()</code>メソッドがあって、送信されたなにかを受信することが出来る。違いとしては、<code>recv()</code>は送信側が消されてエラーになるか、それとも何かの値が受信されるまでスレッドをブロック状態に入らせる。<code>try_recv()</code>はそうではなく、失敗したらそのまま再開するようになっている。</p><p>また、送信するときの引数は必ず所有権が移動しなければならない。</p><p>また、次のようにイテレータを使って受信側でメッセージを連続的に処理することも可能だ。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=n>mpsc</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>thread</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>time</span>::<span class=n>Duration</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>tx</span><span class=p>,</span><span class=w> </span><span class=n>rx</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mpsc</span>::<span class=n>channel</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>sender</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>vals</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>vec</span><span class=o>!</span><span class=p>[</span><span class=w>
</span><span class=w>            </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hi&#34;</span><span class=p>),</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;from&#34;</span><span class=p>),</span><span class=w>
</span><span class=w>            </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;the&#34;</span><span class=p>),</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;thread&#34;</span><span class=p>),</span><span class=w>
</span><span class=w>        </span><span class=p>];</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=n>val</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>vals</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>tx</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=n>val</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w>            </span><span class=n>thread</span>::<span class=n>sleep</span><span class=p>(</span><span class=n>Duration</span>::<span class=n>from_secs</span><span class=p>(</span><span class=mi>1</span><span class=p>));</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>});</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=n>sender</span><span class=p>.</span><span class=n>join</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w> </span><span class=c1>// 安全策
</span><span class=c1></span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>received</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>rx</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Got: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>received</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>上のコードで下の結果が取れる。</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>$ cargo run
Got: hi
Got: from
Got: the
Got: thread
</code></pre></div><h3 id=3-mutext>3. <code>Mutex&lt;T></code><a hidden class=anchor aria-hidden=true href=#3-mutext>#</a></h3><blockquote><p><a href=https://doc.rust-lang.org/std/sync/struct.Mutex.html>https://doc.rust-lang.org/std/sync/struct.Mutex.html</a></p></blockquote><p><em>Mutex</em>は<em>mutual exclusion</em>の略語として、マルチスレッド上で共有メモリに決まった時間内で一つのスレッドしか接近できないようにする。Rustで提供している<code>Mutex&lt;T></code>はC++のものとはちょっと違って、データを中に含んでいてそれを<code>lock()</code>することによりラッパーを吐き出すようにして、最終的にはデータに接近させる感じとなる。</p><p>また、<code>Mutex&lt;T></code>はC++の<code>lock_guard&lt;T></code>を自動で生成してRAIIのような仕組みをするようになっていて、<code>lock()</code>すると<code>MutexGuard&lt;&T></code>が返されて<code>Deref</code>することでデータに接近させるようにしている。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=n>Mutex</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Mutex</span>::<span class=n>new</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>dat</span>: <span class=nc>LockResult</span><span class=o>&lt;</span><span class=na>&#39;_</span><span class=p>,</span><span class=w> </span><span class=kt>i32</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>m</span><span class=p>.</span><span class=n>lock</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=o>*</span><span class=n>dat</span><span class=w> </span><span class=o>*=</span><span class=w> </span><span class=mi>6</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;m = {:?}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>m</span><span class=p>);</span><span class=w> </span><span class=c1>// 30
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p><code>Mutex&lt;T></code>をマルチスレッドに対応する時に注意すべき点としては、<code>Rc&lt;T></code>を使わず<code>Arc&lt;T></code>を使うべきであることだ。なぜなら、<code>Rc&lt;T></code>のカウンターはアトミック演算をしていないため、スレッドにCloneした変数を渡すとしてもコンパイルエラーが起こってしまう。</p><p>その反面、<code>Arc&lt;T></code>はアトミック演算を使って参照カウントを実装しているため、渡すことが出来る。</p><blockquote><p><a href=https://doc.rust-lang.org/std/sync/struct.Arc.html>https://doc.rust-lang.org/std/sync/struct.Arc.html</a></p></blockquote><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=p>{</span><span class=n>Arc</span><span class=p>,</span><span class=w> </span><span class=n>Mutex</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>thread</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>am_counter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Mutex</span>::<span class=n>new</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>handles</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>vec</span><span class=o>!</span><span class=p>[];</span><span class=w>
</span><span class=w>    
</span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>1</span><span class=p>..</span><span class=mi>10</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>am_counter_cloned</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arc</span>::<span class=n>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=n>am_counter</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>num</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>am_counter_cloned</span><span class=p>.</span><span class=n>lock</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w>            </span><span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=p>})</span><span class=w>
</span><span class=w>        </span><span class=n>handles</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>handle</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    
</span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>handle</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>handles</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>handle</span><span class=p>.</span><span class=n>join</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=o>*</span><span class=n>am_counter</span><span class=p>.</span><span class=n>lock</span><span class=p>().</span><span class=n>unwrap</span><span class=p>(),</span><span class=w> </span><span class=mi>10</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h3 id=4-syncsend-marker-traits>4. <code>Sync</code>、<code>Send</code> marker traits<a hidden class=anchor aria-hidden=true href=#4-syncsend-marker-traits>#</a></h3><p>実は上の<code>Arc&lt;></code>か<code>Mutex&lt;></code>、また<code>mpsc::Channel()</code>などはライブラリの機能で、Rust自体の文法的な機能ではない。しかし言語自他が内部的に定義しているコンセプトはあって、それが<code>Sync</code>と<code>Send</code> traitである。</p><h4 id=a-send>a. <code>Send</code><a hidden class=anchor aria-hidden=true href=#a-send>#</a></h4><blockquote><p><a href=https://doc.rust-lang.org/std/marker/trait.Send.html>https://doc.rust-lang.org/std/marker/trait.Send.html</a>This trait is automatically implemented when the compiler determines it&rsquo;s appropriate.</p></blockquote><p><code>Send</code> marker traitは実装した型のデータはスレッド間転送できるようになる。ほぼ全てのRustのタイプは<code>Send</code>を実装しているが、<code>Rc&lt;T></code>のようにSendできないタイプも存在する。</p><p>上でも書かれたように、ある構造体のすべての変数が<code>Send</code>を実装していれば、その構造体自体も自動に<code>Send</code>を実装したことになる。ほぼ全ての<code>unsafe</code>なpointerタイプを除外したPrimitive Typeは<code>Send</code>をサポートする。</p><h4 id=b-sync>b. <code>Sync</code><a hidden class=anchor aria-hidden=true href=#b-sync>#</a></h4><p><code>Sync</code>を実装したデータ型は、マルチスレッド環境で複数のスレッドから接近されても安全であることを示す。つまり上の<code>Send</code>と合わせて、もし<code>&T</code>が<code>Send</code>で、そして<code>T</code>が<code>Sync</code>ならば別のスレッドにRefを転送してその中で使わせることが出来るということである。</p><p>ちなみにPrimitive Typeは<code>Sync</code>で、このTraitも構造体の変数が全て<code>Sync</code>ならば自動に<code>Sync</code>が実装される。</p><p>また、<code>Mutex&lt;T></code>は<code>Sync</code>だけど<code>RefCell&lt;T></code>か<code>Cell&lt;T></code>はBorrowingルールがランタイムで動作することもあり、スレッドセーフではないため<code>Sync</code>が実装されない。なので他のスレッドに同時接近させることが出来ない。</p><h4 id=c-sendとsyncの自前実装はunsafe>c. <code>Send</code>と<code>Sync</code>の自前実装は<code>unsafe</code><a hidden class=anchor aria-hidden=true href=#c-sendとsyncの自前実装はunsafe>#</a></h4><p><code>Send</code>と<code>Sync</code> marker traitを自前で実装するのは<code>unsafe</code>になる。基本的にはコンパイラが自動で実装してくれる。</p><h2 id=pattern-matching>Pattern Matching<a hidden class=anchor aria-hidden=true href=#pattern-matching>#</a></h2><h3 id=1-function-parameters>1. Function Parameters<a hidden class=anchor aria-hidden=true href=#1-function-parameters>#</a></h3><p>関数のパラメータもパターンに成れる。以下のコードがあったとすると、</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>foo</span><span class=p>(</span><span class=n>x</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// ...
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p><code>x</code>の部分は<code>match</code>か<code>if let, while let</code>のようにパターンとして扱うことが出来る。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>print_coordinates</span><span class=p>(</span><span class=o>&amp;</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>)</span>: <span class=kp>&amp;</span><span class=p>(</span><span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=kt>i32</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Current Location : ({}, {})&#34;</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>point</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>print_coordinates</span><span class=p>(</span><span class=o>&amp;</span><span class=n>point</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h3 id=2-refutableirrefutable>2. refutable、irrefutable<a hidden class=anchor aria-hidden=true href=#2-refutableirrefutable>#</a></h3><ul><li>refutable pattern：パターンマッチングで、パターンが合わなく該当するロジックがなかったことに見なすことが出来るコードのパターンを指す。例えば、<code>if let</code>とか<code>while let</code>のようなマッチングパターンが含まれる。</li><li>irrefutable pattern：パターンマッチングで、パターンが必ず合って関連したロジックが実行されるか評価される。<code>let</code>、<code>for</code>が含まえる。</li></ul><p>例えば、<code>Option&lt;T></code>になにかの値がある時に<code>let</code>を使って以下の構文を作るのは出来ない。なぜなら<code>let</code>は必ずirrefutable patternにならなければならないからだ。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>some_option_value</span><span class=p>;</span><span class=w>
</span></code></pre></div><p>しかし、<code>it let</code>を使ったらビルドが通る。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>some_option_value</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// ...
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>だが、irrefutable patternをrefutable patternに当てはめることは出来ない。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// BUILD ERROR!
</span><span class=c1></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cm>/*
</span><span class=cm>$ cargo run
</span><span class=cm>warning: irrefutable if-let pattern
</span><span class=cm> --&gt; src/main.rs:2:5
</span><span class=cm>  |
</span><span class=cm>2 | /     if let x = 5 {
</span><span class=cm>3 | |         println!(&#34;{}&#34;, x);
</span><span class=cm>4 | |     };
</span><span class=cm>  | |_____^
</span><span class=cm>  |
</span><span class=cm>  = note: `#[warn(irrefutable_let_patterns)]` on by default
</span><span class=cm>
</span><span class=cm>    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
</span><span class=cm>     Running `target/debug/patterns`
</span><span class=cm>5
</span><span class=cm>*/</span><span class=w>
</span></code></pre></div><h3 id=3-pattern-syntax>3. Pattern Syntax<a hidden class=anchor aria-hidden=true href=#3-pattern-syntax>#</a></h3><h4 id=a-matching-named-variables>a. Matching Named Variables<a hidden class=anchor aria-hidden=true href=#a-matching-named-variables>#</a></h4><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>match</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=nb>Some</span><span class=p>(</span><span class=mi>50</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Got 50&#34;</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=nb>Some</span><span class=p>(</span><span class=n>y</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Matched, y = {:?}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>),</span><span class=w> </span><span class=c1>// ...(1)
</span><span class=c1></span><span class=w>    </span><span class=nb>Some</span><span class=p>(</span><span class=n>new_var</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Matched, new = {:?}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>new_var</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Default case. None.&#34;</span><span class=p>),</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p><code>...(1)</code>のように既存の変数を使ってパターンマッチングに使わせることも出来る。</p><h4 id=b-multiple-patterns>b. Multiple Patterns<a hidden class=anchor aria-hidden=true href=#b-multiple-patterns>#</a></h4><p>Virtical Pipe文法（<code>|</code>）を使って、複数のパターンをORでマッチングをさせることも出来る。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>match</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=mi>1</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;one or two&#34;</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=mi>3</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;three!&#34;</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;whatever&#34;</span><span class=p>),</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h4 id=c-を使ってinclusiveな範囲マッチング>c. <code>..=</code>を使ってInclusiveな範囲マッチング<a hidden class=anchor aria-hidden=true href=#c-を使ってinclusiveな範囲マッチング>#</a></h4><p><code>..=</code>文法は値の範囲を決めるようにする。しかし、制限があってPrimitive Typeの数型または<code>char</code>タイプしか範囲を決めることが出来ない。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=sc>&#39;c&#39;</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>match</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=sc>&#39;a&#39;</span><span class=p>..</span><span class=o>=</span><span class=sc>&#39;j&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;early ASCII letters&#34;</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=sc>&#39;k&#39;</span><span class=p>..</span><span class=o>=</span><span class=sc>&#39;z&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;late ASCII letters&#34;</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;something else&#34;</span><span class=p>),</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>ちなみにRustのstable版では<code>..=</code>じゃなく<code>..</code>を使ってパターンマッチングさせる文法は実験機能として使えない。</p><blockquote><pre><code class=language-rust_errors data-lang=rust_errors>error[E0658]: exclusive range pattern syntax is experimental
</code></pre><p><a href=https://github.com/rust-lang/rust/issues/37854>https://github.com/rust-lang/rust/issues/37854</a></p></blockquote><h4 id=d-構造体の変数の分解>d. 構造体の変数の分解<a hidden class=anchor aria-hidden=true href=#d-構造体の変数の分解>#</a></h4><p>構造体と中の変数が見えてる限り（<code>pub</code>）、構造体の変数を分解することが出来る。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>struct</span> <span class=nc>Point</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>x</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=kt>i32</span>
<span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=mi>7</span><span class=w> </span><span class=p>};</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=nc>a</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=nc>b</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>p</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=mi>7</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>または変数の名前をそのまま使ってパターンマッチングさせることも出来る。（irrefutable patternになること）</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=mi>7</span><span class=w> </span><span class=p>};</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>p</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>y</span><span class=p>,</span><span class=w> </span><span class=mi>7</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>このような文法を使って、<code>match</code>にも活かせる。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=mi>7</span><span class=w> </span><span class=p>};</span><span class=w>
</span><span class=w>   	</span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=mi>0</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=cm>/* ... */</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=cm>/* ... */</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=cm>/* ... */</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h4 id=e-多重の構造体またはenumの分解>e. 多重の構造体または<code>enum</code>の分解<a hidden class=anchor aria-hidden=true href=#e-多重の構造体またはenumの分解>#</a></h4><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>enum</span> <span class=nc>Color</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>Rgb</span><span class=p>(</span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=kt>u8</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=n>Hsv</span><span class=p>(</span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=kt>u8</span><span class=p>),</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>enum</span> <span class=nc>Message</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>Quit</span><span class=p>,</span><span class=w> 
</span><span class=w>    </span><span class=n>Move</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=kt>i32</span> <span class=p>},</span><span class=w>
</span><span class=w>    </span><span class=n>Write</span><span class=p>(</span><span class=n>std</span>::<span class=nb>String</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=n>ChangeColor</span><span class=p>(</span><span class=n>Color</span><span class=p>),</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>msg</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Message</span>::<span class=n>ChangeColor</span><span class=p>(</span><span class=n>Color</span>::<span class=n>Hsv</span><span class=p>(</span><span class=mi>15</span><span class=p>,</span><span class=w> </span><span class=mi>128</span><span class=p>,</span><span class=w> </span><span class=mi>255</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>msg</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Message</span>::<span class=n>Move</span><span class=p>{</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>}</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=cm>/* ... */</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>Message</span>::<span class=n>ChangeColor</span><span class=p>(</span><span class=n>Color</span>::<span class=n>Hsv</span><span class=p>(</span><span class=n>h</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>))</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=cm>/* ... */</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>Message</span>::<span class=n>ChangeColor</span><span class=p>(</span><span class=n>Color</span>::<span class=n>Rgb</span><span class=p>(</span><span class=n>r</span><span class=p>,</span><span class=w> </span><span class=n>g</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>))</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=cm>/* ... */</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>(),</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h4 id=f-を使って使わない変数たちを無視する>f. <code>..</code>を使って使わない変数たちを無視する<a hidden class=anchor aria-hidden=true href=#f-を使って使わない変数たちを無視する>#</a></h4><p><code>_</code>は単一変数を無視することで、<code>..</code>は変数組を無視する効果を持つ。ただし、<code>..</code>を使う際にはどの変数まで無視して使わないようにするかがはっきりしていなければならない。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>struct</span> <span class=nc>Point</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>x</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>z</span>: <span class=kt>i32</span>
<span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>origin</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Point</span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=n>z</span>: <span class=mi>2</span><span class=w> </span><span class=p>};</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>origin</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Point</span><span class=p>{</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=p>..</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;x is {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>numbers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>8</span><span class=p>,</span><span class=w> </span><span class=mi>16</span><span class=p>,</span><span class=w> </span><span class=mi>32</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>numbers</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>,</span><span class=w> </span><span class=p>..,</span><span class=w> </span><span class=n>h</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Some numbers: {}, {}, and {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>,</span><span class=w> </span><span class=n>h</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=p>},</span><span class=w>
</span><span class=w>        </span><span class=c1>// (.., w, ..) =&gt; ERROR STATEMENTS.
</span><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h4 id=g-match-guardを使って条件の追加提示>g. <em>match guard</em>を使って条件の追加提示<a hidden class=anchor aria-hidden=true href=#g-match-guardを使って条件の追加提示>#</a></h4><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=n>num</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=k>match</span><span class=w> </span><span class=n>num</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=nb>Some</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>x</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>4</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;less than five: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=nb>Some</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>(),</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h4 id=h--at-operatorを使って同時に変数を生成>h. <code>@</code> at operatorを使って同時に変数を生成<a hidden class=anchor aria-hidden=true href=#h--at-operatorを使って同時に変数を生成>#</a></h4><p><em>at</em>演算子（<code>@</code>）はパターンマッチングをやりながら、マッチングされた時に変数を生成して中身で活用するようにする。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=w>    </span><span class=k>enum</span> <span class=nc>Message</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Hello</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>id</span>: <span class=kt>i32</span> <span class=p>},</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>msg</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Message</span>::<span class=n>Hello</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>id</span>: <span class=mi>5</span><span class=w> </span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>msg</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Message</span>::<span class=n>Hello</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>id</span>: <span class=nc>id_variable</span><span class=w> </span><span class=o>@</span><span class=w> </span><span class=mi>3</span><span class=p>..</span><span class=o>=</span><span class=mi>7</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Found an id in range: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>id_variable</span><span class=p>),</span><span class=w>
</span><span class=w>        </span><span class=n>Message</span>::<span class=n>Hello</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>id</span>: <span class=mi>10</span><span class=p>..</span><span class=o>=</span><span class=mi>12</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Found an id in another range&#34;</span><span class=p>)</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=n>Message</span>::<span class=n>Hello</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Found some other id: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>id</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span></code></pre></div></div><footer class=post-footer><nav class=paginav><a class=prev href=https://liliilli.github.io/posts/rust_3_memo/><span class=title>« Prev Page</span><br><span>Rustメモ（2020-11-21~）</span></a>
<a class=next href=https://liliilli.github.io/posts/rust_1_memo/><span class=title>Next Page »</span><br><span>Rustメモ（20-11-16～20-11-19)</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Rustメモ（20-11-20～) on twitter" href="https://twitter.com/intent/tweet/?text=Rust%e3%83%a1%e3%83%a2%ef%bc%8820-11-20%ef%bd%9e%29&url=https%3a%2f%2fliliilli.github.io%2fposts%2frust_2_memo%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Rustメモ（20-11-20～) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fliliilli.github.io%2fposts%2frust_2_memo%2f&title=Rust%e3%83%a1%e3%83%a2%ef%bc%8820-11-20%ef%bd%9e%29&summary=Rust%e3%83%a1%e3%83%a2%ef%bc%8820-11-20%ef%bd%9e%29&source=https%3a%2f%2fliliilli.github.io%2fposts%2frust_2_memo%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Rustメモ（20-11-20～) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fliliilli.github.io%2fposts%2frust_2_memo%2f&title=Rust%e3%83%a1%e3%83%a2%ef%bc%8820-11-20%ef%bd%9e%29"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Rustメモ（20-11-20～) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fliliilli.github.io%2fposts%2frust_2_memo%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Rustメモ（20-11-20～) on whatsapp" href="https://api.whatsapp.com/send?text=Rust%e3%83%a1%e3%83%a2%ef%bc%8820-11-20%ef%bd%9e%29%20-%20https%3a%2f%2fliliilli.github.io%2fposts%2frust_2_memo%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Rustメモ（20-11-20～) on telegram" href="https://telegram.me/share/url?text=Rust%e3%83%a1%e3%83%a2%ef%bc%8820-11-20%ef%bd%9e%29&url=https%3a%2f%2fliliilli.github.io%2fposts%2frust_2_memo%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright © 2008–2019, Steve Francia and the Hugo Authors; all rights reserved.</span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>