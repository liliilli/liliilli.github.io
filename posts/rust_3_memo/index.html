<!DOCTYPE html>
<html lang="en">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<title>Rustメモ（2020-11-21~） - neuromantic</title>

<meta name="description" content="unsafe unsafeコードブロックを使うことによって、Safeなコード（普通のRustコード）では出来なかったことが出来るようになる。つまり、所有">
<meta name="keywords" content= />
<meta name="author" content="Jongmin Yun, Neu.">
<link rel="canonical" href="https://liliilli.github.io/posts/rust_3_memo/" />
<link href="https://liliilli.github.io/assets/css/stylesheet.min.a3b13905fd4b98ea165a18374ae5215d9de97a04f187f789736c56858296ba12.css" integrity="sha256-o7E5Bf1LmOoWWhg3SuUhXZ3pegTxh/eJc2xWhYKWuhI=" rel="preload stylesheet"
    as="style">
<link rel="apple-touch-icon" href="https://liliilli.github.io/apple-touch-icon.png">
<link rel="icon" href="https://liliilli.github.io/favicon.ico">
<meta name="generator" content="Hugo 0.75.1" />


</head>

<body class="single" id="top">
<header class="header">
    <nav class="nav">
        <p class="logo"><a href="https://liliilli.github.io">neuromantic</a></p>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://liliilli.github.io/posts/">
                    <span>
                        Posts
                    </span>
                </a>
            </li>
            <li>
                <a href="https://liliilli.github.io/archives/">
                    <span>
                        Archives
                    </span>
                </a>
            </li>
            <li>
                <a href="https://liliilli.github.io/tags/">
                    <span>
                        Tags
                    </span>
                </a>
            </li>
            <li>
                <a href="https://liliilli.github.io/series/">
                    <span>
                        Series
                    </span>
                </a>
            </li>
        </ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      Rustメモ（2020-11-21~）
    </h1>
    <div class="post-meta">
      <time>November 21, 2020</time>&nbsp;·&nbsp;Jongmin Yun, Neu.
    </div>
  </header>
  <div class="post-content"><h2 id="unsafe"><code>unsafe</code></h2>
<p><code>unsafe</code>コードブロックを使うことによって、Safeなコード（普通のRustコード）では出来なかったことが出来るようになる。つまり、所有権などのRustの特有の制限、動作にこだわらなくても構わなくなる。しかし、その分の責任はすべてコードを作成するプログラマーの分になる。</p>
<p>また、Rustが<code>unsafe</code>なコードを制限的に許容している理由としては、OSのAPIまたはそれに準ずるロジックをさせるためには<code>unsafe</code>じゃなければならなかったためである。ローレベルシステムプログラミングなどを行うためには<code>unsafe</code>ブロックの中でポインターの演算などをすることがある。</p>
<p>とにかく<code>unsafe</code>ブロックの中でロジックを書くか、それとも<code>unsafe</code>な関数などを書くことによって以下の機能が使えるようになる。</p>
<ul>
<li>生ポインター（<code>*const T</code>、<code>*mut T</code>）のDerefが出来る</li>
<li><code>unsafe</code>な関数なメソッドの呼び出しができる</li>
<li><code>static</code>スコープの変数の接近と更新ができる</li>
<li><code>unsafe</code>なtraitの実装ができる（<code>Send</code>か<code>Sync</code>などの）</li>
<li><code>union</code>のフィルドの接近ができる</li>
</ul>
<p>しかし、<code>unsafe</code>コードブロックの中でもBorrowチェッカーとRust特有の安全性チェックはずっと有効になる。また、<code>unsafe</code>は外に見えるようにするのではく可能な限り範囲を少なくして安全なAPIで囲んで書くようにする方が望ましい。</p>
<h3 id="1-const-tmut-t">1. <code>*const T</code>、<code>*mut T</code></h3>
<p>生ポインターのタイプを使うことによって、</p>
<ul>
<li>ポインターだけBorrowingルールが無視できる。つまり、ImmutableなポインターとMutableなポインターが同じスコープで同時に存在できるようになる。</li>
<li>しかし、必ず有効なメモリアドレスの位置を指しているとは保証できない。</li>
<li><code>nullptr</code>である可能性がある。</li>
<li>他の型とは違ってRAIIをしない。なのでポインターを参照しているメモリが無効化されてもポインターはずっと初期化されたアドレスを持っていまう。</li>
</ul>
<p>念頭すべき点としては、生ポインタータイプ自体は<code>unsafe</code>ブロックの外でも作れることがある。ポインターだけを作るのはメモリ上に何の害もないからだ。（ポインターを使ってなにかをすることが問題なだけ）</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">num</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">pmut_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>生ポインタータイプの変数を生成する時には、<code>as</code>を使って既存の<code>&amp;</code>か<code>&amp;mut</code>になるはずだったの参照を生ポインターとして変換する。</p>
<p>参照だけではなく、ただの値をそのままポインターに変換してしまうことも出来る。（要注意）</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">address_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xDEADBEEF</span><span class="k">usize</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address_val</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>しかし、ポインターをDerefして接近したりするためには<code>unsafe</code>ブロックの中でしか行えない。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">num</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;r1 is : {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">p_num</span><span class="p">);</span><span class="w"> </span><span class="c1">// Deref must be held in `unsafe` block code.
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>また、一番上のコードのように<code>*const i32</code>と<code>*mut i32</code>が共存するのが見えるけど、基の<code>&amp;</code>と<code>&amp;mut</code>だとしたらこのコードはビルドが失敗するか、ランタイムでBorrowチェッカーによって<code>panic!</code>になってしまう。しかし、生ポインターはBorrowチェッカーが動作しないため、不変と可変が共存することが出来る。</p>
<h3 id="2-unsafeコードをsafeなapiとして使わせる方法">2. <code>unsafe</code>コードをSafeなAPIとして使わせる方法</h3>
<p>もし、次のようなコードがあって、<code>split_at_mut</code>関数は<code>vec!</code>のスライスを最初から進んだ地点からを基点として左右を分けて<code>&amp;[T]</code>を返す関数だとする。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="p">[..];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">split_at_mut</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">]);</span><span class="w">
</span></code></pre></div><p>しかし、Safeなコード書くだけの観点から見れば、<code>split_at_mut()</code>から返される複数のサブスコープを持ったスライスの参照はBorowが複数起こるはずなので関数として作れなさそうに見える。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">split_at_mut</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">slice</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">],</span><span class="w"> </span><span class="n">mid</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">mid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w">
</span><span class="w">   	</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">slice</span><span class="p">[..</span><span class="n">mid</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">slice</span><span class="p">[</span><span class="n">mid</span><span class="p">..])</span><span class="w"> </span><span class="c1">// Multiple borrow, failed to build.
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>意図通りに<code>split_at_mut</code>で割り当てられた範囲を真っ二つに分けるためには、Borrowチェッカーを回避する必要がある。なので、ここで<code>unsafe</code>を使ってしまう。</p>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_mut_ptr">https://doc.rust-lang.org/std/primitive.slice.html#method.as_mut_ptr</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">split_at_mut</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">slice</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">],</span><span class="w"> </span><span class="n">mid</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">mid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p_slice</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slice</span><span class="p">.</span><span class="n">as_mut_ptr</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Successful build.
</span><span class="c1"></span><span class="w">        </span><span class="p">(</span><span class="w">
</span><span class="w">            </span><span class="n">slice</span>::<span class="n">from_raw_parts_mut</span><span class="p">(</span><span class="n">p_slice</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">slice</span>::<span class="n">from_raw_parts_mut</span><span class="p">(</span><span class="n">p_slice</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">mid</span><span class="p">),</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mid</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>上のコードで使う<code>slice::from_raw_parts_mut()</code>は<code>unsafe</code>なので、<code>unsafe</code>コードブロックの中でしか使えない。ポインター演算が上手く使えなかったらC/C++系列の言語で見れる未定義行動が起こってしまう可能性もある。</p>
<h3 id="3-extern関数で外部のコードを呼ぶ">3. <code>extern</code>関数で外部のコードを呼ぶ</h3>
<p>Rustでの<code>extern</code>キーワードは、*Foreign Function Interface (FFI)*を使うためのものとして、つまりC言語で書かれたまたはC言語関数、または構造体の規約を沿っている任意言語のAPI、もしくは変数を生成する時に使われる。</p>
<p><code>extern</code>ブロックで宣言された関数などは全部<code>unsafe</code>扱いになる。なぜなら、Rust独自の仕様ではない可能性があるため、Rustで使っているBorrowチェッカー、参照・可変参照の制限が無用になるからだ。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">abs</span><span class="p">(</span><span class="n">input</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Absolute value of -3 according to C: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>extern &quot;C&quot;</code>ブロックを指定することによって、その中の関数はC言語のABIとして動作することになる。（ABIではCPPでの<code>__cdecl</code>、<code>__stdcall</code>、<code>__fastcall</code>のようなコール規約も含まれる）</p>
<p>もし、Rustの関数をC言語の規約として作って外側のFFIをサポートする任意言語のコードで使わせるとしたら、<code>extern &quot;C&quot;</code>ブロックではなく普通の関数に<code>extern &quot;C&quot;</code>を書く。しかし、ABI規約をC言語にしたのとは別で関数名のManglingはまだ有効化されたままなので、指定した関数の名前そのものが公開できるようにするために<code>#[no_mangle]</code>Annotationを付けなければならない。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[no_mangle]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">call_from_c</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Just called a Rust function from C!&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w"> 
</span></code></pre></div><h3 id="4-static変数に接近更新">4. Static変数に接近・更新</h3>
<p>一応Rustも<code>static</code>キーワードを付けることとしてグローバルスコープの変数をサポートしているが、Rust特有の所有権ルールに矛盾してしまう問題がある。<code>static</code>になった変数はマルチスレッド環境でどのスレッドでの露出されてしまうので、簡単にデータ競合が起こりえる。</p>
<p>ただ、<code>static</code>変数を不変<code>&amp;</code>として読み込んで接近することは上のような問題が起こらないので安全なコードの中でも使える。しかし<code>&amp;mut</code>として接近したり、そもそも<code>static</code>が<code>mut</code>の変数だったり、値を変更しようとするなら<code>unsafe</code>ブロックを使わなければならない。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">static</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">COUNTER</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">add_to_count</span><span class="p">(</span><span class="n">val</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">COUNTER</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">inc</span><span class="p">;</span><span class="w"> </span><span class="c1">// Not thread-safe
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;COUNTER: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">COUNTER</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="5-unionの使用">5. <code>union</code>の使用</h3>
<blockquote>
<p><a href="https://doc.rust-lang.org/reference/items/unions.html">https://doc.rust-lang.org/reference/items/unions.html</a></p>
</blockquote>
<p>Rust自体も<code>union</code>をサポートしているが、大体のことは<code>enum</code>で各値に変数などを持たせることによって解決できるし、実装の意図もFFIとして動作させるためだけだったのであえて使うためには<code>unsafe</code>ブロックの中で使用しなければならない。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[repr(u32)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Tag</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="p">}</span><span class="w"> 
</span><span class="w">
</span><span class="w"></span><span class="cp">#[repr(C)]</span><span class="w">
</span><span class="w"></span><span class="k">union</span> <span class="nc">U</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">i</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">f</span>: <span class="kt">f32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[repr(C)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Value</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">tag</span>: <span class="nc">Tag</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">u</span>: <span class="nc">U</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">is_zero</span><span class="p">(</span><span class="n">v</span>: <span class="nc">Value</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Value</span><span class="p">{</span><span class="w"> </span><span class="n">tag</span>: <span class="nc">Tag</span>::<span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">u</span>: <span class="nc">U</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">i</span>: <span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">Value</span><span class="p">{</span><span class="w"> </span><span class="n">tag</span>: <span class="nc">Tag</span>::<span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">u</span>: <span class="nc">U</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span>: <span class="nc">num</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="k">f32</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="advanced-traits">Advanced Traits</h2>
<h3 id="1-operator-overloading">1. operator overloading</h3>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a></p>
</blockquote>
<p>Rustでは各種オペレーターは全部<code>trait</code>を実装してメソッドをオーバーライドすれば動作する仕組みとなっている。今までのチュートリアルで見てきた参照または<code>Box&lt;T&gt;</code>などのスマートポインタの前に付けられる<code>*</code>（逆参照）も<code>Deref</code>を実装したものに過ぎない。</p>
<p>例えば<code>std::ops::Add&lt;RHS&gt;</code>を任意の構造体に実装して、<code>+</code>演算子が使えるようにするとしよう。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Add</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span>
<span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Point</span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">Point</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Point</span>::<span class="n">new</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="n">Point</span>::<span class="n">new</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>std::ops::Add</code> traitの内部は次のようになっている。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">=</span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Rhs=Self</code>とは、ジェネリックに見えそうだけど正確には「基本タイプパラメータ」（Default Type Parameters）と呼ぶ。このTraitを任意のタイプに対して実装する時に、基本パラメータが指定されているので、<code>impl Add for Point</code>のような書き方が出来る。</p>
<p>型さえ指定していれば他のタイプに対して特殊な<code>add()</code>を書くのも出来る。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Debug, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">IdentityPoint</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">IdentityPoint</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">IdentityPoint</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Point</span>::<span class="n">new</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="2-ambiguousな関数の明示的な呼び出し">2. Ambiguousな関数の明示的な呼び出し</h3>
<p>次のようなコードがある時、</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Pilot</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Human</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Pilot</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;This is your captain speaking.&#34;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fly_anyway</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Airplane is falling!&#34;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Up!&#34;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fly_anyway</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;You are not wizard. You can not fly.&#34;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;*waving arms furiously*&#34;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fly_anyway</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;*waving arms furiously*&#34;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Human{}.fly()</code>としてどんな関数が呼ばれるかを見てみると、<code>Human</code>で直接実装した<code>fly()</code>関数が呼ばれることがわかる。しかし、<code>Wizard</code>と<code>Pilot</code>のメソッドを呼ぶためには明示的な方法を使うしかない。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">person</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Human</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">Pilot</span>::<span class="n">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="n">person</span><span class="p">);</span><span class="w">  </span><span class="c1">// &#34;This is your captain speaking.&#34;;
</span><span class="c1"></span><span class="n">Wizard</span>::<span class="n">fly</span><span class="p">(</span><span class="o">&amp;</span><span class="n">person</span><span class="p">);</span><span class="w"> </span><span class="c1">// &#34;Up!&#34;
</span><span class="c1"></span><span class="n">person</span><span class="p">.</span><span class="n">fly</span><span class="p">();</span><span class="w">         </span><span class="c1">// &#34;*waving arms furiously*&#34;
</span></code></pre></div><p>もし、メソッドに<code>&amp;self</code>か<code>&amp;mut self</code>の自分を指す引数がない場合には、次のように関数を立ち上げるしかない。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">Human</span>::<span class="n">fly_anyway</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="o">&lt;</span><span class="n">Human</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Pilot</span><span class="o">&gt;</span>::<span class="n">fly_anyway</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="o">&lt;</span><span class="n">Human</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Wizard</span><span class="o">&gt;</span>::<span class="n">fly_anyway</span><span class="p">();</span><span class="w">
</span></code></pre></div><h3 id="3-traitの実装を要求するtraitの実装">3. traitの実装を要求するtraitの実装</h3>
<p>Rustでコードを書いたら、traitのメソッド、機能を使うtraitを実装したくなる時がある。この時にはtraitの定義コードを書く時、要件とする<code>trait</code>を書くことによって、新しく定義したtraitは依存しようとする<code>trait</code>の機能が中身で使えるようになる。この依存しようとするtraitを<code>Supertrait</code>と呼ぶ。</p>
<p>もし次のようなコードがあるとして、</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">OutlinePrint</span>: <span class="nc">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">outline_print</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w"> </span><span class="c1">// use feature of std::fmt::Display trait.
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">output</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="c1">// ...
</span><span class="c1"></span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;* {} *&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>ここで<code>supertrait</code>を定義するには、traitの名前の定義の後ろに依存するtraitを書く。上の<code>OutlinePrint</code> traitでは<code>std::fmt::Display</code> traitを依存しようとしている。</p>
<p>ここで<code>Point</code>に<code>OutlinePrint</code>を実装させるが、下のコードだけじゃビルドが通らない。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">OutlinePrint</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>なぜなら、<code>OutlinePrint</code>は<code>std::fmt::Display</code> traitを依存しているのに、<code>Point</code>はまだそのtraitを実装していなかったからだ。なので、<code>#[derive(Display)]</code> Annotationで自動実装させるようにするか、それとも直接実装するしかない。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;({}, {})&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="advanced-types">Advanced Types</h2>
<h3 id="1-type-aliases-type">1. Type aliases <code>type</code></h3>
<p>C++11またはC++03の<code>using</code>、<code>typedef</code>のようにRustも<code>type</code>キーワードでタイプに対する別称を指定することが出来る。<code>type</code>キーワードは<code>trait</code>の中でAnnotation Typeだけではなく下の形でも使える。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">AliasI32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span>: <span class="nc">AliasI32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;x + y = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>type</code>を使ったType Aliasは主に<code>std::Result&lt;T, E&gt;</code>でよく使われる。基本的に<code>std</code>の各モジュールごとに<code>Error</code>があって、各モジュールで<code>Result&lt;T, E&gt;</code>を吐き出す時に<code>E</code>は各モジュールのErrorになるため、各<code>fn</code>か構造体ごとにフルネームを一つ一つ書かせるのって手間がかかりすぎるからだ。</p>
<p>なので、一般的にはこんな感じで<code>Result</code>の書き方を簡潔にしている。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">result</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Write</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">flush</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">write_all</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">write_fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span>: <span class="nc">std</span>::<span class="n">fmt</span>::<span class="n">Arguments</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="2--never-type">2. <code>!</code> <em>never type</em></h3>
<p>Rustは<code>continue</code>、<code>loop</code>または他のマクロ、関数などで特殊な用途として使わせるためのタイプ、<code>!</code>（Never Type）をサポートしている。Never Typeは、関数自体または式の終わりで返す値がなく（<code>void</code>とは違う）特定の状態に落ちずに次にくるロジックを行うことを指す。</p>
<p>上でも説明したように、<code>loop</code>または<code>continue</code>はこのNever Typeを内包していて、次のようなコードが出来るようになる。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">guess</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">guess</span><span class="p">.</span><span class="n">trim</span><span class="p">().</span><span class="n">parse</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">continue</span><span class="p">,</span><span class="w"> </span><span class="c1">// use &#39;!&#39; never type not to return into guess.
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">   </span><span class="c1">// use &#39;!&#39; to loop.
</span></code></pre></div><p><code>match</code>分のすべてのケースは最後に返されるタイプが同じじゃなければならないが、<code>!</code>が実装されたタイプまたはキーワードを返すことによって型推論から除外できるようになる。</p>
<p>ちなみに<code>panic!</code>マクロもこのNever typeを使っている。</p>
<h3 id="3-dstとdynとsized-trait">3. DSTと<code>dyn</code>と<code>Sized</code> trait</h3>
<p>Rustの関数のパラメータと構造体の引数の型は必ずコンパイルタイムで該当タイプのサイズがわからなければならない…（Genericも特殊化されるものを含めて）が、実はそうではなくてコンパイルタイムでサイズがわからなくても特定 traitなどに関連づけられたタイプ郡をタイプとして受け取りさせることが出来る。</p>
<p><code>dyn</code>キーワードは<code>impl</code>のように特定のTraitを実装したタイプ郡だけを受け取るために使える。ただ、<code>impl</code>はジェネリックの型を決める時か、Traitを実装しようとした時にだけ使えるキーワードで、<code>dyn</code>は<code>&amp;mut dyn</code>、<code>Box&lt;dyn Trait&gt;</code>、<code>Rc&lt;dyn Trait&gt;</code>、<code>Arc&lt;dyn Trait&gt;</code>のようにもっと具体的な変数かパラメータタイプに使える。</p>
<p><code>dyn</code>キーワード自体はDynamicの略語として、フルネームとしてはdynamically sized typesを指す。つまり、コンパイルタイムではサイズがはっきり決まってないタイプを指す用語で、Rustでは<code>str</code>と各種traitが該当される。</p>
<p>DSTを取り入れるために、Rustは<code>Sized</code>という特殊なtraitを実装している。<code>Sized</code>traitはコンパイルタイムでサイズがわかる全てのタイプに実装されるTraitである。また、Rustは全てのジェネリック関数に黙示的に<code>Sized</code> traitが実装されたかを追加する。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">generic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// -- snip --
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>が実は、</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">generic</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// -- snip --
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>として解釈される。なので一般的に全ての型引数はコンパイルタイムでサイズがわからないとならない。しかし、DSTに対応するために<code>Sized</code> traitだけ追加的に<code>?Sized</code>という書き方が出来るようになっていて、その時にはDSTのタイプも型引数として受け取るようにしている。</p>
<p>しかし、DSTは単特としては存在できないし、必ずDSTが受け取れるタイプと連携して（Reference, Box, Rc, Arcなど…）使わなければならない。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">generic</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// -- snip --
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="advanced-functions-and-closures">Advanced Functions and Closures</h2>
<h3 id="1-関数ポインタ-fn">1. 関数ポインタ <code>fn</code></h3>
<p>クロージャじゃない一般関数、またメソッドは<code>fn</code>タイプとして扱える。<code>Fn</code> traitとは違って、単純な関数ポインタを指す。</p>
<p>もちろん<code>fn</code>もクロージャと同じく条件によって<code>FnOnce</code>、<code>FnMut</code>、<code>Fn</code> traitを実装している。なのでクロージャを入れるようにしているパラメータか、それとも<code>dyn</code>などにも関数ポインタを入れることが出来る。</p>
<p><code>fn</code>タイプの基本使い方は以下のコードを見ればわかるはず…</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">do_twice</span><span class="p">(</span><span class="n">f</span>: <span class="nc">fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">f</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">do_twice</span><span class="p">(</span><span class="n">add_one</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;The answer is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">answer</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>また、クロージャを入れるIteratorのIterator consume methodにも関数ポインタが入れられる。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">list_of_number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">list_of_string</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list_of_number</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="nb">ToString</span>::<span class="n">to_string</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span></code></pre></div><h3 id="2-クロージャを返し方">2. クロージャを返し方</h3>
<p>クロージャ自体はTraitとして現れているので、特定の型として返すのは出来ない。しかしクロージャがTraitとして表現出来ているのであると、DSTになるので<code>dyn</code>を使ってなんとか返せる。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">returns_closure</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="macro"><code>macro!</code></h2>
<blockquote>
<p><a href="https://doc.rust-lang.org/reference/macros-by-example.html">https://doc.rust-lang.org/reference/macros-by-example.html</a></p>
</blockquote>
<h3 id="1-概要">1. 概要</h3>
<p>RustのマクロはC・C++言語のマクロとはより柔軟にロジックが書けるようになっている。Rustでマクロを定義する時には<code>macro_rules!</code>と書く。</p>
<p>Rustのマクロの大種類は２つ存在して、<code>macro_rules!</code>をウィッシュとした宣言型マクロと、手続きマクロが存在する。</p>
<p>手続きとして生成されるマクロは３つの種類が存在する。</p>
<ul>
<li>structかenumに<code>#[derive()]</code>属性として追加される時のカスタム<code>#[derive]</code>マクロロジック</li>
<li>どの要素などでも使えるカスタム属性（Attribute）マクロ</li>
<li>関数とほぼ似ているが、渡された引数の種類かトークンによるパターンマッチングなどでの関数マクロ</li>
</ul>
<h3 id="2-macro_rulesと基本的な使い方">2. <code>macro_rules!</code>と基本的な使い方</h3>
<blockquote>
<p><a href="https://danielkeep.github.io/tlborm/book/mbe-min-debugging.html">https://danielkeep.github.io/tlborm/book/mbe-min-debugging.html</a></p>
</blockquote>
<p><code>macro_rules!</code>を使うことにより、宣言型のマクロ（Declarative Macro）が作成できるようになる。宣言型マクロはRustの<code>match</code>表現式とほぼ似ていて、実際に定義ブロックでパターンマッチングをやってロジックが生成することが出来る。</p>
<p>例えば、<code>vec![]</code>の場合には次のように定義されている。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[macro_export]</span><span class="w">
</span><span class="w"></span><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$x</span>: <span class="nc">expr</span><span class="w"> </span><span class="p">),</span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">temp_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="cm">/* Do preallocate logic... */</span><span class="w">
</span><span class="w">        </span><span class="cp">$(</span><span class="w">
</span><span class="w">            </span><span class="n">temp_vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="cp">$x</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">)</span><span class="o">*</span><span class="w">
</span><span class="w">        </span><span class="n">temp_vec</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>一番最初の<code>#[macro_export]</code> Annotationはマクロが定義されているCrateが他のとこのロジックに見えるようになると、外部で使えるよう設定する。これがないと、マクロ自体は内部でだけのスコープを持つ。</p>
<h3 id="3-手続きマクロの概要">3. 手続きマクロの概要</h3>
<blockquote>
<p><a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html">https://doc.rust-lang.org/proc_macro/struct.TokenStream.html</a></p>
</blockquote>
<p>手続きマクロは書き方が少しややこしいが、コードを入れて加工したり、なにかのロジックを行ってから加工されたロジックを返すことが出来る。宣言型とは違って、パターンマッチングでコードを書き換えたりすることとはちょっと方向性が異なる。</p>
<p>上で書いた細部種類全ほぼ同じ書き方として生成することが出来る。</p>
<p>手続きマクロを生成する時には、定義自体は今マクロを生成しようとしているCrateに必ず存在しなければならない。また、特殊なCrateをもたせてロジックを行うらしい。手続きマクロは次のように書く。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">proc_macro</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[some_attribute]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">some_name</span><span class="p">(</span><span class="n">input</span>: <span class="nc">TokenStream</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TokenStream</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>上の関数は<code>TokenStream</code>を入力として、トークンを加工してから<code>TokenStream</code>を出力とする手続きマクロを定義する。<code>TokenStream</code>を使うためには<code>proc_macro</code>というRust自体で提供しているCrateを使わなければならない。手続きマクロは上のような感じで骨子を作る。</p>
<p>そして<code>some_attribute</code>部分にどの種類としてのマクロを作るかを決める。また、同じCrateで様々な手続きマクロが作れる。</p>
</div>
  <footer class="post-footer">
  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2020 <a href="https://liliilli.github.io">neuromantic</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo️️</a>️</span>
    <span>&middot;</span>
    <span>Theme️ <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top">
    <button class="top-link" id="top-link" type="button">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6">
            <path d="M12 6H0l6-6z" /></svg>
    </button>
</a>
<script src="https://liliilli.github.io/assets/js/highlight.min.e7afc2928c0925d65c4732dfebe147014d91299a98e819e4b42f25c4fa68e91c.js" integrity="sha256-56/CkowJJdZcRzLf6&#43;FHAU2RKZqY6BnktC8lxPpo6Rw="></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();

            document.querySelector(this.getAttribute("href")).scrollIntoView({
                behavior: "smooth"
            });
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }
</script>
</body>

</html>