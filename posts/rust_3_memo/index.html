<!doctype html><html lang=en dir=" auto"><head><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=DotGothic16&family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel=stylesheet><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rustメモ（2020-11-21~） | neuromantic</title><meta name=keywords content><meta name=description content="unsafe unsafeコードブロックを使うことによって、Safeなコード（普通のRustコード）では出来なかったことが出来るようになる。つまり、所有"><meta name=author content="Jongmin Yun, Neu."><link rel=canonical href=https://liliilli.github.io/posts/rust_3_memo/><link crossorigin=anonymous href=/assets/css/stylesheet.min.80dbcc80c00cba63b71a6526cb77f5aab60620dd3fecc491bc3a5da1af3d4c62.css integrity="sha256-gNvMgMAMumO3GmUmy3f1qrYGIN0/7MSRvDpdoa89TGI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://liliilli.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://liliilli.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://liliilli.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://liliilli.github.io/apple-touch-icon.png><link rel=mask-icon href=https://liliilli.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.0"><meta property="og:title" content="Rustメモ（2020-11-21~）"><meta property="og:description" content="unsafe unsafeコードブロックを使うことによって、Safeなコード（普通のRustコード）では出来なかったことが出来るようになる。つまり、所有"><meta property="og:type" content="article"><meta property="og:url" content="https://liliilli.github.io/posts/rust_3_memo/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-21T23:10:01+09:00"><meta property="article:modified_time" content="2020-12-02T15:08:25+09:00"><meta property="og:site_name" content="neuromantic"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rustメモ（2020-11-21~）"><meta name=twitter:description content="unsafe unsafeコードブロックを使うことによって、Safeなコード（普通のRustコード）では出来なかったことが出来るようになる。つまり、所有"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://liliilli.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Rustメモ（2020-11-21~）","item":"https://liliilli.github.io/posts/rust_3_memo/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rustメモ（2020-11-21~）","name":"Rustメモ（2020-11-21~）","description":"unsafe unsafeコードブロックを使うことによって、Safeなコード（普通のRustコード）では出来なかったことが出来るようになる。つまり、所有","keywords":[],"articleBody":"unsafe unsafeコードブロックを使うことによって、Safeなコード（普通のRustコード）では出来なかったことが出来るようになる。つまり、所有権などのRustの特有の制限、動作にこだわらなくても構わなくなる。しかし、その分の責任はすべてコードを作成するプログラマーの分になる。\nまた、Rustがunsafeなコードを制限的に許容している理由としては、OSのAPIまたはそれに準ずるロジックをさせるためにはunsafeじゃなければならなかったためである。ローレベルシステムプログラミングなどを行うためにはunsafeブロックの中でポインターの演算などをすることがある。\nとにかくunsafeブロックの中でロジックを書くか、それともunsafeな関数などを書くことによって以下の機能が使えるようになる。\n 生ポインター（*const T、*mut T）のDerefが出来る unsafeな関数なメソッドの呼び出しができる staticスコープの変数の接近と更新ができる unsafeなtraitの実装ができる（SendかSyncなどの） unionのフィルドの接近ができる  しかし、unsafeコードブロックの中でもBorrowチェッカーとRust特有の安全性チェックはずっと有効になる。また、unsafeは外に見えるようにするのではく可能な限り範囲を少なくして安全なAPIで囲んで書くようにする方が望ましい。\n1. *const T、*mut T 生ポインターのタイプを使うことによって、\n ポインターだけBorrowingルールが無視できる。つまり、ImmutableなポインターとMutableなポインターが同じスコープで同時に存在できるようになる。 しかし、必ず有効なメモリアドレスの位置を指しているとは保証できない。 nullptrである可能性がある。 他の型とは違ってRAIIをしない。なのでポインターを参照しているメモリが無効化されてもポインターはずっと初期化されたアドレスを持っていまう。  念頭すべき点としては、生ポインタータイプ自体はunsafeブロックの外でも作れることがある。ポインターだけを作るのはメモリ上に何の害もないからだ。（ポインターを使ってなにかをすることが問題なだけ）\nfn main(){letmutnum=5;letp_num=\u0026numas*consti32;letpmut_num=\u0026mutnumas*muti32;}生ポインタータイプの変数を生成する時には、asを使って既存の\u0026か\u0026mutになるはずだったの参照を生ポインターとして変換する。\n参照だけではなく、ただの値をそのままポインターに変換してしまうことも出来る。（要注意）\nletaddress_val=0xDEADBEEFusize;letaddress=address_valas*consti32;しかし、ポインターをDerefして接近したりするためにはunsafeブロックの中でしか行えない。\nfn main(){letnum=5;letp_num=\u0026numas*consti32;unsafe{println!(\"r1 is : {}\",*p_num);// Deref must be held in `unsafe` block code. }}また、一番上のコードのように*const i32と*mut i32が共存するのが見えるけど、基の\u0026と\u0026mutだとしたらこのコードはビルドが失敗するか、ランタイムでBorrowチェッカーによってpanic!になってしまう。しかし、生ポインターはBorrowチェッカーが動作しないため、不変と可変が共存することが出来る。\n2. unsafeコードをSafeなAPIとして使わせる方法 もし、次のようなコードがあって、split_at_mut関数はvec!のスライスを最初から進んだ地点からを基点として左右を分けて\u0026[T]を返す関数だとする。\nletmutv=vec![1,2,3,4,5,6];letr=\u0026mutv[..];let(a,b)=r.split_at_mut(3);assert_eq!(a,\u0026mut[1,2,3]);assert_eq!(b,\u0026mut[4,5,6]);しかし、Safeなコード書くだけの観点から見れば、split_at_mut()から返される複数のサブスコープを持ったスライスの参照はBorowが複数起こるはずなので関数として作れなさそうに見える。\nfn split_at_mutT(slice: \u0026mut[T],mid: usize)- (\u0026mut[T],\u0026mut[T]){letlen=slice.len();assert!(midlen);(\u0026mutslice[..mid],\u0026mutslice[mid..])// Multiple borrow, failed to build. }意図通りにsplit_at_mutで割り当てられた範囲を真っ二つに分けるためには、Borrowチェッカーを回避する必要がある。なので、ここでunsafeを使ってしまう。\n https://doc.rust-lang.org/std/primitive.slice.html#method.as_mut_ptr\n fn split_at_mutT(slice: \u0026mut[T],mid: usize)- (\u0026mut[T],\u0026mut[T]){letlen=slice.len();assert!(midlen);letp_slice: *mutT=slice.as_mut_ptr();unsafe{// Successful build. (slice::from_raw_parts_mut(p_slice,mid),slice::from_raw_parts_mut(p_slice.add(mid),len-mid))}}上のコードで使うslice::from_raw_parts_mut()はunsafeなので、unsafeコードブロックの中でしか使えない。ポインター演算が上手く使えなかったらC/C++系列の言語で見れる未定義行動が起こってしまう可能性もある。\n3. extern関数で外部のコードを呼ぶ Rustでのexternキーワードは、*Foreign Function Interface (FFI)*を使うためのものとして、つまりC言語で書かれたまたはC言語関数、または構造体の規約を沿っている任意言語のAPI、もしくは変数を生成する時に使われる。\nexternブロックで宣言された関数などは全部unsafe扱いになる。なぜなら、Rust独自の仕様ではない可能性があるため、Rustで使っているBorrowチェッカー、参照・可変参照の制限が無用になるからだ。\nextern\"C\"{fn abs(input: i32)- i32;}fn main(){unsafe{println!(\"Absolute value of -3 according to C: {}\",abs(-3));}}extern \"C\"ブロックを指定することによって、その中の関数はC言語のABIとして動作することになる。（ABIではCPPでの__cdecl、__stdcall、__fastcallのようなコール規約も含まれる）\nもし、Rustの関数をC言語の規約として作って外側のFFIをサポートする任意言語のコードで使わせるとしたら、extern \"C\"ブロックではなく普通の関数にextern \"C\"を書く。しかし、ABI規約をC言語にしたのとは別で関数名のManglingはまだ有効化されたままなので、指定した関数の名前そのものが公開できるようにするために#[no_mangle]Annotationを付けなければならない。\n#[no_mangle]pubextern\"C\"fn call_from_c(){println!(\"Just called a Rust function from C!\");}4. Static変数に接近・更新 一応Rustもstaticキーワードを付けることとしてグローバルスコープの変数をサポートしているが、Rust特有の所有権ルールに矛盾してしまう問題がある。staticになった変数はマルチスレッド環境でどのスレッドでの露出されてしまうので、簡単にデータ競合が起こりえる。\nただ、static変数を不変\u0026として読み込んで接近することは上のような問題が起こらないので安全なコードの中でも使える。しかし\u0026mutとして接近したり、そもそもstaticがmutの変数だったり、値を変更しようとするならunsafeブロックを使わなければならない。\nstaticmutCOUNTER: u32 =0;fn add_to_count(val: u32){unsafe{COUNTER+=inc;// Not thread-safe }unsafe{println!(\"COUNTER: {}\",COUNTER);}}5. unionの使用  https://doc.rust-lang.org/reference/items/unions.html\n Rust自体もunionをサポートしているが、大体のことはenumで各値に変数などを持たせることによって解決できるし、実装の意図もFFIとして動作させるためだけだったのであえて使うためにはunsafeブロックの中で使用しなければならない。\n#[repr(u32)]enum Tag{I,F}#[repr(C)]union U{i: i32,f: f32,}#[repr(C)]struct Value{tag: Tag,u: U,}pubextern\"C\"fn is_zero(v: Value)- bool {unsafe{matchv{Value{tag: Tag::I,u: U{i: 0}}=true,Value{tag: Tag::F,u: U{f: num}}ifnum==0.0f32=true,_=false,}}}Advanced Traits 1. operator overloading  https://doc.rust-lang.org/std/ops/index.html\n Rustでは各種オペレーターは全部traitを実装してメソッドをオーバーライドすれば動作する仕組みとなっている。今までのチュートリアルで見てきた参照またはBoxなどのスマートポインタの前に付けられる*（逆参照）もDerefを実装したものに過ぎない。\n例えばstd::ops::Addを任意の構造体に実装して、+演算子が使えるようにするとしよう。\nusestd::ops::Add;#[derive(Debug, PartialEq)]struct Point{x: i32,y: i32 }implPoint{fn new(x: i32,y: i32)- Point{Point{x,y}}}implAddforPoint{type Output=Point;fn add(self,other: Point)- Point{Point{x: self.x+other.x,y: self.y+other.y,}}}fn main(){assert_eq!(Point::new(1,0)+Point::new(2,3),Point::new(3,3));}std::ops::Add traitの内部は次のようになっている。\ntraitAddRhs=Self{type Output;fn add(self,rhs: Rhs)- Self::Output;}Rhs=Selfとは、ジェネリックに見えそうだけど正確には「基本タイプパラメータ」（Default Type Parameters）と呼ぶ。このTraitを任意のタイプに対して実装する時に、基本パラメータが指定されているので、impl Add for Pointのような書き方が出来る。\n型さえ指定していれば他のタイプに対して特殊なadd()を書くのも出来る。\n#[derive(Debug, PartialEq)]struct IdentityPoint{x: i32,}implAddIdentityPointforPoint{type Output=Point;fn add(self,other: IdentityPoint)- Self::Output{self+Point::new(other.x,other.x)}}2. Ambiguousな関数の明示的な呼び出し 次のようなコードがある時、\ntraitPilot{fn fly(\u0026self);}traitWizard{fn fly(\u0026self);}struct Human;implPilotforHuman{fn fly(\u0026self){println!(\"This is your captain speaking.\");}fn fly_anyway(){println!(\"Airplane is falling!\");}}implWizardforHuman{fn fly(\u0026self){println!(\"Up!\");}fn fly_anyway(){println!(\"You are not wizard. You can not fly.\");}}implHuman{fn fly(\u0026self){println!(\"*waving arms furiously*\");}fn fly_anyway(){println!(\"*waving arms furiously*\");}}Human{}.fly()としてどんな関数が呼ばれるかを見てみると、Humanで直接実装したfly()関数が呼ばれることがわかる。しかし、WizardとPilotのメソッドを呼ぶためには明示的な方法を使うしかない。\nletperson=Human;Pilot::fly(\u0026person);// \"This is your captain speaking.\"; Wizard::fly(\u0026person);// \"Up!\" person.fly();// \"*waving arms furiously*\" もし、メソッドに\u0026selfか\u0026mut selfの自分を指す引数がない場合には、次のように関数を立ち上げるしかない。\nHuman::fly_anyway();HumanasPilot::fly_anyway();HumanasWizard::fly_anyway();3. traitの実装を要求するtraitの実装 Rustでコードを書いたら、traitのメソッド、機能を使うtraitを実装したくなる時がある。この時にはtraitの定義コードを書く時、要件とするtraitを書くことによって、新しく定義したtraitは依存しようとするtraitの機能が中身で使えるようになる。この依存しようとするtraitをSupertraitと呼ぶ。\nもし次のようなコードがあるとして、\nstruct Point{x: i32,y: i32,}usestd::fmt;traitOutlinePrint: fmt::Display{fn outline_print(\u0026self){letoutput=self.to_string();// use feature of std::fmt::Display trait. letlen=output.len();// ... println!(\"* {} *\",output);}}ここでsupertraitを定義するには、traitの名前の定義の後ろに依存するtraitを書く。上のOutlinePrint traitではstd::fmt::Display traitを依存しようとしている。\nここでPointにOutlinePrintを実装させるが、下のコードだけじゃビルドが通らない。\nimplOutlinePrintforPoint{}なぜなら、OutlinePrintはstd::fmt::Display traitを依存しているのに、Pointはまだそのtraitを実装していなかったからだ。なので、#[derive(Display)] Annotationで自動実装させるようにするか、それとも直接実装するしかない。\nusestd::fmt;implfmt::DisplayforPoint{fn fmt(\u0026self,f: \u0026mutfmt::Formatter)- fmt::Result{write!(f,\"({}, {})\",self.x,self.y)}}Advanced Types 1. Type aliases type C++11またはC++03のusing、typedefのようにRustもtypeキーワードでタイプに対する別称を指定することが出来る。typeキーワードはtraitの中でAnnotation Typeだけではなく下の形でも使える。\nfn main(){type AliasI32=i32;letx: i32 =5;lety: AliasI32=5;println!(\"x + y = {}\",x+y);}typeを使ったType Aliasは主にstd::Resultでよく使われる。基本的にstdの各モジュールごとにErrorがあって、各モジュールでResultを吐き出す時にEは各モジュールのErrorになるため、各fnか構造体ごとにフルネームを一つ一つ書かせるのって手間がかかりすぎるからだ。\nなので、一般的にはこんな感じでResultの書き方を簡潔にしている。\nusestd::fmt;type ResultT=std::result::ResultT,std::io::Error;pubtraitWrite{fn write(\u0026mutself,buf: \u0026[u8])- Resultusize;fn flush(\u0026mutself)- Result();fn write_all(\u0026mutself,buf: \u0026[u8])- Resultusize;fn write_fmt(\u0026mutself,fmt: std::fmt::Arguments)- Result();}2. ! never type Rustはcontinue、loopまたは他のマクロ、関数などで特殊な用途として使わせるためのタイプ、!（Never Type）をサポートしている。Never Typeは、関数自体または式の終わりで返す値がなく（voidとは違う）特定の状態に落ちずに次にくるロジックを行うことを指す。\n上でも説明したように、loopまたはcontinueはこのNever Typeを内包していて、次のようなコードが出来るようになる。\nloop{letguess: u32 =matchguess.trim().parse(){Ok(num)=num,Err(_)=continue,// use '!' never type not to return into guess. }}// use '!' to loop. match分のすべてのケースは最後に返されるタイプが同じじゃなければならないが、!が実装されたタイプまたはキーワードを返すことによって型推論から除外できるようになる。\nちなみにpanic!マクロもこのNever typeを使っている。\n3. DSTとdynとSized trait Rustの関数のパラメータと構造体の引数の型は必ずコンパイルタイムで該当タイプのサイズがわからなければならない…（Genericも特殊化されるものを含めて）が、実はそうではなくてコンパイルタイムでサイズがわからなくても特定 traitなどに関連づけられたタイプ郡をタイプとして受け取りさせることが出来る。\ndynキーワードはimplのように特定のTraitを実装したタイプ郡だけを受け取るために使える。ただ、implはジェネリックの型を決める時か、Traitを実装しようとした時にだけ使えるキーワードで、dynは\u0026mut dyn、Box、Rc、Arcのようにもっと具体的な変数かパラメータタイプに使える。\ndynキーワード自体はDynamicの略語として、フルネームとしてはdynamically sized typesを指す。つまり、コンパイルタイムではサイズがはっきり決まってないタイプを指す用語で、Rustではstrと各種traitが該当される。\nDSTを取り入れるために、RustはSizedという特殊なtraitを実装している。Sizedtraitはコンパイルタイムでサイズがわかる全てのタイプに実装されるTraitである。また、Rustは全てのジェネリック関数に黙示的にSized traitが実装されたかを追加する。\nfn genericT(val: T){// -- snip -- }が実は、\nfn genericT: Sized(val: T){// -- snip -- }として解釈される。なので一般的に全ての型引数はコンパイルタイムでサイズがわからないとならない。しかし、DSTに対応するためにSized traitだけ追加的に?Sizedという書き方が出来るようになっていて、その時にはDSTのタイプも型引数として受け取るようにしている。\nしかし、DSTは単特としては存在できないし、必ずDSTが受け取れるタイプと連携して（Reference, Box, Rc, Arcなど…）使わなければならない。\nfn genericT: ?Sized(val: \u0026T){// -- snip -- }Advanced Functions and Closures 1. 関数ポインタ fn クロージャじゃない一般関数、またメソッドはfnタイプとして扱える。Fn traitとは違って、単純な関数ポインタを指す。\nもちろんfnもクロージャと同じく条件によってFnOnce、FnMut、Fn traitを実装している。なのでクロージャを入れるようにしているパラメータか、それともdynなどにも関数ポインタを入れることが出来る。\nfnタイプの基本使い方は以下のコードを見ればわかるはず…\nfn add_one(x: i32)- i32 {x+1}fn do_twice(f: fn(i32)- i32,arg: i32)- i32 {f(arg)+f(arg)}fn main(){letanswer=do_twice(add_one,5);println!(\"The answer is {}\",answer);}また、クロージャを入れるIteratorのIterator consume methodにも関数ポインタが入れられる。\nletlist_of_number=vec![1,2,3];letlist_of_string: VecString=list_of_number.iter().map(ToString::to_string).collect();2. クロージャを返し方 クロージャ自体はTraitとして現れているので、特定の型として返すのは出来ない。しかしクロージャがTraitとして表現出来ているのであると、DSTになるのでdynを使ってなんとか返せる。\nfn returns_closure()- BoxdynFn(i32)- i32{Box::new(|x|x+1)}macro!  https://doc.rust-lang.org/reference/macros-by-example.html\n 1. 概要 RustのマクロはC・C++言語のマクロとはより柔軟にロジックが書けるようになっている。Rustでマクロを定義する時にはmacro_rules!と書く。\nRustのマクロの大種類は２つ存在して、macro_rules!をウィッシュとした宣言型マクロと、手続きマクロが存在する。\n手続きとして生成されるマクロは３つの種類が存在する。\n structかenumに#[derive()]属性として追加される時のカスタム#[derive]マクロロジック どの要素などでも使えるカスタム属性（Attribute）マクロ 関数とほぼ似ているが、渡された引数の種類かトークンによるパターンマッチングなどでの関数マクロ  2. macro_rules!と基本的な使い方  https://danielkeep.github.io/tlborm/book/mbe-min-debugging.html\n macro_rules!を使うことにより、宣言型のマクロ（Declarative Macro）が作成できるようになる。宣言型マクロはRustのmatch表現式とほぼ似ていて、実際に定義ブロックでパターンマッチングをやってロジックが生成することが出来る。\n例えば、vec![]の場合には次のように定義されている。\n#[macro_export]macro_rules!vec{($($x: expr),*)={letmuttemp_vec=Vec::new();/* Do preallocate logic... */$(temp_vec.push($x);)*temp_vec}}一番最初の#[macro_export] Annotationはマクロが定義されているCrateが他のとこのロジックに見えるようになると、外部で使えるよう設定する。これがないと、マクロ自体は内部でだけのスコープを持つ。\n3. 手続きマクロの概要  https://doc.rust-lang.org/proc_macro/struct.TokenStream.html\n 手続きマクロは書き方が少しややこしいが、コードを入れて加工したり、なにかのロジックを行ってから加工されたロジックを返すことが出来る。宣言型とは違って、パターンマッチングでコードを書き換えたりすることとはちょっと方向性が異なる。\n上で書いた細部種類全ほぼ同じ書き方として生成することが出来る。\n手続きマクロを生成する時には、定義自体は今マクロを生成しようとしているCrateに必ず存在しなければならない。また、特殊なCrateをもたせてロジックを行うらしい。手続きマクロは次のように書く。\nuseproc_macro;#[some_attribute]pubfn some_name(input: TokenStream)- TokenStream{}上の関数はTokenStreamを入力として、トークンを加工してからTokenStreamを出力とする手続きマクロを定義する。TokenStreamを使うためにはproc_macroというRust自体で提供しているCrateを使わなければならない。手続きマクロは上のような感じで骨子を作る。\nそしてsome_attribute部分にどの種類としてのマクロを作るかを決める。また、同じCrateで様々な手続きマクロが作れる。\n","wordCount":"7373","inLanguage":"en","datePublished":"2020-11-21T23:10:01+09:00","dateModified":"2020-12-02T15:08:25+09:00","author":{"@type":"Person","name":"Jongmin Yun, Neu."},"mainEntityOfPage":{"@type":"WebPage","@id":"https://liliilli.github.io/posts/rust_3_memo/"},"publisher":{"@type":"Organization","name":"neuromantic","logo":{"@type":"ImageObject","url":"https://liliilli.github.io/favicon.ico"}}}</script></head><body id=" top"><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://liliilli.github.io accesskey=h title="neuromantic (Alt + H)">neuromantic</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://liliilli.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://liliilli.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://liliilli.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://liliilli.github.io/series/ title=Series><span>Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://liliilli.github.io>Home</a>&nbsp;»&nbsp;<a href=https://liliilli.github.io/posts/>Posts</a></div><h1 class=post-title>Rustメモ（2020-11-21~）</h1><div class=post-meta>2020, November 21&nbsp;·&nbsp;Jongmin Yun, Neu.</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#unsafe aria-label=unsafe><code>unsafe</code></a><ul><li><a href=#1-const-tmut-t aria-label="1. *const T、*mut T">1. <code>*const T</code>、<code>*mut T</code></a></li><li><a href=#2-unsafe%e3%82%b3%e3%83%bc%e3%83%89%e3%82%92safe%e3%81%aaapi%e3%81%a8%e3%81%97%e3%81%a6%e4%bd%bf%e3%82%8f%e3%81%9b%e3%82%8b%e6%96%b9%e6%b3%95 aria-label="2. unsafeコードをSafeなAPIとして使わせる方法">2. <code>unsafe</code>コードをSafeなAPIとして使わせる方法</a></li><li><a href=#3-extern%e9%96%a2%e6%95%b0%e3%81%a7%e5%a4%96%e9%83%a8%e3%81%ae%e3%82%b3%e3%83%bc%e3%83%89%e3%82%92%e5%91%bc%e3%81%b6 aria-label="3. extern関数で外部のコードを呼ぶ">3. <code>extern</code>関数で外部のコードを呼ぶ</a></li><li><a href=#4-static%e5%a4%89%e6%95%b0%e3%81%ab%e6%8e%a5%e8%bf%91%e6%9b%b4%e6%96%b0 aria-label="4. Static変数に接近・更新">4. Static変数に接近・更新</a></li><li><a href=#5-union%e3%81%ae%e4%bd%bf%e7%94%a8 aria-label="5. unionの使用">5. <code>union</code>の使用</a></li></ul></li><li><a href=#advanced-traits aria-label="Advanced Traits">Advanced Traits</a><ul><li><a href=#1-operator-overloading aria-label="1. operator overloading">1. operator overloading</a></li><li><a href=#2-ambiguous%e3%81%aa%e9%96%a2%e6%95%b0%e3%81%ae%e6%98%8e%e7%a4%ba%e7%9a%84%e3%81%aa%e5%91%bc%e3%81%b3%e5%87%ba%e3%81%97 aria-label="2. Ambiguousな関数の明示的な呼び出し">2. Ambiguousな関数の明示的な呼び出し</a></li><li><a href=#3-trait%e3%81%ae%e5%ae%9f%e8%a3%85%e3%82%92%e8%a6%81%e6%b1%82%e3%81%99%e3%82%8btrait%e3%81%ae%e5%ae%9f%e8%a3%85 aria-label="3. traitの実装を要求するtraitの実装">3. traitの実装を要求するtraitの実装</a></li></ul></li><li><a href=#advanced-types aria-label="Advanced Types">Advanced Types</a><ul><li><a href=#1-type-aliases-type aria-label="1. Type aliases type">1. Type aliases <code>type</code></a></li><li><a href=#2--never-type aria-label="2. ! never type">2. <code>!</code> <em>never type</em></a></li><li><a href=#3-dst%e3%81%a8dyn%e3%81%a8sized-trait aria-label="3. DSTとdynとSized trait">3. DSTと<code>dyn</code>と<code>Sized</code> trait</a></li></ul></li><li><a href=#advanced-functions-and-closures aria-label="Advanced Functions and Closures">Advanced Functions and Closures</a><ul><li><a href=#1-%e9%96%a2%e6%95%b0%e3%83%9d%e3%82%a4%e3%83%b3%e3%82%bf-fn aria-label="1. 関数ポインタ fn">1. 関数ポインタ <code>fn</code></a></li><li><a href=#2-%e3%82%af%e3%83%ad%e3%83%bc%e3%82%b8%e3%83%a3%e3%82%92%e8%bf%94%e3%81%97%e6%96%b9 aria-label="2. クロージャを返し方">2. クロージャを返し方</a></li></ul></li><li><a href=#macro aria-label=macro!><code>macro!</code></a><ul><li><a href=#1-%e6%a6%82%e8%a6%81 aria-label="1. 概要">1. 概要</a></li><li><a href=#2-macro_rules%e3%81%a8%e5%9f%ba%e6%9c%ac%e7%9a%84%e3%81%aa%e4%bd%bf%e3%81%84%e6%96%b9 aria-label="2. macro_rules!と基本的な使い方">2. <code>macro_rules!</code>と基本的な使い方</a></li><li><a href=#3-%e6%89%8b%e7%b6%9a%e3%81%8d%e3%83%9e%e3%82%af%e3%83%ad%e3%81%ae%e6%a6%82%e8%a6%81 aria-label="3. 手続きマクロの概要">3. 手続きマクロの概要</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=unsafe><code>unsafe</code><a hidden class=anchor aria-hidden=true href=#unsafe>#</a></h2><p><code>unsafe</code>コードブロックを使うことによって、Safeなコード（普通のRustコード）では出来なかったことが出来るようになる。つまり、所有権などのRustの特有の制限、動作にこだわらなくても構わなくなる。しかし、その分の責任はすべてコードを作成するプログラマーの分になる。</p><p>また、Rustが<code>unsafe</code>なコードを制限的に許容している理由としては、OSのAPIまたはそれに準ずるロジックをさせるためには<code>unsafe</code>じゃなければならなかったためである。ローレベルシステムプログラミングなどを行うためには<code>unsafe</code>ブロックの中でポインターの演算などをすることがある。</p><p>とにかく<code>unsafe</code>ブロックの中でロジックを書くか、それとも<code>unsafe</code>な関数などを書くことによって以下の機能が使えるようになる。</p><ul><li>生ポインター（<code>*const T</code>、<code>*mut T</code>）のDerefが出来る</li><li><code>unsafe</code>な関数なメソッドの呼び出しができる</li><li><code>static</code>スコープの変数の接近と更新ができる</li><li><code>unsafe</code>なtraitの実装ができる（<code>Send</code>か<code>Sync</code>などの）</li><li><code>union</code>のフィルドの接近ができる</li></ul><p>しかし、<code>unsafe</code>コードブロックの中でもBorrowチェッカーとRust特有の安全性チェックはずっと有効になる。また、<code>unsafe</code>は外に見えるようにするのではく可能な限り範囲を少なくして安全なAPIで囲んで書くようにする方が望ましい。</p><h3 id=1-const-tmut-t>1. <code>*const T</code>、<code>*mut T</code><a hidden class=anchor aria-hidden=true href=#1-const-tmut-t>#</a></h3><p>生ポインターのタイプを使うことによって、</p><ul><li>ポインターだけBorrowingルールが無視できる。つまり、ImmutableなポインターとMutableなポインターが同じスコープで同時に存在できるようになる。</li><li>しかし、必ず有効なメモリアドレスの位置を指しているとは保証できない。</li><li><code>nullptr</code>である可能性がある。</li><li>他の型とは違ってRAIIをしない。なのでポインターを参照しているメモリが無効化されてもポインターはずっと初期化されたアドレスを持っていまう。</li></ul><p>念頭すべき点としては、生ポインタータイプ自体は<code>unsafe</code>ブロックの外でも作れることがある。ポインターだけを作るのはメモリ上に何の害もないからだ。（ポインターを使ってなにかをすることが問題なだけ）</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>num</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span><span class=w>    
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>p_num</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>num</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=o>*</span><span class=k>const</span><span class=w> </span><span class=kt>i32</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>pmut_num</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>num</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=kt>i32</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>生ポインタータイプの変数を生成する時には、<code>as</code>を使って既存の<code>&</code>か<code>&mut</code>になるはずだったの参照を生ポインターとして変換する。</p><p>参照だけではなく、ただの値をそのままポインターに変換してしまうことも出来る。（要注意）</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=n>address_val</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mh>0xDEADBEEF</span><span class=k>usize</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>address</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>address_val</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=o>*</span><span class=k>const</span><span class=w> </span><span class=kt>i32</span><span class=p>;</span><span class=w>
</span></code></pre></div><p>しかし、ポインターをDerefして接近したりするためには<code>unsafe</code>ブロックの中でしか行えない。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>num</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>p_num</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>num</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=o>*</span><span class=k>const</span><span class=w> </span><span class=kt>i32</span><span class=p>;</span><span class=w>
</span><span class=w>    
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;r1 is : {}&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=n>p_num</span><span class=p>);</span><span class=w> </span><span class=c1>// Deref must be held in `unsafe` block code.
</span><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>また、一番上のコードのように<code>*const i32</code>と<code>*mut i32</code>が共存するのが見えるけど、基の<code>&</code>と<code>&mut</code>だとしたらこのコードはビルドが失敗するか、ランタイムでBorrowチェッカーによって<code>panic!</code>になってしまう。しかし、生ポインターはBorrowチェッカーが動作しないため、不変と可変が共存することが出来る。</p><h3 id=2-unsafeコードをsafeなapiとして使わせる方法>2. <code>unsafe</code>コードをSafeなAPIとして使わせる方法<a hidden class=anchor aria-hidden=true href=#2-unsafeコードをsafeなapiとして使わせる方法>#</a></h3><p>もし、次のようなコードがあって、<code>split_at_mut</code>関数は<code>vec!</code>のスライスを最初から進んだ地点からを基点として左右を分けて<code>&[T]</code>を返す関数だとする。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>vec</span><span class=o>!</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=mi>6</span><span class=p>];</span><span class=w>
</span><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>v</span><span class=p>[..];</span><span class=w>
</span><span class=w></span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r</span><span class=p>.</span><span class=n>split_at_mut</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>]);</span><span class=w>
</span><span class=w></span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=p>[</span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=mi>6</span><span class=p>]);</span><span class=w>
</span></code></pre></div><p>しかし、Safeなコード書くだけの観点から見れば、<code>split_at_mut()</code>から返される複数のサブスコープを持ったスライスの参照はBorowが複数起こるはずなので関数として作れなさそうに見える。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>split_at_mut</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>slice</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=p>[</span><span class=n>T</span><span class=p>],</span><span class=w> </span><span class=n>mid</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=p>[</span><span class=n>T</span><span class=p>],</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=p>[</span><span class=n>T</span><span class=p>])</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>slice</span><span class=p>.</span><span class=n>len</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=n>assert</span><span class=o>!</span><span class=p>(</span><span class=n>mid</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>len</span><span class=p>);</span><span class=w>
</span><span class=w>   	</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>slice</span><span class=p>[..</span><span class=n>mid</span><span class=p>],</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>slice</span><span class=p>[</span><span class=n>mid</span><span class=p>..])</span><span class=w> </span><span class=c1>// Multiple borrow, failed to build.
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>意図通りに<code>split_at_mut</code>で割り当てられた範囲を真っ二つに分けるためには、Borrowチェッカーを回避する必要がある。なので、ここで<code>unsafe</code>を使ってしまう。</p><blockquote><p><a href=https://doc.rust-lang.org/std/primitive.slice.html#method.as_mut_ptr>https://doc.rust-lang.org/std/primitive.slice.html#method.as_mut_ptr</a></p></blockquote><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>split_at_mut</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>slice</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=p>[</span><span class=n>T</span><span class=p>],</span><span class=w> </span><span class=n>mid</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=p>[</span><span class=n>T</span><span class=p>],</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=p>[</span><span class=n>T</span><span class=p>])</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>slice</span><span class=p>.</span><span class=n>len</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=n>assert</span><span class=o>!</span><span class=p>(</span><span class=n>mid</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>len</span><span class=p>);</span><span class=w>
</span><span class=w>    
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>p_slice</span>: <span class=o>*</span><span class=k>mut</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>slice</span><span class=p>.</span><span class=n>as_mut_ptr</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// Successful build.
</span><span class=c1></span><span class=w>        </span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=n>slice</span>::<span class=n>from_raw_parts_mut</span><span class=p>(</span><span class=n>p_slice</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=p>),</span><span class=w>
</span><span class=w>            </span><span class=n>slice</span>::<span class=n>from_raw_parts_mut</span><span class=p>(</span><span class=n>p_slice</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=n>mid</span><span class=p>),</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>mid</span><span class=p>)</span><span class=w>
</span><span class=w>        </span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>上のコードで使う<code>slice::from_raw_parts_mut()</code>は<code>unsafe</code>なので、<code>unsafe</code>コードブロックの中でしか使えない。ポインター演算が上手く使えなかったらC/C++系列の言語で見れる未定義行動が起こってしまう可能性もある。</p><h3 id=3-extern関数で外部のコードを呼ぶ>3. <code>extern</code>関数で外部のコードを呼ぶ<a hidden class=anchor aria-hidden=true href=#3-extern関数で外部のコードを呼ぶ>#</a></h3><p>Rustでの<code>extern</code>キーワードは、*Foreign Function Interface (FFI)*を使うためのものとして、つまりC言語で書かれたまたはC言語関数、または構造体の規約を沿っている任意言語のAPI、もしくは変数を生成する時に使われる。</p><p><code>extern</code>ブロックで宣言された関数などは全部<code>unsafe</code>扱いになる。なぜなら、Rust独自の仕様ではない可能性があるため、Rustで使っているBorrowチェッカー、参照・可変参照の制限が無用になるからだ。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>extern</span><span class=w> </span><span class=s>&#34;C&#34;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>abs</span><span class=p>(</span><span class=n>input</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Absolute value of -3 according to C: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>abs</span><span class=p>(</span><span class=o>-</span><span class=mi>3</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p><code>extern "C"</code>ブロックを指定することによって、その中の関数はC言語のABIとして動作することになる。（ABIではCPPでの<code>__cdecl</code>、<code>__stdcall</code>、<code>__fastcall</code>のようなコール規約も含まれる）</p><p>もし、Rustの関数をC言語の規約として作って外側のFFIをサポートする任意言語のコードで使わせるとしたら、<code>extern "C"</code>ブロックではなく普通の関数に<code>extern "C"</code>を書く。しかし、ABI規約をC言語にしたのとは別で関数名のManglingはまだ有効化されたままなので、指定した関数の名前そのものが公開できるようにするために<code>#[no_mangle]</code>Annotationを付けなければならない。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[no_mangle]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>extern</span><span class=w> </span><span class=s>&#34;C&#34;</span><span class=w> </span><span class=k>fn</span> <span class=nf>call_from_c</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Just called a Rust function from C!&#34;</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w> 
</span></code></pre></div><h3 id=4-static変数に接近更新>4. Static変数に接近・更新<a hidden class=anchor aria-hidden=true href=#4-static変数に接近更新>#</a></h3><p>一応Rustも<code>static</code>キーワードを付けることとしてグローバルスコープの変数をサポートしているが、Rust特有の所有権ルールに矛盾してしまう問題がある。<code>static</code>になった変数はマルチスレッド環境でどのスレッドでの露出されてしまうので、簡単にデータ競合が起こりえる。</p><p>ただ、<code>static</code>変数を不変<code>&</code>として読み込んで接近することは上のような問題が起こらないので安全なコードの中でも使える。しかし<code>&mut</code>として接近したり、そもそも<code>static</code>が<code>mut</code>の変数だったり、値を変更しようとするなら<code>unsafe</code>ブロックを使わなければならない。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>static</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>COUNTER</span>: <span class=kt>u32</span> <span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>add_to_count</span><span class=p>(</span><span class=n>val</span>: <span class=kt>u32</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>COUNTER</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>inc</span><span class=p>;</span><span class=w> </span><span class=c1>// Not thread-safe
</span><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>    
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;COUNTER: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>COUNTER</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h3 id=5-unionの使用>5. <code>union</code>の使用<a hidden class=anchor aria-hidden=true href=#5-unionの使用>#</a></h3><blockquote><p><a href=https://doc.rust-lang.org/reference/items/unions.html>https://doc.rust-lang.org/reference/items/unions.html</a></p></blockquote><p>Rust自体も<code>union</code>をサポートしているが、大体のことは<code>enum</code>で各値に変数などを持たせることによって解決できるし、実装の意図もFFIとして動作させるためだけだったのであえて使うためには<code>unsafe</code>ブロックの中で使用しなければならない。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[repr(u32)]</span><span class=w>
</span><span class=w></span><span class=k>enum</span> <span class=nc>Tag</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>I</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=w> </span><span class=p>}</span><span class=w> 
</span><span class=w>
</span><span class=w></span><span class=cp>#[repr(C)]</span><span class=w>
</span><span class=w></span><span class=k>union</span> <span class=nc>U</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>i</span>: <span class=kt>i32</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>f</span>: <span class=kt>f32</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[repr(C)]</span><span class=w>
</span><span class=w></span><span class=k>struct</span> <span class=nc>Value</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>tag</span>: <span class=nc>Tag</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>u</span>: <span class=nc>U</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>extern</span><span class=w> </span><span class=s>&#34;C&#34;</span><span class=w> </span><span class=k>fn</span> <span class=nf>is_zero</span><span class=p>(</span><span class=n>v</span>: <span class=nc>Value</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>Value</span><span class=p>{</span><span class=w> </span><span class=n>tag</span>: <span class=nc>Tag</span>::<span class=n>I</span><span class=p>,</span><span class=w> </span><span class=n>u</span>: <span class=nc>U</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>i</span>: <span class=mi>0</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>Value</span><span class=p>{</span><span class=w> </span><span class=n>tag</span>: <span class=nc>Tag</span>::<span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>u</span>: <span class=nc>U</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>f</span>: <span class=nc>num</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=n>num</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mf>0.0</span><span class=k>f32</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h2 id=advanced-traits>Advanced Traits<a hidden class=anchor aria-hidden=true href=#advanced-traits>#</a></h2><h3 id=1-operator-overloading>1. operator overloading<a hidden class=anchor aria-hidden=true href=#1-operator-overloading>#</a></h3><blockquote><p><a href=https://doc.rust-lang.org/std/ops/index.html>https://doc.rust-lang.org/std/ops/index.html</a></p></blockquote><p>Rustでは各種オペレーターは全部<code>trait</code>を実装してメソッドをオーバーライドすれば動作する仕組みとなっている。今までのチュートリアルで見てきた参照または<code>Box&lt;T></code>などのスマートポインタの前に付けられる<code>*</code>（逆参照）も<code>Deref</code>を実装したものに過ぎない。</p><p>例えば<code>std::ops::Add&lt;RHS></code>を任意の構造体に実装して、<code>+</code>演算子が使えるようにするとしよう。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>ops</span>::<span class=n>Add</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[derive(Debug, PartialEq)]</span><span class=w>
</span><span class=w></span><span class=k>struct</span> <span class=nc>Point</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>x</span>: <span class=kt>i32</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>y</span>: <span class=kt>i32</span>
<span class=p>}</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>x</span>: <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Point</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>Point</span><span class=p>{</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>}</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Add</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Point</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>add</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>other</span>: <span class=nc>Point</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Point</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>x</span>: <span class=nc>self</span><span class=p>.</span><span class=n>x</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>other</span><span class=p>.</span><span class=n>x</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>y</span>: <span class=nc>self</span><span class=p>.</span><span class=n>y</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>other</span><span class=p>.</span><span class=n>y</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>Point</span>::<span class=n>new</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>Point</span>::<span class=n>new</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>),</span><span class=w> </span><span class=n>Point</span>::<span class=n>new</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>));</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p><code>std::ops::Add</code> traitの内部は次のようになっている。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>trait</span><span class=w> </span><span class=n>Add</span><span class=o>&lt;</span><span class=n>Rhs</span><span class=o>=</span><span class=n>Self</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Output</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>add</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span>: <span class=nc>Rhs</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p><code>Rhs=Self</code>とは、ジェネリックに見えそうだけど正確には「基本タイプパラメータ」（Default Type Parameters）と呼ぶ。このTraitを任意のタイプに対して実装する時に、基本パラメータが指定されているので、<code>impl Add for Point</code>のような書き方が出来る。</p><p>型さえ指定していれば他のタイプに対して特殊な<code>add()</code>を書くのも出来る。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[derive(Debug, PartialEq)]</span><span class=w>
</span><span class=w></span><span class=k>struct</span> <span class=nc>IdentityPoint</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>x</span>: <span class=kt>i32</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Add</span><span class=o>&lt;</span><span class=n>IdentityPoint</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Point</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>add</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>other</span>: <span class=nc>IdentityPoint</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Output</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>Point</span>::<span class=n>new</span><span class=p>(</span><span class=n>other</span><span class=p>.</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>other</span><span class=p>.</span><span class=n>x</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h3 id=2-ambiguousな関数の明示的な呼び出し>2. Ambiguousな関数の明示的な呼び出し<a hidden class=anchor aria-hidden=true href=#2-ambiguousな関数の明示的な呼び出し>#</a></h3><p>次のようなコードがある時、</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>trait</span><span class=w> </span><span class=n>Pilot</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>fn</span> <span class=nf>fly</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=k>trait</span><span class=w> </span><span class=n>Wizard</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>fn</span> <span class=nf>fly</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>struct</span> <span class=nc>Human</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Pilot</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Human</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>fly</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;This is your captain speaking.&#34;</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>fly_anyway</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Airplane is falling!&#34;</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Wizard</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Human</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>fly</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Up!&#34;</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>fly_anyway</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;You are not wizard. You can not fly.&#34;</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Human</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>fly</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;*waving arms furiously*&#34;</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>fly_anyway</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;*waving arms furiously*&#34;</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p><code>Human{}.fly()</code>としてどんな関数が呼ばれるかを見てみると、<code>Human</code>で直接実装した<code>fly()</code>関数が呼ばれることがわかる。しかし、<code>Wizard</code>と<code>Pilot</code>のメソッドを呼ぶためには明示的な方法を使うしかない。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=n>person</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Human</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=n>Pilot</span>::<span class=n>fly</span><span class=p>(</span><span class=o>&amp;</span><span class=n>person</span><span class=p>);</span><span class=w>  </span><span class=c1>// &#34;This is your captain speaking.&#34;;
</span><span class=c1></span><span class=n>Wizard</span>::<span class=n>fly</span><span class=p>(</span><span class=o>&amp;</span><span class=n>person</span><span class=p>);</span><span class=w> </span><span class=c1>// &#34;Up!&#34;
</span><span class=c1></span><span class=n>person</span><span class=p>.</span><span class=n>fly</span><span class=p>();</span><span class=w>         </span><span class=c1>// &#34;*waving arms furiously*&#34;
</span></code></pre></div><p>もし、メソッドに<code>&self</code>か<code>&mut self</code>の自分を指す引数がない場合には、次のように関数を立ち上げるしかない。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=n>Human</span>::<span class=n>fly_anyway</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=o>&lt;</span><span class=n>Human</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>Pilot</span><span class=o>&gt;</span>::<span class=n>fly_anyway</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=o>&lt;</span><span class=n>Human</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>Wizard</span><span class=o>&gt;</span>::<span class=n>fly_anyway</span><span class=p>();</span><span class=w>
</span></code></pre></div><h3 id=3-traitの実装を要求するtraitの実装>3. traitの実装を要求するtraitの実装<a hidden class=anchor aria-hidden=true href=#3-traitの実装を要求するtraitの実装>#</a></h3><p>Rustでコードを書いたら、traitのメソッド、機能を使うtraitを実装したくなる時がある。この時にはtraitの定義コードを書く時、要件とする<code>trait</code>を書くことによって、新しく定義したtraitは依存しようとする<code>trait</code>の機能が中身で使えるようになる。この依存しようとするtraitを<code>Supertrait</code>と呼ぶ。</p><p>もし次のようなコードがあるとして、</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>struct</span> <span class=nc>Point</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>x</span>: <span class=kt>i32</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>y</span>: <span class=kt>i32</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>fmt</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>trait</span><span class=w> </span><span class=n>OutlinePrint</span>: <span class=nc>fmt</span>::<span class=n>Display</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>outline_print</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>to_string</span><span class=p>();</span><span class=w> </span><span class=c1>// use feature of std::fmt::Display trait.
</span><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>output</span><span class=p>.</span><span class=n>len</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=c1>// ...
</span><span class=c1></span><span class=w>        </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;* {} *&#34;</span><span class=p>,</span><span class=w> </span><span class=n>output</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>ここで<code>supertrait</code>を定義するには、traitの名前の定義の後ろに依存するtraitを書く。上の<code>OutlinePrint</code> traitでは<code>std::fmt::Display</code> traitを依存しようとしている。</p><p>ここで<code>Point</code>に<code>OutlinePrint</code>を実装させるが、下のコードだけじゃビルドが通らない。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>OutlinePrint</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Point</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></code></pre></div><p>なぜなら、<code>OutlinePrint</code>は<code>std::fmt::Display</code> traitを依存しているのに、<code>Point</code>はまだそのtraitを実装していなかったからだ。なので、<code>#[derive(Display)]</code> Annotationで自動実装させるようにするか、それとも直接実装するしかない。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>fmt</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>fmt</span>::<span class=n>Display</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Point</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>fmt</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>f</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>fmt</span>::<span class=n>Formatter</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>fmt</span>::<span class=nb>Result</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>write</span><span class=o>!</span><span class=p>(</span><span class=n>f</span><span class=p>,</span><span class=w> </span><span class=s>&#34;({}, {})&#34;</span><span class=p>,</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>y</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h2 id=advanced-types>Advanced Types<a hidden class=anchor aria-hidden=true href=#advanced-types>#</a></h2><h3 id=1-type-aliases-type>1. Type aliases <code>type</code><a hidden class=anchor aria-hidden=true href=#1-type-aliases-type>#</a></h3><p>C++11またはC++03の<code>using</code>、<code>typedef</code>のようにRustも<code>type</code>キーワードでタイプに対する別称を指定することが出来る。<code>type</code>キーワードは<code>trait</code>の中でAnnotation Typeだけではなく下の形でも使える。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>AliasI32</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kt>i32</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span>: <span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>y</span>: <span class=nc>AliasI32</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;x + y = {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>y</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p><code>type</code>を使ったType Aliasは主に<code>std::Result&lt;T, E></code>でよく使われる。基本的に<code>std</code>の各モジュールごとに<code>Error</code>があって、各モジュールで<code>Result&lt;T, E></code>を吐き出す時に<code>E</code>は各モジュールのErrorになるため、各<code>fn</code>か構造体ごとにフルネームを一つ一つ書かせるのって手間がかかりすぎるからだ。</p><p>なので、一般的にはこんな感じで<code>Result</code>の書き方を簡潔にしている。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>fmt</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>type</span> <span class=nb>Result</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>std</span>::<span class=n>result</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span>::<span class=n>Error</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>Write</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>write</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>buf</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=kt>u8</span><span class=p>])</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=kt>usize</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>flush</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>write_all</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>buf</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=kt>u8</span><span class=p>])</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=kt>usize</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>write_fmt</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>fmt</span>: <span class=nc>std</span>::<span class=n>fmt</span>::<span class=n>Arguments</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h3 id=2--never-type>2. <code>!</code> <em>never type</em><a hidden class=anchor aria-hidden=true href=#2--never-type>#</a></h3><p>Rustは<code>continue</code>、<code>loop</code>または他のマクロ、関数などで特殊な用途として使わせるためのタイプ、<code>!</code>（Never Type）をサポートしている。Never Typeは、関数自体または式の終わりで返す値がなく（<code>void</code>とは違う）特定の状態に落ちずに次にくるロジックを行うことを指す。</p><p>上でも説明したように、<code>loop</code>または<code>continue</code>はこのNever Typeを内包していて、次のようなコードが出来るようになる。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>guess</span>: <span class=kt>u32</span> <span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>guess</span><span class=p>.</span><span class=n>trim</span><span class=p>().</span><span class=n>parse</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Ok</span><span class=p>(</span><span class=n>num</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>num</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=nb>Err</span><span class=p>(</span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>continue</span><span class=p>,</span><span class=w> </span><span class=c1>// use &#39;!&#39; never type not to return into guess.
</span><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>   </span><span class=c1>// use &#39;!&#39; to loop.
</span></code></pre></div><p><code>match</code>分のすべてのケースは最後に返されるタイプが同じじゃなければならないが、<code>!</code>が実装されたタイプまたはキーワードを返すことによって型推論から除外できるようになる。</p><p>ちなみに<code>panic!</code>マクロもこのNever typeを使っている。</p><h3 id=3-dstとdynとsized-trait>3. DSTと<code>dyn</code>と<code>Sized</code> trait<a hidden class=anchor aria-hidden=true href=#3-dstとdynとsized-trait>#</a></h3><p>Rustの関数のパラメータと構造体の引数の型は必ずコンパイルタイムで該当タイプのサイズがわからなければならない…（Genericも特殊化されるものを含めて）が、実はそうではなくてコンパイルタイムでサイズがわからなくても特定 traitなどに関連づけられたタイプ郡をタイプとして受け取りさせることが出来る。</p><p><code>dyn</code>キーワードは<code>impl</code>のように特定のTraitを実装したタイプ郡だけを受け取るために使える。ただ、<code>impl</code>はジェネリックの型を決める時か、Traitを実装しようとした時にだけ使えるキーワードで、<code>dyn</code>は<code>&mut dyn</code>、<code>Box&lt;dyn Trait></code>、<code>Rc&lt;dyn Trait></code>、<code>Arc&lt;dyn Trait></code>のようにもっと具体的な変数かパラメータタイプに使える。</p><p><code>dyn</code>キーワード自体はDynamicの略語として、フルネームとしてはdynamically sized typesを指す。つまり、コンパイルタイムではサイズがはっきり決まってないタイプを指す用語で、Rustでは<code>str</code>と各種traitが該当される。</p><p>DSTを取り入れるために、Rustは<code>Sized</code>という特殊なtraitを実装している。<code>Sized</code>traitはコンパイルタイムでサイズがわかる全てのタイプに実装されるTraitである。また、Rustは全てのジェネリック関数に黙示的に<code>Sized</code> traitが実装されたかを追加する。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>generic</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>val</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// -- snip --
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>が実は、</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>generic</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nb>Sized</span><span class=o>&gt;</span><span class=p>(</span><span class=n>val</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// -- snip --
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>として解釈される。なので一般的に全ての型引数はコンパイルタイムでサイズがわからないとならない。しかし、DSTに対応するために<code>Sized</code> traitだけ追加的に<code>?Sized</code>という書き方が出来るようになっていて、その時にはDSTのタイプも型引数として受け取るようにしている。</p><p>しかし、DSTは単特としては存在できないし、必ずDSTが受け取れるタイプと連携して（Reference, Box, Rc, Arcなど…）使わなければならない。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>generic</span><span class=o>&lt;</span><span class=n>T</span>: <span class=o>?</span><span class=nb>Sized</span><span class=o>&gt;</span><span class=p>(</span><span class=n>val</span>: <span class=kp>&amp;</span><span class=nc>T</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// -- snip --
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><h2 id=advanced-functions-and-closures>Advanced Functions and Closures<a hidden class=anchor aria-hidden=true href=#advanced-functions-and-closures>#</a></h2><h3 id=1-関数ポインタ-fn>1. 関数ポインタ <code>fn</code><a hidden class=anchor aria-hidden=true href=#1-関数ポインタ-fn>#</a></h3><p>クロージャじゃない一般関数、またメソッドは<code>fn</code>タイプとして扱える。<code>Fn</code> traitとは違って、単純な関数ポインタを指す。</p><p>もちろん<code>fn</code>もクロージャと同じく条件によって<code>FnOnce</code>、<code>FnMut</code>、<code>Fn</code> traitを実装している。なのでクロージャを入れるようにしているパラメータか、それとも<code>dyn</code>などにも関数ポインタを入れることが出来る。</p><p><code>fn</code>タイプの基本使い方は以下のコードを見ればわかるはず…</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>add_one</span><span class=p>(</span><span class=n>x</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span> <span class=p>{</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>do_twice</span><span class=p>(</span><span class=n>f</span>: <span class=nc>fn</span><span class=p>(</span><span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=n>arg</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span> <span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>f</span><span class=p>(</span><span class=n>arg</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>f</span><span class=p>(</span><span class=n>arg</span><span class=p>)</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>answer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>do_twice</span><span class=p>(</span><span class=n>add_one</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;The answer is {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>answer</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>また、クロージャを入れるIteratorのIterator consume methodにも関数ポインタが入れられる。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=n>list_of_number</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>vec</span><span class=o>!</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>];</span><span class=w>
</span><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>list_of_string</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>list_of_number</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>map</span><span class=p>(</span><span class=nb>ToString</span>::<span class=n>to_string</span><span class=p>).</span><span class=n>collect</span><span class=p>();</span><span class=w>
</span></code></pre></div><h3 id=2-クロージャを返し方>2. クロージャを返し方<a hidden class=anchor aria-hidden=true href=#2-クロージャを返し方>#</a></h3><p>クロージャ自体はTraitとして現れているので、特定の型として返すのは出来ない。しかしクロージャがTraitとして表現出来ているのであると、DSTになるので<code>dyn</code>を使ってなんとか返せる。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>returns_closure</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nb>Box</span><span class=o>&lt;</span><span class=n>dyn</span><span class=w> </span><span class=nb>Fn</span><span class=p>(</span><span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>i32</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=o>|</span><span class=n>x</span><span class=o>|</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h2 id=macro><code>macro!</code><a hidden class=anchor aria-hidden=true href=#macro>#</a></h2><blockquote><p><a href=https://doc.rust-lang.org/reference/macros-by-example.html>https://doc.rust-lang.org/reference/macros-by-example.html</a></p></blockquote><h3 id=1-概要>1. 概要<a hidden class=anchor aria-hidden=true href=#1-概要>#</a></h3><p>RustのマクロはC・C++言語のマクロとはより柔軟にロジックが書けるようになっている。Rustでマクロを定義する時には<code>macro_rules!</code>と書く。</p><p>Rustのマクロの大種類は２つ存在して、<code>macro_rules!</code>をウィッシュとした宣言型マクロと、手続きマクロが存在する。</p><p>手続きとして生成されるマクロは３つの種類が存在する。</p><ul><li>structかenumに<code>#[derive()]</code>属性として追加される時のカスタム<code>#[derive]</code>マクロロジック</li><li>どの要素などでも使えるカスタム属性（Attribute）マクロ</li><li>関数とほぼ似ているが、渡された引数の種類かトークンによるパターンマッチングなどでの関数マクロ</li></ul><h3 id=2-macro_rulesと基本的な使い方>2. <code>macro_rules!</code>と基本的な使い方<a hidden class=anchor aria-hidden=true href=#2-macro_rulesと基本的な使い方>#</a></h3><blockquote><p><a href=https://danielkeep.github.io/tlborm/book/mbe-min-debugging.html>https://danielkeep.github.io/tlborm/book/mbe-min-debugging.html</a></p></blockquote><p><code>macro_rules!</code>を使うことにより、宣言型のマクロ（Declarative Macro）が作成できるようになる。宣言型マクロはRustの<code>match</code>表現式とほぼ似ていて、実際に定義ブロックでパターンマッチングをやってロジックが生成することが出来る。</p><p>例えば、<code>vec![]</code>の場合には次のように定義されている。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[macro_export]</span><span class=w>
</span><span class=w></span><span class=n>macro_rules</span><span class=o>!</span><span class=w> </span><span class=n>vec</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=p>(</span><span class=w> </span><span class=cp>$(</span><span class=w> </span><span class=cp>$x</span>: <span class=nc>expr</span><span class=w> </span><span class=p>),</span><span class=o>*</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>temp_vec</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=cm>/* Do preallocate logic... */</span><span class=w>
</span><span class=w>        </span><span class=cp>$(</span><span class=w>
</span><span class=w>            </span><span class=n>temp_vec</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=cp>$x</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=p>)</span><span class=o>*</span><span class=w>
</span><span class=w>        </span><span class=n>temp_vec</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>一番最初の<code>#[macro_export]</code> Annotationはマクロが定義されているCrateが他のとこのロジックに見えるようになると、外部で使えるよう設定する。これがないと、マクロ自体は内部でだけのスコープを持つ。</p><h3 id=3-手続きマクロの概要>3. 手続きマクロの概要<a hidden class=anchor aria-hidden=true href=#3-手続きマクロの概要>#</a></h3><blockquote><p><a href=https://doc.rust-lang.org/proc_macro/struct.TokenStream.html>https://doc.rust-lang.org/proc_macro/struct.TokenStream.html</a></p></blockquote><p>手続きマクロは書き方が少しややこしいが、コードを入れて加工したり、なにかのロジックを行ってから加工されたロジックを返すことが出来る。宣言型とは違って、パターンマッチングでコードを書き換えたりすることとはちょっと方向性が異なる。</p><p>上で書いた細部種類全ほぼ同じ書き方として生成することが出来る。</p><p>手続きマクロを生成する時には、定義自体は今マクロを生成しようとしているCrateに必ず存在しなければならない。また、特殊なCrateをもたせてロジックを行うらしい。手続きマクロは次のように書く。</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>proc_macro</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[some_attribute]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>some_name</span><span class=p>(</span><span class=n>input</span>: <span class=nc>TokenStream</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>TokenStream</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>上の関数は<code>TokenStream</code>を入力として、トークンを加工してから<code>TokenStream</code>を出力とする手続きマクロを定義する。<code>TokenStream</code>を使うためには<code>proc_macro</code>というRust自体で提供しているCrateを使わなければならない。手続きマクロは上のような感じで骨子を作る。</p><p>そして<code>some_attribute</code>部分にどの種類としてのマクロを作るかを決める。また、同じCrateで様々な手続きマクロが作れる。</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://liliilli.github.io/posts/self_review_chipmunk/><span class=title>« Prev Page</span><br><span>RustでChip-8インタプリタを作ってみた</span></a>
<a class=next href=https://liliilli.github.io/posts/rust_2_memo/><span class=title>Next Page »</span><br><span>Rustメモ（20-11-20～)</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Rustメモ（2020-11-21~） on twitter" href="https://twitter.com/intent/tweet/?text=Rust%e3%83%a1%e3%83%a2%ef%bc%882020-11-21~%ef%bc%89&url=https%3a%2f%2fliliilli.github.io%2fposts%2frust_3_memo%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Rustメモ（2020-11-21~） on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fliliilli.github.io%2fposts%2frust_3_memo%2f&title=Rust%e3%83%a1%e3%83%a2%ef%bc%882020-11-21~%ef%bc%89&summary=Rust%e3%83%a1%e3%83%a2%ef%bc%882020-11-21~%ef%bc%89&source=https%3a%2f%2fliliilli.github.io%2fposts%2frust_3_memo%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Rustメモ（2020-11-21~） on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fliliilli.github.io%2fposts%2frust_3_memo%2f&title=Rust%e3%83%a1%e3%83%a2%ef%bc%882020-11-21~%ef%bc%89"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Rustメモ（2020-11-21~） on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fliliilli.github.io%2fposts%2frust_3_memo%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Rustメモ（2020-11-21~） on whatsapp" href="https://api.whatsapp.com/send?text=Rust%e3%83%a1%e3%83%a2%ef%bc%882020-11-21~%ef%bc%89%20-%20https%3a%2f%2fliliilli.github.io%2fposts%2frust_3_memo%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Rustメモ（2020-11-21~） on telegram" href="https://telegram.me/share/url?text=Rust%e3%83%a1%e3%83%a2%ef%bc%882020-11-21~%ef%bc%89&url=https%3a%2f%2fliliilli.github.io%2fposts%2frust_3_memo%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright © 2008–2019, Steve Francia and the Hugo Authors; all rights reserved.</span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>