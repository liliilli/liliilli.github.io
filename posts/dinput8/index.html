<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>DirectInput8 導入メモ</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
</head>
<body>
	<header>
	=================<br>
	== <a href="https://liliilli.github.io">neuromantic</a> ==<br>
	=================
	<div style="float: right;"></div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/about-hugo/"><b>About</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>DirectInput8 導入メモ</h1>
			<b><time>25.04.2020 13:28</time></b>
		       

			<div>
				

<blockquote>
<p><a href="https://en.wikipedia.org/wiki/DirectInput">https://en.wikipedia.org/wiki/DirectInput</a></p>

<p><a href="https://bell0bytes.eu/directinput/">https://bell0bytes.eu/directinput/</a></p>

<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416842(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416842(v=vs.85)?redirectedfrom=MSDN</a></p>

<p><a href="https://docs.microsoft.com/ko-kr/windows/win32/xinput/xinput-and-directinput?redirectedfrom=MSDN">https://docs.microsoft.com/ko-kr/windows/win32/xinput/xinput-and-directinput?redirectedfrom=MSDN</a></p>
</blockquote>

<h1 id="directinputとは">DirectInputとは</h1>

<p><strong>DirectInput</strong>は、キーボード、マウス、そして各種のコントローラーを含んでほぼ同一な挙動制御をサポートしてくれるAPIを指す。今は<strong>xinput</strong>という新しい（今になっては結構古いAPIだが）APIと一緒に両立しているらしい。</p>

<p>*DirectInput*はもともと<strong>DirectX</strong>のコンポーネントの一つとして提供され、これを使えば以前までコントローラーごとの挙動制御を一つずつ制御しなかったことが相当省かれる。</p>

<p>*DirectInput*は認知したデバイスを3つの種類（キーボード、マウス、そしてコントローラー）として分類する。また、*DirectInput*はデバイスが必ず認識てきる、自分ひとりしか持ってない番号をもたせて認識させるようにする。それを<strong>GUID</strong>という。</p>

<p>よって、認知したデバイスをインスタンス（例えば<code>IDirectInput8Device</code>とか）として返すためには必ず*GUID*を持つ必要があるらしい。ただし、基本接続しているキーボードとマウスデバイスは以下のGUIDを通して探せる。</p>

<ul>
<li><code>GUID_SysKeyboard</code>：基本接続しているキーボードのGUID（マクロっぽい）</li>
<li><code>GUID_SysMouse</code>：基本接続しているマウスのGUID</li>
</ul>

<p>しかし、それ以外のデバイスはAPIで入れられる<strong>コールバック関数</strong>を通して検証する必要がある。また、それを行うためにはDInput8の<strong>メインオブジェクト</strong>をまず取得する必要がある。</p>

<blockquote>
<p>Getting Started with DirectInput</p>

<p>DirectInputを理解する為には、次のような用語を知っておく必要があるらしい。</p>

<ul>
<li>DirectInput Object：メインDirectInputのインタフェース</li>
<li>Device：キーボード、マウス、またコントローラーとなれるすべての入力デバイス</li>
<li>DirectInputDevice Object：Deviceの情報を持つ変数またはそれに準ずるコード</li>
<li>Device Object：DIDOから取得できるキー、ボタン、トリガーなどの構成要素</li>
</ul>
</blockquote>

<p>元記事では以下のようにDirectInput初期化手順を記述している。</p>

<ol>
<li>DirectInput Objectを生成する</li>
<li>GUIDを持つ全てのデバイスを検知し（コールバック関数を用いたクエリー）</li>
<li>適合なデバイスからDirectInput Device Objectを持ってくる。</li>
<li>DIDOのco-operation level、フォーマット、プロパティを設定する</li>
<li>Device Objectを取得する。</li>
<li>デバイスに入力をPollするかReadを行う。</li>
<li>取得したDevice Objectを先に開放し、そしてDirectInput Objectを開放して終わり。</li>
</ol>

<h1 id="大体のやり方">大体のやり方</h1>

<h2 id="1-directinput-objectを生成">1. DirectInput Objectを生成</h2>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416756(v%3dvs.85)">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416756%28v%3dvs.85%29</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">HRESULT</span> <span class="n">DirectInput8Create</span><span class="p">(</span>
         <span class="n">HINSTANCE</span> <span class="n">hinst</span><span class="p">,</span>
         <span class="n">DWORD</span> <span class="n">dwVersion</span><span class="p">,</span>
         <span class="n">REFIID</span> <span class="n">riidltf</span><span class="p">,</span>
         <span class="n">LPVOID</span> <span class="o">*</span> <span class="n">ppvOut</span><span class="p">,</span>
         <span class="n">LPUNKNOWN</span> <span class="n">punkOuter</span>
<span class="p">)</span></code></pre></div>
<p>上の関数の<code>ppvOut</code>に変数のポインターを入れて、<code>IDirectInput8</code>DirectInput Objectを取得する。取得したオブジェクトは一つしか生成しないようにしなければならないし、特別な状況じゃないとアプリケーションが終わるまで開放しないべきである。</p>

<p>また、<code>hinst</code>にはプロセス（アプリケーション）またはDLLのハンドルを入れるべき。普通は<code>GetModuleHandleW(nullptr)</code>でいいかも…</p>

<h2 id="2-guidを持つ全てのデバイスを検知">2. GUIDを持つ全てのデバイスを検知</h2>

<p>DirectInputはシステムが認知しているすべての入力デバイスを巡回し、連結されているかないか、そしてデバイスの情報を取得することが出来るようになっている。このデバイス全体を巡回して情報を要請することを<strong>Enumeration</strong>という。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417804(v%3dvs.85)">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417804%28v%3dvs.85%29</a></p>
</blockquote>

<p>Enumerationを行うためには、先程取得したDirectInput Objectの<code>EnumDevices</code>関数を使う。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">EnumDevices</span><span class="p">(</span>
         <span class="n">DWORD</span> <span class="n">dwDevType</span><span class="p">,</span>
         <span class="n">LPDIENUMDEVICESCALLBACK</span> <span class="n">lpCallback</span><span class="p">,</span>
         <span class="n">LPVOID</span> <span class="n">pvRef</span><span class="p">,</span>
         <span class="n">DWORD</span> <span class="n">dwFlags</span>
<span class="p">)</span>
</code></pre></div>
<p><code>dwDevType</code>は<code>DI8DEVCLASS_</code>列挙型の値を入れて、巡回させるデバイスの種類を縛る。コントローラーだけで縛って検証させるなら<code>DI8DEVCLASS_GAMECTRL</code>だけでいいかも。</p>

<p><code>lpCallback</code>は巡回するデバイスの情報などを取得ためのコールバック関数のポインターを指定する。関数の型は以下のようにしなければならない。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">BOOL</span> <span class="p">(</span><span class="o">*</span><span class="n">LPDIENUMDEVICESCALLBACK</span><span class="p">)(</span><span class="n">LPCDIDEVICEINSTANCE</span> <span class="n">lpddi</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">pvRef</span><span class="p">);</span>
</code></pre></div>
<p><code>pvRef</code>引数はコールバック関数に持っていくことが出来るポインター変数である。<code>lpddi</code>は<code>EnumDevices</code>関数で取得できたデバイスリストのデバイスインスタンスのポインターである。</p>

<p>普通はコールバック関数で、縛ったデバイスインスタンスの情報を検証して<code>pvRef</code>の構造体に情報を入れて使えるように準備をするようにしていればOKかもしれない…</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416610(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416610(v=vs.85)?redirectedfrom=MSDN</a></p>
</blockquote>

<p>コールバック関数で持ってこれる<code>DIDEVICEINSTANCE</code>構造体は以下のようになっている。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">DIDEVICEINSTANCE</span> <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">dwSize</span><span class="p">;</span>
    <span class="n">GUID</span> <span class="n">guidInstance</span><span class="p">;</span>
    <span class="n">GUID</span> <span class="n">guidProduct</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwDevType</span><span class="p">;</span>
    <span class="n">TCHAR</span> <span class="n">tszInstanceName</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
    <span class="n">TCHAR</span> <span class="n">tszProductName</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
    <span class="n">GUID</span> <span class="n">guidFFDriver</span><span class="p">;</span>
    <span class="n">WORD</span> <span class="n">wUsagePage</span><span class="p">;</span>
    <span class="n">WORD</span> <span class="n">wUsage</span><span class="p">;</span>
<span class="p">}</span> <span class="n">DIDEVICEINSTANCE</span><span class="p">,</span> <span class="o">*</span><span class="n">LPDIDEVICEINSTANCE</span><span class="p">;</span>
</code></pre></div>
<p>注意する点は、新しいAPIの<strong>xinput</strong>がデバイスによって同時にサポートされていることがありうるので、<code>guidProduct</code>を使ってxinputを支援しているかを確認しなければならない。</p>

<p>とにかく取得したいデバイスを探したら、<code>CreateDevice</code>関数を使ってDIDOを取得する。</p>

<h2 id="3-適合なデバイスからdirectinput-device-object取得">3. 適合なデバイスからDirectInput Device Object取得</h2>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417803(v%3Dvs.85">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417803(v%3Dvs.85</a>)</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">CreateDevice</span><span class="p">(</span>
         <span class="n">REFGUID</span> <span class="n">rguid</span><span class="p">,</span>
         <span class="n">LPDIRECTINPUTDEVICE</span> <span class="o">*</span> <span class="n">lplpDirectInputDevice</span><span class="p">,</span>
         <span class="n">LPUNKNOWN</span> <span class="n">pUnkOuter</span>
<span class="p">)</span>
</code></pre></div>
<p><code>rguid</code>にGUIDを入れるが、必ずインスタンスのGUIDである必要がある。<code>pUnkOuter</code>はCOM Aggregationのための引数であるため、今は使わない。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// 3. Get DirectInput Device Object pointer.
</span><span class="c1"></span><span class="n">IDirectInputDevice8</span><span class="o">*</span> <span class="n">p_device</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">p_dio</span><span class="o">-&gt;</span><span class="n">CreateDevice</span><span class="p">(</span><span class="n">lpddi</span><span class="o">-&gt;</span><span class="n">guidInstance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p_device</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DI_OK</span><span class="p">)</span>
<span class="p">{</span> 
    <span class="k">return</span> <span class="n">DIENUM_CONTINUE</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>
<h2 id="4-didoのco-operation-level-format-properties設定">4. DIDOのco-operation level、format、properties設定</h2>

<h3 id="co-operation-level">co-operation level</h3>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417921(v%3Dvs.85">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417921(v%3Dvs.85</a>)</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">SetCooperativeLevel</span><span class="p">(</span>
         <span class="n">HWND</span> <span class="n">hwnd</span><span class="p">,</span>
         <span class="n">DWORD</span> <span class="n">dwFlags</span>
<span class="p">)</span>
</code></pre></div>
<p>生成した窓の状態に対し（バックかフォアか、それとも特別な状態を持っているか）、取得したDIDOからのシグナル検知の権限を設定する。</p>

<p>僕の個人プロジェクトでは、表に見える窓だけではなくてバックグラウンドで動く窓もあるため、<code>dwFlags</code>は<code>DISCL_BACKGROUND | DISCL_EXCLUSIVE</code>にする。</p>

<h3 id="data-formats">Data formats</h3>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417925(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417925(v=vs.85)?redirectedfrom=MSDN</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">SetDataFormat</span><span class="p">(</span>
         <span class="n">LPCDIDATAFORMAT</span> <span class="n">lpdf</span>
<span class="p">)</span>
</code></pre></div>
<p>取得したDIDOから、どのようにデータを解釈して取得させるようにするかを設定する。実は<code>DIDATAFORMAT</code>構造体に値を入れてポインターとして入れなければならないか、DINPUTヘッダーファイル自体ですでに決まったものを入れれば良いらしい。</p>

<ul>
<li>c_dfDIKeyboard</li>
<li>c_dfDIMouse</li>
<li>c_dfDIJoystick</li>
<li>c_dfDIJoystick2</li>
</ul>

<blockquote>
<p>&hellip;
ちなみに実はジョイスティックには2種類の入力フォーマットがあり、そのもう1つが<strong>c_dfDIJoystick2</strong>と定義されています。
実際にはボタンやアナログの数が増えただけなので、PS2などの標準コントローラを使う分には特に意味はありませんが、
入力の多いデバイスを使用する場合はこちらの方を使う必要があります。
※<strong>c_dfDIJoystick</strong>と<strong>c_dfDIJoystick2</strong>のどちらを使用しても取得出来る分は取得できます
&hellip;</p>

<p>from : <a href="http://www.charatsoft.com/develop/otogema/page/07input/joystick.html">http://www.charatsoft.com/develop/otogema/page/07input/joystick.html</a></p>
</blockquote>

<p>データフォーマットを入れたら、後でデバイスのキー状態などを取得する際には入れた値にあっている構造体を入れなければならない。例えば、<code>c_dfDIJoystick</code>を入れた時には<code>DIJOYSTATAE</code>を使う。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416627(v%3Dvs.85">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416627(v%3Dvs.85</a>)</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">DIJOYSTATE</span> <span class="p">{</span>
    <span class="n">LONG</span> <span class="n">lX</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">lY</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">lZ</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">lRx</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">lRy</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">lRz</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">rglSlider</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">DWORD</span> <span class="n">rgdwPOV</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="n">BYTE</span> <span class="n">rgbButtons</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">}</span> <span class="n">DIJOYSTATE</span><span class="p">,</span> <span class="o">*</span><span class="n">LPDIJOYSTATE</span><span class="p">;</span>
</code></pre></div>
<h3 id="properties">Properties</h3>

<p>普通のゲームコントローラーって、デジタルのボタンなどを除くと、Lスティック、Rスティックそしてタッチパネルまたは特殊トリガーのような<strong>アナログ</strong>数値を持つ要素が残る。コントローラーごとにこのスティックなどの読み取り値が違うかもしれないので、それを一つの範囲などに合わせなければならない。その設定を<code>GetCapabilities</code>と<code>SetProperty</code>で設定することが出来るらしい。</p>

<p>まず、<code>GetCapabilities</code>と<code>DIDIVCAPS</code>構造体でDIDOのDevice Object情報を取得する必要がある。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417892(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417892(v=vs.85)?redirectedfrom=MSDN</a></p>

<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416607(v%3dvs.85)">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416607%28v%3dvs.85%29</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="nf">GetCapabilities</span><span class="p">(</span><span class="n">LPDIDEVCAPS</span> <span class="n">lpDIDevCaps</span><span class="p">)</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">DIDEVCAPS</span> <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">dwSize</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwFlags</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwDevType</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwAxes</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwButtons</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwPOVs</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwFFSamplePeriod</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwFFMinTimeResolution</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwFirmwareRevision</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwHardwareRevision</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwFFDriverVersion</span><span class="p">;</span>
<span class="p">}</span> <span class="n">DIDEVCAPS</span><span class="p">,</span> <span class="o">*</span><span class="n">LPDIDEVCAPS</span><span class="p">;</span>
</code></pre></div>
<p>そしてプロパティーを設定するなら、<code>SetProperty</code>を使う。ただし、設定したいプロパティーによって記述する構造体がそれぞれ違う。例えばスティック軸の数値の範囲を決めたい場合には下のコードのようにしなければならない。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416638(v%3dvs.85)">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416638%28v%3dvs.85%29</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">DIPROPHEADER</span> <span class="n">header</span><span class="p">;</span>
<span class="n">header</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DIPROPRANGE</span><span class="p">);</span>
<span class="n">header</span><span class="p">.</span><span class="n">dwHeaderSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DIPROPHEADER</span><span class="p">);</span>
<span class="n">header</span><span class="p">.</span><span class="n">dwObj</span> <span class="o">=</span> <span class="o">???</span><span class="p">;</span>
<span class="n">header</span><span class="p">.</span><span class="n">dwHow</span> <span class="o">=</span> <span class="o">???</span><span class="p">;</span>

<span class="n">DIPROPRANGE</span> <span class="n">range</span><span class="p">;</span>
<span class="n">range</span><span class="p">.</span><span class="n">diph</span> <span class="o">=</span> <span class="n">header</span><span class="p">;</span>
<span class="n">range</span><span class="p">.</span><span class="n">lMin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span><span class="p">;</span>
<span class="n">range</span><span class="p">.</span><span class="n">lMax</span> <span class="o">=</span> <span class="o">+</span><span class="mi">100</span><span class="p">;</span>

<span class="n">gameController</span><span class="o">-&gt;</span><span class="n">SetProperty</span><span class="p">(</span><span class="n">DIPROP_RANGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">range</span><span class="p">.</span><span class="n">header</span><span class="p">);</span>
</code></pre></div>
<p>注目すべき所は、<code>DIPROPHEADER</code>構造体の<code>dwObj</code>と<code>dwHow</code>である。公式の説明ページを見ればわかるかもしれないが、<code>dwHow</code>にはデバイスではなく、DIDOの中にある軸、ボタンなどのインスタンスを指すための<code>DIPH_BYID</code>を入れなければならない。</p>

<p>ただし、<code>DIPH_BYID</code>を入れたら、<code>dwObj</code>には<code>EnumObjects</code>関数で呼び出しするコールバック関数の中で取得できるインスタンスのIDを<code>dwObj</code>に入れなければならなくなる。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417889(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417889(v=vs.85)?redirectedfrom=MSDN</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">EnumObjects</span><span class="p">(</span>
         <span class="n">LPDIENUMDEVICEOBJECTSCALLBACK</span> <span class="n">lpCallback</span><span class="p">,</span>
         <span class="n">LPVOID</span> <span class="n">pvRef</span><span class="p">,</span>
         <span class="n">DWORD</span> <span class="n">dwFlags</span>
<span class="p">)</span>
  
<span class="c1">// Callback function pointer type
</span><span class="c1"></span><span class="n">BOOL</span> <span class="p">(</span><span class="o">*</span><span class="n">LPDIENUMDEVICEOBJECTSCALLBACK</span><span class="p">)(</span><span class="n">LPCDIDEVICEOBJECTINSTANCE</span> <span class="n">lpddoi</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">pvRef</span><span class="p">)</span>
</code></pre></div>
<p>書き方は上の<code>EnumDevices</code>と同じだが、<code>dwFlags</code>のフラグ値とコールバック関数の中での<code>SetProperty</code>コールに使われる構造体がよく合っていなければならない。（かもしれない）</p>

<p>ということで手順をまとめると、</p>

<ol>
<li><code>IDirectInputDevice8</code>のDIDOを取得し、</li>
<li><code>EnumObjects</code>関数で調べたいインスタンスの縛ってイテレーションさせ、</li>
<li>その中で適切なインスタンスがあったら<code>DIPROPHEADER</code>の入っている適切な構造体を記述して</li>
<li><code>SetProperty</code>でインスタンスに設定をする。</li>
</ol>

<p>アナログスティックの場合には、<strong>デッドゾーン（Deadzone)</strong>っていうのがあって、スティックを動かさないと必ず中立（0）の数値になるのではなく0に違い数値を表す時があって、それに対する誤動作を防ぐための判定範囲を設けなければならない。</p>

<p>アナログスティックなどのデッドゾーンを決めるには<code>DIPROPWORD</code>と<code>DIPROP_DEADZONE</code>を使う。ここで中止することは、デッドゾーンの数値は固定された0~10000までの範囲から決めなかればならない。例えばスティック入力の1%以内をデッドゾーンとして決めたいなら、100を入れる。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416636(v%3dvs.85)">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416636%28v%3dvs.85%29</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">DIPROPDWORD</span> <span class="p">{</span>
    <span class="n">DIPROPHEADER</span> <span class="n">diph</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwData</span><span class="p">;</span>
<span class="p">}</span> <span class="n">DIPROPDWORD</span><span class="p">,</span> <span class="o">*</span><span class="n">LPDIPROPDWORD</span><span class="p">;</span>
</code></pre></div>
<p>ちなみに元記事ではRANGEとWORDを同時に設定している。</p>

<h2 id="5-device-objectを取得-acquire">5. Device Objectを取得(Acquire)</h2>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417818(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417818(v=vs.85)?redirectedfrom=MSDN</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">Acquire</span><span class="p">()</span>
</code></pre></div>
<p>設定した入力デバイスに接近する権限を得る。アプリケーションを終了したり、それとも使っているコントローラーのアクセス権限を返却する場合には</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417931(v=vs.85">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417931(v=vs.85</a>)</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">Unacquire</span><span class="p">()</span>
<span class="c1">// and
</span><span class="c1"></span><span class="n">HRESULT</span> <span class="n">Release</span><span class="p">()</span>
</code></pre></div>
<p>を使う。（Releaseを連続で呼び出すのは、CreateDeviceで参照カウントが１増加されたから）</p>

<h2 id="6-デバイスの入力をpollするかreadを行う">6. デバイスの入力をPollするかReadを行う</h2>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417913(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417913(v=vs.85)?redirectedfrom=MSDN</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">Poll</span><span class="p">()</span>
</code></pre></div>
<p>取得したデバイスによって違われるかもしれないが、大体は<code>Poll()</code>関数でデバイスか入力情報を取得しなおさなければならない。あるデバイスは自分からインターラプト（Interrupt）をかけて入力データを取得するようにするものもあるが、そのデバイスに限っては<code>Poll()</code>を呼び出す必要はない（読んだとしてもエラーにはならない）</p>

<p>もしかして<code>Poll</code>関数を呼ぶ必要があるかを確かめる為には、<code>GetCapabilities()</code>関数で<code>DIDEVCAPS</code>の<code>DIDC_POLLEDDATAFORMAT</code>を確認すれば良いらしい。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417897(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417897(v=vs.85)?redirectedfrom=MSDN</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">GetDeviceState</span><span class="p">(</span>
         <span class="n">DWORD</span> <span class="n">cbData</span><span class="p">,</span>
         <span class="n">LPVOID</span> <span class="n">lpvData</span>
<span class="p">)</span>
</code></pre></div>
<p>デバイスで更新された情報を持ってくるためには上の関数を使う。ただし、この関数を使うには<code>lpvData</code>は前にDIDOのデータフォーマット（DataFormat）を設定した時の値に対応している構造体を入れなければならない。</p>

<table>
<thead>
<tr>
<th>Data Format</th>
<th>State Structure</th>
</tr>
</thead>

<tbody>
<tr>
<td>c_dfDIMouse</td>
<td><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416630(v%3dvs.85)">DIMOUSESTATE</a></td>
</tr>

<tr>
<td>c_dfDIMouse2</td>
<td><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416631(v%3dvs.85)">DIMOUSESTATE2</a></td>
</tr>

<tr>
<td>c_dfDIKeyboard</td>
<td>array of 256 bytes</td>
</tr>

<tr>
<td>c_dfDIJoystick</td>
<td><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416627(v%3dvs.85)"> DIJOYSTATE</a></td>
</tr>

<tr>
<td>c_dfDIJoystick2</td>
<td><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416628(v%3dvs.85)">DIJOYSTATE2</a></td>
</tr>
</tbody>
</table>

<h2 id="7-directinput-objectを開放して終わり">7. DirectInput Objectを開放して終わり</h2>

<p>「5. Device Objectを取得(Acquire)」を見ること。</p>

			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/posts/shader_opti_memo_2/">Low-level shader optimization for next-gen and D3D11のメモ</a></li>
				
				<li><a href="/posts/sfinae_afaid/">SFINAEの活用、ざっくりメモ</a></li>
				
				<li><a href="/posts/shader_opti_memo/">Low Level Thinking in High Shader Languages</a></li>
				
				<li><a href="/posts/dinput8/">DirectInput8 導入メモ</a></li>
				
				<li><a href="/posts/tlsf_basic/">TLSF Allocatorを作ってみた</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2020 <a href="https://liliilli.github.io"><b>neuromantic</b></a>.
	<a href="https://github.com/liliilli"><b>Github</b></a>.
	<a href="https://twitter.com/NeuliliilliD"><b>Twitter</b></a>.
	</p>
</footer>

</body>
</html>
