<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on neuromantic</title>
		<link>https://liliilli.github.io/posts/</link>
		<description>Recent content in Posts on neuromantic</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Thu, 21 Nov 2019 20:33:04 +0900</lastBuildDate>
		<atom:link href="https://liliilli.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>C&#43;&#43;2aのconceptsを使ってみた。</title>
			<link>https://liliilli.github.io/posts/cpp_concept/</link>
			<pubDate>Thu, 21 Nov 2019 20:33:04 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/cpp_concept/</guid>
			<description>C++のConceptを簡略説明 C++2a（20）から追加する文法の一つであるconceptは、あるタイプの制約条件を記すことができる識別子</description>
			<content type="html"><![CDATA[

<h1 id="c-のconceptを簡略説明">C++のConceptを簡略説明</h1>

<p>C++2a（20）から追加する文法の一つである<code>concept</code>は、あるタイプの制約条件を記すことができる識別子です。制約条件というのは<code>Constraints</code>と呼びますが、あくまでも付与された<code>concept</code>を満足するための一連の条件組だと言えます。以下はある<code>concept</code>を宣言するコードです。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">is_floating_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<p>注意することは、宣言したconceptは、他のconceptを宣言する時に型引数で<code>typename</code>または<code>class</code>の代わりに使うことはできません。また、<code>requires</code>を使うこともできません。ただし、定義する構文で使うことはできます。</p>

<p>constraintsはconceptだけじゃなくて、<code>requires</code>文法を使ってタイプの条件を設定することができます。C#に例えたら、多分<code>where</code>が一番近いんじゃないかな？と思いますね。下はconceptを使わずにconstraintsだけを使っているコードです。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// First syntax of `requires` and `constraints`
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go3</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">v2</span><span class="p">)</span> <span class="k">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>宣言したconceptは次のように使えます。conceptじゃない構文であれば、<code>typename</code>と<code>class</code>の代わりに使えることがわかります。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="n">is_floating_point</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go4</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>ただし、上のコードではあくまでも<code>v1</code>と<code>v2</code>が<code>Float</code>という型に縛られているので、<code>v1</code>に<code>double</code>を入れたり<code>v2</code>に<code>float</code>を入れてコンパイルすることはできません。下のコードでは、上記の問題点を解決するため<code>template</code>を使わず、conceptを型として使います。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">auto</span> <span class="nf">go5</span><span class="p">(</span><span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>[const/volatile] concept auto [&amp;, &amp;&amp;]</code>を使うことで<code>v1</code>と<code>v2</code>のタイプは別々のタイプが持てるようになります。実はリターン型<code>auto</code>の前にもconceptをくっつけることが出来ます。</p>

<p>最後に、変数にもconceptが使えます。<code>auto</code>を一緒に使いますが、前にconceptを書けることでタイプ自体じゃなくてできる行動・特性をもつタイプの一連として考えるようになり、もっと柔軟なロジックを組むことが出来ます。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//floating_point auto val2 = go6(1.2f, 3.4f); 
</span><span class="c1">// go6は`int`を返しますが、`int`はfloating_pointコンセプトの条件が満たしていないので
</span><span class="c1">// コンパイルエラーが出ます。
</span><span class="c1"></span><span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">val3</span> <span class="o">=</span> <span class="n">go5</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>
</code></pre></div>
<h1 id="もっと詳しく知りたい方へ">もっと詳しく知りたい方へ</h1>

<p>上の説明は、<code>concept</code>と<code>requires</code>、そして条件構文でできることの一部しか紹介していません。詳しく知りたい型には以下の文書をお読みいただけましたら嬉しいです。</p>

<p><a href="https://en.cppreference.com/w/cpp/language/constraints">https://en.cppreference.com/w/cpp/language/constraints</a></p>

<p>また、C++のコードがウェブで作成できるCompiler Explorerというサイトで、gcc (trunk)またはclang (concepts)を選択しましたら<code>concept</code>が実装されたバージョンでコードが組めることが出来ます。</p>

<h1 id="full-code">Full code</h1>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go1</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">value1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">value2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">Float</span><span class="p">,</span>
    <span class="k">typename</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;&gt;</span>
<span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go2</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">value1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">value2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// First syntax of `requires`.
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go3</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">v2</span><span class="p">)</span> 
    <span class="k">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Using concept instead of typename or class in template.
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">is_floating_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">is_floating_point</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go4</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">floating_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// We can write `floating_point` explicitly before `auto` return.
</span><span class="c1">// When `floating_point` is written before auto, return value should
</span><span class="c1">// satisfy `floating_point` constraint.
</span><span class="c1"></span><span class="k">auto</span> <span class="nf">go5</span><span class="p">(</span><span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="nf">go6</span><span class="p">(</span><span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="kt">int</span><span class="p">{</span><span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">};</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//go1(1, 2.3);
</span><span class="c1"></span>    <span class="c1">//go1(1.2f, 2.3);
</span><span class="c1"></span>    <span class="n">go1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>          <span class="c1">// Float is int.
</span><span class="c1"></span>    <span class="n">go1</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">2.3f</span><span class="p">);</span>    <span class="c1">// Float is float.
</span><span class="c1"></span>    <span class="n">go1</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">);</span>      <span class="c1">// Float is double.
</span><span class="c1"></span>
    <span class="c1">//go2(1, 2);        // Substitution is failed, and output message is bizzare.
</span><span class="c1"></span>    <span class="n">go2</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">);</span>      <span class="c1">// Float is double.
</span><span class="c1"></span>
    <span class="c1">// Substitution is failed 
</span><span class="c1"></span>    <span class="c1">// but output message is humble and more readable.
</span><span class="c1"></span>    <span class="c1">//go3(1, 2);
</span><span class="c1"></span>    <span class="c1">//go3(1, 2.3);
</span><span class="c1"></span>    <span class="n">go3</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>        

    <span class="c1">// constraints not satisfied
</span><span class="c1"></span>    <span class="c1">//go4(1, 10);
</span><span class="c1"></span>    <span class="c1">// Also need one uniformed type.
</span><span class="c1"></span>    <span class="c1">// template argument deduction/substitution failed:
</span><span class="c1"></span>    <span class="c1">//go4(1.2f, 3.4);     
</span><span class="c1"></span>    <span class="n">go4</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>
    <span class="n">go4</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>

    <span class="c1">// error: use of function &#39;auto go5(auto:1, auto:2) 
</span><span class="c1"></span>    <span class="c1">// [with auto:1 = int; auto:2 = int]&#39; with unsatisfied constraints
</span><span class="c1"></span>    <span class="c1">//go5(1, 10);
</span><span class="c1"></span>    <span class="n">go5</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>
    <span class="n">go5</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>
    <span class="n">go5</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>
    <span class="n">go5</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">val1</span> <span class="o">=</span> <span class="n">go6</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span> <span class="c1">// This outputs warning but not error,
</span><span class="c1"></span>    <span class="c1">// But below is failed to compile.
</span><span class="c1"></span>    <span class="c1">// &lt; constraints not satisfied
</span><span class="c1"></span>    <span class="c1">// &lt; the expression &#39;is_floating_point_v&lt;T&gt;&#39; evaluated to &#39;false&#39;
</span><span class="c1"></span>    <span class="c1">//floating_point auto val2 = go6(1.2f, 3.4f);
</span><span class="c1"></span>    <span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">val3</span> <span class="o">=</span> <span class="n">go5</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>
    <span class="k">return</span> <span class="kt">int</span><span class="p">{</span><span class="n">val3</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>ShaderToyでPBRを書いてから、自ら解説してみた。</title>
			<link>https://liliilli.github.io/posts/shadertoy_pbr/</link>
			<pubDate>Sat, 16 Nov 2019 19:51:58 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/shadertoy_pbr/</guid>
			<description>実は2週前に、ShaderToyというウェブでGLSLがかけて、それをレンダリングすることができるサイトで、上のシェーダーを書いてました。前</description>
			<content type="html"><![CDATA[

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/WsdSDf?gui=true&t=10&paused=true&muted=false" allowfullscreen></iframe>
実は2週前に、ShaderToyというウェブでGLSLがかけて、それをレンダリングすることができるサイトで、上のシェーダーを書いてました。前にもShaderToyで色々と書いたんですが、PBRを本格に適用して書いたのは今が初めてです。</p>

<p>なんで、このシェーダーを書きながら、どうやってPBRのDiffuseとSpecularを実装したのかを簡単と大雑把に書きたいと思います。図形の作り方、またはレイマーチングのやり方に関しては説明いたしません。</p>

<h1 id="本編">本編</h1>

<p>PBRレンダリングを勉強するときによく見られるDisneyの<code>Physical-Based Shading at Disney</code>、または色々のPBRが基づく理論文書を読みますと、光と視点のよるある地点の色は以下になります。</p>

<p>$$
f(\pmb{l}, \pmb{v}) = \text{diffuse} + \text{specular}
$$
<code>Diffuse</code>と<code>Specular</code>はそれぞれの特性を独立的に持てると言えます。なので、実施に最終色を入れるときに次のように単純に<code>Diffuse</code>と<code>Specular</code>を入れます。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="c1">// fragColorは[0,1]のvec4(R,G,B,A)です。</span>
<span class="n">fragColor</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">dif</span> <span class="o">+</span> <span class="n">spc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></code></pre></div>
<blockquote>
<p>$$ f(\pmb{l}, \pmb{v}) $$ は実際には色そのまのを表してはいません。あくまでBRDF（Bidirectional-Reflectance Distribution Funciton）のモデルを表したものであり、実際にはぶつかった入射光線と表面の法線での半球で、すべての反射光線がどの角度とエナジーを持つのかを調べて、全部合わせないと正確な数値が計算できません。</p>

<p>ただし、今はもっと抽象化した数式を使ってレンダリングをしようとします。リアルタイムで完全な数式を解いて色を得ることはほぼ不可能だし、もっと抽象化したモデルでもだいたい通じます。</p>
</blockquote>

<h2 id="diffuse">Diffuse</h2>

<p>普通よく使うのは<code>Lambertian</code>ですが<code>Oren-Nayar</code>っていう、もっと正確なPBRモデルもあります。僕は最初は<code>Lambertian</code>を使いましたが、最終は<code>Oren-Nayar</code>にしました。</p>

<h3 id="lambertian">Lambertian</h3>

<p>$$
f(\pmb{l}, \pmb{v}) = \frac{\rho_{ss}}{\pi}
$$</p>

<p><code>Diffuse</code>モデルの中で一番簡単なモデルです。色だけでモデルBRDFが決まりますし、だとしてもそれっぽく見えるようになるので普通のゲームでもよく使います。</p>

<p>ここで
$$
\rho_{ss}
$$
は、表面のアルベド（物体が光を弾いたときの反射率）を表します。これだけがLambertianのモデルの数値になります。</p>

<p>下のコードはLambertianモデルを使って、実際のピクセルのカラーを表現するコードです。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">FactorDiffLambertian</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">/</span> <span class="n">pi</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">vec3</span> <span class="n">DiffuseLambertian</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> 
                       <span class="k">in</span> <span class="k">vec3</span> <span class="n">diffuse</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">ambient</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mix</span><span class="p">(</span><span class="n">ambient</span><span class="p">,</span> <span class="n">diffuse</span><span class="p">,</span> <span class="n">FactorDiffLambertian</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>注意するとこは、<code>FactorDiffLamberitan</code>の中の<code>dot(l, n)</code>は実際はLambertianのモデルの数式に含まれていません。<code>mix(ambient, diffuse, ...)</code>の<code>diffuse</code>が上記の
$$
\rho_{ss}
$$
になります。
そして、<code>FactorDiffLambertian</code>関数は、以下の数式
$$
L_o(\mathbf{v}) = \int_{\mathbf{l}\in\Omega}{f(\mathbf{l}, \mathbf{v})L_i(\mathbf{l})(\mathbf{n}\cdot\mathbf{l})d\mathbf{l}}
$$
の<code>dot(l, n)</code>項を表しています。（ただし、πは事前に入れときました。反省するとこですね。）</p>

<p>このモデルの特徴は表面が平坦だと見なしてレンダリングを行うところです。Roughnessが関与するとこが無く、単純にアルベドと光と表面の法線ベクトルによる明度だけをレンダリングします。ということで、ちょっと単純だけどコストが速いし、それなりにごまかせば他のモデルとあんまり違いは出ないと思います。</p>

<h3 id="oren-nayar">Oren-Nayar</h3>

<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model">https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model</a>
<a href="https://mimosa-pudica.net/improved-oren-nayar.html">https://mimosa-pudica.net/improved-oren-nayar.html</a></p>
</blockquote>

<p>このモデルは上のLambertianとは違って、表面の粗さによって明度の違いのレンダリングを調節できます。Oren-Nayarとともに表面の粗さによるDiffuseレンダリングモデルを総じて、<code>Rough-surface diffuse BRDF</code>と呼びます。</p>

<p>とりあえずOren-Nayarは論文をみますとFull-Model（完全モデル）とQuantitive-Model（ある程度省略したモデル）に分かれています。ウィキペディアに乗っているのはQuantitive-Modelだし、僕もフールモデルじゃなくてQuantitive-Modelを使ってOren-Nayarを実装してます。</p>

<p>Oren-Nayar（Quantitiveバージョン）は以下の数式となります。
$$
\begin{align}
L_{r} &amp;=
    \frac{\rho}{\pi}
    \cdot (\mathbf{l} \cdot \mathbf{n})
    \cdot (A + (B \cdot \max[0, \cos(\phi_{i} - \phi_{v})]
        \cdot \sin\alpha
        \cdot \tan\beta))
    \cdot E_0
\\<br />
A &amp;= 1 - 0.5\frac{\sigma^2}{\sigma^2 + 0.33}
\\<br />
B &amp;= 0.45 \frac{\sigma^2}{\sigma^2 + 0.09}
\\<br />
\alpha &amp;= \max(
    \theta_{\mathbf{l} \cdot \mathbf{n}},
    \theta_{\mathbf{v} \cdot \mathbf{n}})
\\<br />
\beta &amp;= \min(
    \theta_{\mathbf{l} \cdot \mathbf{n}},
    \theta_{\mathbf{v} \cdot \mathbf{n}})
\end{align}
$$
しかし僕は2番目のリンクにあるベクトルを使った数式を使いました。
$$
\begin{align}
L_o &amp;= \frac{\rho}{\pi}\cdot(\mathbf{l}\cdot\mathbf{n})(A + B\frac{\mathbf{s}}{t})
\\<br />
s &amp;= \mathbf{l}\cdot\mathbf{v} - (\mathbf{n}\cdot\mathbf{l})(\mathbf{n}\cdot\mathbf{v})
\\<br />
t &amp;=
\begin{cases}
1 &amp; \text{if $s \le 0$} \\<br />
\max(\mathbf{n}\cdot\mathbf{v}, \mathbf{n}\cdot\mathbf{l}) &amp; \text{if $s \gt 0$}
\end{cases}
\\<br />
A &amp;= (1 - 0.5\frac{\sigma^2}{\sigma^2 + 0.33} + 0.17\rho\frac{\sigma^2}{\sigma^2 + 0.13})
\\<br />
B &amp;= 0.45\frac{\sigma^2}{\sigma^2 + 0.09}
\end{align}
$$
なぜなら、上の数式を直接反映してみたらところどころでバグによる明るい曲線が見えるからです。多分<code>tan()</code>項でバグったりして不具合が描画されると思いますが、直せずに下のベクトル形態の数式を使ってOren-NayarのQuantitive-Modelを実装しました。</p>

<p>数式で見れる<code>\rho</code>（$ \rho $ ）はアルベドを表します。普通Lamberitanのアルベドのように、アルベドカラーを入れます。そして<code>\sigma</code>（$ \sigma $）は表面の粗さ（Roughness）を示します。だいたい０～１の値を持ちます。</p>

<p>上の数式を表したコードは下にあります。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">OrenNayarAlpha</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">OrenNayarBeta</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mix</span><span class="p">(</span>
        <span class="mf">1.</span><span class="n">f</span><span class="p">,</span>
        <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)),</span>
        <span class="n">step</span><span class="p">(</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">OrenNayarAlpha</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">OrenNayarA</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">-</span> <span class="mf">0.5</span><span class="n">f</span> <span class="o">*</span> <span class="p">(</span>
         		<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
    <span class="o">/</span> <span class="c1">// ----------------------</span>
        	<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.33</span><span class="n">f</span><span class="p">)</span>           
    <span class="p">)</span>
    <span class="o">+</span> <span class="mf">0.17</span><span class="n">f</span> <span class="o">*</span> <span class="p">(</span>
        		<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
    <span class="o">/</span> <span class="c1">// ----------------------</span>
        	<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.13</span><span class="n">f</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">OrenNayarB</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mf">0.45</span><span class="n">f</span> <span class="o">*</span> <span class="p">(</span>
         		<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
    <span class="o">/</span> <span class="c1">// ----------------------</span>
        	<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.09</span><span class="n">f</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">FactorDiffOrenNayar</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">float</span> <span class="n">A</span>  	<span class="o">=</span> <span class="n">OrenNayarA</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    <span class="k">float</span> <span class="n">B</span> 	<span class="o">=</span> <span class="n">OrenNayarB</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    <span class="k">float</span> <span class="n">_a</span> 	<span class="o">=</span> <span class="n">OrenNayarAlpha</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">float</span> <span class="n">_b</span> 	<span class="o">=</span> <span class="n">OrenNayarBeta</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">FactorDiffLambertian</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span> <span class="o">*</span> <span class="p">(</span><span class="n">_a</span> <span class="o">/</span> <span class="n">_b</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">vec3</span> <span class="n">DiffuseOrenNayar</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> 
                      <span class="k">in</span> <span class="k">vec3</span> <span class="n">diffuse</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">ambient</span><span class="p">,</span> 
                      <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mix</span><span class="p">(</span><span class="n">ambient</span><span class="p">,</span> <span class="n">diffuse</span><span class="p">,</span> <span class="n">FactorDiffOrenNayar</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>一気にコードの量が増えましたが、分析していただきましたら大したものはないことがわかります。</p>

<p>実は、2番目のリンク先で投稿した方の改良したOren-Nayarモデルも実装はしたんですが、光が表面全体を照らすときの描画が好きじゃなかったので断念してOren-NayarのQuantitive-Modelを最終採用しました。</p>

<h2 id="specular">Specular</h2>

<p>SpecularのBRDFも、上のDiffuseのようにMicrofacet理論に基づいたモデルを使っています。Specular（ハイライト）は、Diffuseとは違ってカメラの目線によってある位置にハイライトの陰影がつけられるかが異なります。（なんで、Lambertianみたいな単純なモデルは無いです）</p>

<p>普通に使ってるPBRのSpecularモデルは、以下の<strong>Cook-Torrance Model</strong>です。
$$
f_{spec}(\mathbf{l}, \mathbf{v}) = \frac
    {F(\mathbf{h}, \mathbf{l})G_{2}(\mathbf{l},\mathbf{v},\mathbf{h})D(\mathbf{h})}
    {4|\mathbf{n}\cdot\mathbf{l}||\mathbf{n}\cdot\mathbf{v}|}
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">cn</span> <span class="o">=</span> <span class="mf">4.</span><span class="n">f</span> <span class="o">*</span> <span class="n">max</span><span class="p">(</span><span class="mf">.25</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ld</span><span class="p">))</span> <span class="o">*</span> <span class="n">max</span><span class="p">(</span><span class="mf">.25</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="n">fwd</span><span class="p">));</span>
            
<span class="k">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">GTR</span><span class="p">(</span><span class="mi">9</span><span class="n">e</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="n">kBx1</span><span class="p">.</span><span class="n">mRough</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="mf">2.</span><span class="n">f</span><span class="p">);</span>
<span class="k">float</span> <span class="n">f</span> <span class="o">=</span> <span class="n">Schlick</span><span class="p">(</span><span class="n">kBx1</span><span class="p">.</span><span class="n">mR0</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
<span class="k">float</span> <span class="n">g</span> <span class="o">=</span> <span class="n">SeparableMaskingShadowing</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">kBx1</span><span class="p">.</span><span class="n">mRough</span><span class="p">);</span>
            
<span class="n">spc</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">f</span> <span class="o">*</span> <span class="n">g</span> <span class="o">/</span> <span class="n">cn</span><span class="p">;</span></code></pre></div>
<h3 id="fresnel-reflection">Fresnel Reflection</h3>

<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Fresnel_equations">https://en.wikipedia.org/wiki/Fresnel_equations</a>
<a href="https://en.wikipedia.org/wiki/Schlick%27s_approximation">https://en.wikipedia.org/wiki/Schlick%27s_approximation</a></p>
</blockquote>

<p>上記のCook-Torrance Modelにて、分子の
$$
F(\mathbf{h}, \mathbf{l})
$$
はフレネルの式を示します。要するに、光の入射光線がある物体の表面にぶつかるときの正反射率を表す数式です。全ての物質は自分のIOR（屈折率）と外部のIORによってそれぞれ違う反射率を持ちます。</p>

<p>ウィキペディアを見ていただきますと正確な数式がありますが、CGでシェーダープログラムにフレネルの式の全部をやらせるには負担がかかりすぎます。なので、下の単純なモデルを使いながらある程度フレネルの式を従います。
$$
F(\mathbf{h}, \mathbf{l}) \approx F_0 + (1 - F_0)(1 - (\mathbf{h}\cdot\mathbf{l})^+)^5
$$
この数式は<strong>Schlick-Approximation</strong>と言います。空気中の物質に対するフレネルの式の数値を得たいときの使います。もちろん、抽象化されたモデルなので正確ではありません。ですがフレネルの式の数値のグラフでの変動をある程度沿っています。</p>

<p>ここで、
$$
F_0
$$
は垂直入射の時のFresnel反射係数の実部です。この数値はRGBまたは普通のグレースケールの数値として入れられます。グレースケールになる場合には、物質が金属ではない場合で使えます。RGBは金属の物質のフレネルの数値を求めたい場合に使えます。（大雑把でしたけど、もっと詳しくお調べしたい方々は*Real-Time Rendering 4th*のChapter9をお読みくださいませ）
$$
\mathbf{h} = \text{normalize($\mathbf{l} + \mathbf{v}$)}
$$
<code>h</code>はハーフウェイベクトル（Halfway Vector）と言います。DiffuseとSpecularを一つに統合したレンダリングモデルである、Blinn-Phong Reflectance Modelでも使うやつです。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">Schlick</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r0</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">r0</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">r0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)),</span> <span class="mf">5.</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// または</span>

<span class="k">float</span> <span class="n">Schlick</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r0</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">td</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">r0</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">r0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="n">cos</span><span class="p">(</span><span class="n">td</span><span class="p">)),</span> <span class="mf">5.</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>上のコードはSchlick Approximationを2つのバージョンで実装したものです。下のバージョンの<code>td</code>は、<code>n</code>と<code>v</code>の角度差を表します。</p>

<h3 id="normal-distribution-function">Normal Distribution Function</h3>

<p>法線分布関数だと呼ばれる<strong>Normal Distribution Function</strong>は、微小面の法線がどうやって分布されているかを示す関数です。この関数は統計的に測定されて使っているか、それともある抽象化した数学関数を用いて使います。詳しくはmicrofacet理論の触れますので割愛します。</p>

<p>ですけどこのNDFに特徴の一つは、あるNDF関数があって、そしてある表面の法線ベクトル <code>N</code> があった時に、球面を覆う単位ベクトルを入れたNDFの値の積分は、<code>N</code> を持つ微細表面の面積になります。ということで、
$$
\int_{\mathbf{m} \in \Theta} {D(\mathbf{m})(\mathbf{n} \cdot \mathbf{m})d\mathbf{m}} = 1
$$
になります。</p>

<p>また、カメラまたは目線のベクトル<code>v</code>があるとき、ある表面の法線ベクトルが<code>n</code>で、そして微細表面の球体の単位ベクトルが<code>m</code>だとしたら、
$$
\int_{\mathbf{m} \in \Theta}{D(\mathbf{m})(\mathbf{v}\cdot\mathbf{m})d\mathbf{m}} = \mathbf{v}\cdot\mathbf{n}
$$
です。目によって実際に見える微小面の面積は微小面の凸凹の法線ベクトルたちを目線のベクトルとの内積し、結果値を全部足したのと同じです。<code>v * m</code>で目に見えない微小面はなくなりまし、見える表面は残ります。</p>

<p>一応これもリアルタイムでは計算しにくいので、上の特性から派生した様々な抽象化したモデルがあります。僕はDisney BRDFで使った<strong>GTR (Generalized-Trowbridge-Reitz）</strong>モデルを使いました。このモデルはGGX（Trowbridge-Reitz）モデルを一般化したものです。
$$
D_{GTR} = \frac{c}{(a^2\cos^2(\theta_{h})+\sin^2(\theta_{h}))^\gamma}
$$</p>

<blockquote>
<p>実はこの数式も実使用で使うために簡略化された数式です。Realtime-RenderingでGTRの完全数式を見てみますと結構ひどいです。（白目）</p>
</blockquote>

<p>上の数式で、<code>gamma</code>が2ならGGXと同じになります。以下はGTRをコードに写したものです。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">GTR</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">c</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">dh</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">gamma</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> 
        						 <span class="n">c</span>
    <span class="o">/</span> <span class="c1">//--------------------------------------------------------</span>
        <span class="n">pow</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">dh</span><span class="p">),</span> <span class="n">gamma</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h3 id="joint-masking-shadowing-function">Joint Masking Shadowing Function</h3>

<p>Joint Masking Shadowing Functionを説明する前に、簡単に一般Masking Function <code>G</code>を説明させていただきたいと思います。日本語でいうと<strong>幾何減衰項</strong>（読み方はわかりません）と言います。Masking Functionは微小面（Microfacet）によって発生するシャドウィング（自己陰影）、マスキング（自己遮蔽）を表したものです。</p>

<p>幾何減衰項は上で説明したNDFに（法線分布関数）と密接に関連されます。上の表面の法線・微小面の法線・目線の法線との関係がある数式は、以下のように変形できます。
$$
\int_{\in\Theta}{G_1(\mathbf{m}, \mathbf{v})D(\mathbf{m})(\mathbf{v}\cdot\mathbf{m})^+d\mathbf{m}} = \mathbf{v}\cdot\mathbf{n}
$$
ここで <code>G_1(m, v)</code>は<strong>Smith Function</strong>といい、<code>v</code>に対して見える<code>m</code>の比率を表します。ですけど、G1は実際には<code>m</code>が目線の反対方向を向いていなければ、G1の数値に全然影響がない特徴を持ちます。なのでSmith Function G1の数式は
$$
G_1(\mathbf{m}, \mathbf{v}) = \frac{\chi^+(\mathbf{m}\cdot\mathbf{v})}{1 + \Lambda(\mathbf{v})}
$$
となります。コードでは上の分子の項は、<code>m</code>と<code>v</code>の内積が0より大きければ1として置換できます。ですがこれをこのまま使うのではなく、BRDFを建てる時には以下のようにG1の代わりにG2を使います。
$$
f(\mathbf{l}, \mathbf{v}) =
    \int_{\mathbf{m}\in\Theta}
        f_{\mu}(\mathbf{l}, \mathbf{v}, \mathbf{m})
        G_2(\mathbf{l}, \mathbf{v}, \mathbf{m})
        D(\mathbf{m})
        \frac{(\mathbf{m}\cdot\mathbf{l})^+}{|\mathbf{n}\cdot\mathbf{l}|}
        \frac{(\mathbf{m}\cdot\mathbf{v})^+}{|\mathbf{n}\cdot\mathbf{v}|}
        d\mathbf{m}
\\<br />
\\<br />
G_2(\mathbf{l}, \mathbf{v}, \mathbf{m}) =
    G_1(\mathbf{v}, \mathbf{m})
    G_1(\mathbf{l}, \mathbf{m})
$$
上のG2の形以外に、様々な変形数式が存在します。G1を2つくっつけて掛け算する数式が一番だったりしますが、不具合が存在しますので下のも使われるそうです。（下は*Smith Height-Correlated Masking-Shadowing Function*）と言います。
$$
G_2(\mathbf{l}, \mathbf{v}, \mathbf{m}) = \frac{\chi^+(\mathbf{v}\cdot\mathbf{m})\chi^+(\mathbf{l}\cdot\mathbf{m})}{1 + \Lambda(\mathbf{v}) + \Lambda(\mathbf{l})}
$$
僕は一番簡単な分離型G2を使いました。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">Lambda</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">rad</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> 
        <span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="n">f</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span><span class="n">f</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="n">f</span> <span class="o">/</span> <span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span><span class="n">f</span><span class="p">)))</span> <span class="o">*</span> <span class="mf">.5</span><span class="n">f</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">SmithMasking</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">rad</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span>
        		<span class="mf">1.</span><span class="n">f</span>
    <span class="o">/</span> <span class="c1">//-----------------------</span>
        <span class="p">(</span><span class="mf">1.</span><span class="n">f</span> <span class="o">+</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">rad</span><span class="p">,</span> <span class="n">r</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">SeparableMaskingShadowing</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">tl</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">tv</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">SmithMasking</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">SmithMasking</span><span class="p">(</span><span class="n">tv</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h1 id="まとめ">まとめ</h1>

<p>以上、大雑把にコードを振り返りながらPBRの書き方、中身についてメモをしてみました。</p>

<h1 id="もっと詳しく調べたい方に">もっと詳しく調べたい方に</h1>

<ul>
<li><a href="https://qiita.com/mebiusbox2/items/1cd65993ffb546822213">https://qiita.com/mebiusbox2/items/1cd65993ffb546822213</a></li>

<li><p><a href="https://qiita.com/mebiusbox2/items/8db00cdcaf263992a5ce">https://qiita.com/mebiusbox2/items/8db00cdcaf263992a5ce</a></p></li>

<li><p><a href="https://qiita.com/emadurandal/items/3a8db7bc61438245654d">https://qiita.com/emadurandal/items/3a8db7bc61438245654d</a></p></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Chained-Group Allocationパターンについてメモ</title>
			<link>https://liliilli.github.io/posts/chained-group-allocation/</link>
			<pubDate>Sat, 09 Nov 2019 22:15:34 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/chained-group-allocation/</guid>
			<description>https://www.plflib.org/chained_group_allocation_pattern.htm を見て、分かったことをメモしたいと思います。 Abstract Chanined-Group Allocationパターンは、ダブルリンクリストを拡張して、書くノードは付加的な情報を持</description>
			<content type="html"><![CDATA[

<p><a href="https://www.plflib.org/chained_group_allocation_pattern.htm">https://www.plflib.org/chained_group_allocation_pattern.htm</a><br>を見て、分かったことをメモしたいと思います。</p>

<h2 id="abstract">Abstract</h2>

<p><strong>Chanined-Group Allocation</strong>パターンは、ダブルリンクリストを拡張して、書くノードは付加的な情報を持ちながらメモリを動的に確保して使わせるパターンです。書くノードは２の二乗バイトのメモリを持ち、もしいま使っているノードが全部埋まったら、次のメモリを持つノードのメモリ量は今までのメモリ量を合わせた分になります。</p>

<h2 id="description">Description</h2>

<p>このパターンは、どれぐらいのメモリが必要になるかが事前にわからないときに使えるパターンだそうです。といったら、<code>std::vector&lt;T, A&gt;</code> とはあんまり変わらないじゃないのと思うかもしれないんですが、動的にメモリを管理して、拡張または縮小するのは同じだけれども、具体的には違うそうです。</p>

<p><code>std::vector&lt;T, A&gt;</code> の場合には、メモリが必ず一列になる必要があります。たとえ、あるベクターがあるメモリを持っているとして、もしメモリを拡張しなければならない場合には全体メモリを他のより広いメモリに移す作業を行いますね。しかし、今のパターンはメモリをまた再割当てせずに、新しいインスタンスの確保のためのメモリ空間を割り当てて、リンクリストのポインターに繋げることで拡張を行います。</p>

<p>このパターンでは「メモリブロック」（または空間を指しているポインター）と「メモリブロックに関しての様々な情報」をまとめて「グループ」と言います。情報の中にはダブルリンクリストを構成するための前のメモリノードと後のメモリノードへのポインターが必ず入ります。それ以外に、今ノードが持っているメモリブロックに何個まで入れるか、何個入ったか、Skipfieldなどなどが入りそうです。</p>

<blockquote>
<p>Skipfieldは後の<code>Colony</code>コンテナーを説明するときに説明したいと思います。</p>
</blockquote>

<p>Abstractで書いたように、各ノードは２の二乗バイトのメモリを持ちます。例えば、１番目のブロックが<code>int</code>で8個を持っているとしたら（32Bytes）、次のブロックはまた8個（32Bytes）、そして次々のブロックは1番目と2番目のブロックを足した分の16個（64Bytes）のメモリを持つようにします。で、4番目のブロックは8＋8＋16＝32個が入れるメモリ領域を持つでしょう。</p>

<h2 id="advantages">Advantages</h2>

<p><code>std::vector</code>のような連続メモリとは違って、メモリ領域がリンクリストとして連結していることによって、イテレータとポインターを持っているときに、コンテナーにインスタンスを挿入することでの無効化（Invalidation）が起こらなくなります。</p>

<p>そしてメモリ確保を個別にやってからリンクリストとして連結することで、Resizeなどの関数でよく起こりうるメモリ再確保⇒存在しているインスタンスのコピーまたはムーブコストが発生しなくなります。こうすることで要素（インスタンス）を追加する時の副作用コストが顕著に減ります。（削除する時にもメモリを解除して、リンクリストから除外させれば終わりなんでこれも速いです。）</p>

<p>また、Groupを静的のリストの形として管理したら、Groupのための動的メモリ確保をすることが省きそうなので一部状況ではもっと速く動作すると思われます。</p>

<h2 id="disadvantages">Disadvantages</h2>

<p>メモリ確保がリンクリストとして管理されるので、<code>std::vector</code>のような連続メモリに対してはイテレーターが一回りする速度は遅くなるかもしれません。特に、確保したメモリの実際領域がバラバラになっていたら、キャッシュを改めないとならなくなります。</p>

<p>また、連続メモリでのイテレーターが進むときに、単純にポインターを一つ動くだけとは違って、このパターンのイテレーターは次のメモリを持っているノードに移るべきかを分岐として検証しなければならなくなります。</p>

<p>よって、各メモリの確保数が2の二乗なこともこういった性能落ちを抑制するために意図的に設定した数値だそうです。そして各ノードの持っているメモリが大きすぎないように、各ノードのメモリ確保の限界値を決めることもより速い性能をするために必要だと言ってます。</p>

<h2 id="コード">コード？</h2>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TType</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">DGroup</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">DMeta</span>
    <span class="p">{</span>
        <span class="n">DGroup</span><span class="o">*</span> <span class="n">mpPrev</span><span class="p">;</span>
        <span class="n">DGroup</span><span class="o">*</span> <span class="n">mpNext</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mCnt</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mCap</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">TType</span><span class="o">*</span> <span class="n">mpMem</span><span class="p">;</span>
    <span class="n">DMeta</span>  <span class="n">mMeta</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="p">)</span><span class="o">::</span><span class="n">calloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mpMem</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mpMem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCnt</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">{</span>   <span class="c1">// Create _2.
</span><span class="c1"></span>
        <span class="c1">// We need to calculate next capacity (2^) O(k)
</span><span class="c1"></span>        <span class="kt">unsigned</span> <span class="n">nextCap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">pCur</span> <span class="o">=</span> <span class="n">_1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">pCur</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">nextCap</span> <span class="o">+=</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span>
            <span class="n">pCur</span> <span class="o">=</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="p">)</span><span class="o">::</span><span class="n">calloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mpMem</span>           <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">nextCap</span><span class="p">);</span>
        <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span>      <span class="o">=</span> <span class="n">nextCap</span><span class="p">;</span>
        <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span>    <span class="o">=</span> <span class="n">_2</span><span class="p">;</span>
        <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpPrev</span>    <span class="o">=</span> <span class="n">_1</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mpMem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">nextCap</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">nextCap</span><span class="p">);</span>
            <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCnt</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// DO SOME COMPLEXT THING...
</span><span class="c1"></span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// _2-&gt;mpMem[i - 1].~int();
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="p">{</span>
        <span class="k">auto</span><span class="o">*</span> <span class="n">pDelete</span>       <span class="o">=</span> <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span><span class="p">;</span>
        <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span>    <span class="o">=</span> <span class="n">pDelete</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span><span class="p">;</span>
        <span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">pDelete</span><span class="p">);</span> 
        <span class="n">pDelete</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// _1-&gt;mpMem[i - 1].~int();
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="p">{</span>
        <span class="k">auto</span><span class="o">*</span> <span class="n">pDelete</span>       <span class="o">=</span> <span class="n">_1</span><span class="p">;</span>
        <span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">pDelete</span><span class="p">);</span>
        <span class="n">pDelete</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="最後に">最後に</h2>
]]></content>
		</item>
		
	</channel>
</rss>
