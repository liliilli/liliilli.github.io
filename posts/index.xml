<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on neuromantic</title>
		<link>https://liliilli.github.io/posts/</link>
		<description>Recent content in Posts on neuromantic</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Sat, 25 Apr 2020 13:28:07 +0900</lastBuildDate>
		<atom:link href="https://liliilli.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>DirectInput8 導入メモ</title>
			<link>https://liliilli.github.io/posts/dinput8/</link>
			<pubDate>Sat, 25 Apr 2020 13:28:07 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/dinput8/</guid>
			<description>https://en.wikipedia.org/wiki/DirectInput https://bell0bytes.eu/directinput/ https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416842(v=vs.85)?redirectedfrom=MSDN https://docs.microsoft.com/ko-kr/windows/win32/xinput/xinput-and-directinput?redirectedfrom=MSDN DirectInputとは DirectInputは、キーボード、マウス、そして各種のコントローラーを含んでほぼ同一な挙動制御をサポー</description>
			<content type="html"><![CDATA[

<blockquote>
<p><a href="https://en.wikipedia.org/wiki/DirectInput">https://en.wikipedia.org/wiki/DirectInput</a></p>

<p><a href="https://bell0bytes.eu/directinput/">https://bell0bytes.eu/directinput/</a></p>

<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416842(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416842(v=vs.85)?redirectedfrom=MSDN</a></p>

<p><a href="https://docs.microsoft.com/ko-kr/windows/win32/xinput/xinput-and-directinput?redirectedfrom=MSDN">https://docs.microsoft.com/ko-kr/windows/win32/xinput/xinput-and-directinput?redirectedfrom=MSDN</a></p>
</blockquote>

<h1 id="directinputとは">DirectInputとは</h1>

<p><strong>DirectInput</strong>は、キーボード、マウス、そして各種のコントローラーを含んでほぼ同一な挙動制御をサポートしてくれるAPIを指す。今は<strong>xinput</strong>という新しい（今になっては結構古いAPIだが）APIと一緒に両立しているらしい。</p>

<p>*DirectInput*はもともと<strong>DirectX</strong>のコンポーネントの一つとして提供され、これを使えば以前までコントローラーごとの挙動制御を一つずつ制御しなかったことが相当省かれる。</p>

<p>*DirectInput*は認知したデバイスを3つの種類（キーボード、マウス、そしてコントローラー）として分類する。また、*DirectInput*はデバイスが必ず認識てきる、自分ひとりしか持ってない番号をもたせて認識させるようにする。それを<strong>GUID</strong>という。</p>

<p>よって、認知したデバイスをインスタンス（例えば<code>IDirectInput8Device</code>とか）として返すためには必ず*GUID*を持つ必要があるらしい。ただし、基本接続しているキーボードとマウスデバイスは以下のGUIDを通して探せる。</p>

<ul>
<li><code>GUID_SysKeyboard</code>：基本接続しているキーボードのGUID（マクロっぽい）</li>
<li><code>GUID_SysMouse</code>：基本接続しているマウスのGUID</li>
</ul>

<p>しかし、それ以外のデバイスはAPIで入れられる<strong>コールバック関数</strong>を通して検証する必要がある。また、それを行うためにはDInput8の<strong>メインオブジェクト</strong>をまず取得する必要がある。</p>

<blockquote>
<p>Getting Started with DirectInput</p>

<p>DirectInputを理解する為には、次のような用語を知っておく必要があるらしい。</p>

<ul>
<li>DirectInput Object：メインDirectInputのインタフェース</li>
<li>Device：キーボード、マウス、またコントローラーとなれるすべての入力デバイス</li>
<li>DirectInputDevice Object：Deviceの情報を持つ変数またはそれに準ずるコード</li>
<li>Device Object：DIDOから取得できるキー、ボタン、トリガーなどの構成要素</li>
</ul>
</blockquote>

<p>元記事では以下のようにDirectInput初期化手順を記述している。</p>

<ol>
<li>DirectInput Objectを生成する</li>
<li>GUIDを持つ全てのデバイスを検知し（コールバック関数を用いたクエリー）</li>
<li>適合なデバイスからDirectInput Device Objectを持ってくる。</li>
<li>DIDOのco-operation level、フォーマット、プロパティを設定する</li>
<li>Device Objectを取得する。</li>
<li>デバイスに入力をPollするかReadを行う。</li>
<li>取得したDevice Objectを先に開放し、そしてDirectInput Objectを開放して終わり。</li>
</ol>

<h1 id="大体のやり方">大体のやり方</h1>

<h2 id="1-directinput-objectを生成">1. DirectInput Objectを生成</h2>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416756(v%3dvs.85)">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416756%28v%3dvs.85%29</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">HRESULT</span> <span class="n">DirectInput8Create</span><span class="p">(</span>
         <span class="n">HINSTANCE</span> <span class="n">hinst</span><span class="p">,</span>
         <span class="n">DWORD</span> <span class="n">dwVersion</span><span class="p">,</span>
         <span class="n">REFIID</span> <span class="n">riidltf</span><span class="p">,</span>
         <span class="n">LPVOID</span> <span class="o">*</span> <span class="n">ppvOut</span><span class="p">,</span>
         <span class="n">LPUNKNOWN</span> <span class="n">punkOuter</span>
<span class="p">)</span></code></pre></div>
<p>上の関数の<code>ppvOut</code>に変数のポインターを入れて、<code>IDirectInput8</code>DirectInput Objectを取得する。取得したオブジェクトは一つしか生成しないようにしなければならないし、特別な状況じゃないとアプリケーションが終わるまで開放しないべきである。</p>

<p>また、<code>hinst</code>にはプロセス（アプリケーション）またはDLLのハンドルを入れるべき。普通は<code>GetModuleHandleW(nullptr)</code>でいいかも…</p>

<h2 id="2-guidを持つ全てのデバイスを検知">2. GUIDを持つ全てのデバイスを検知</h2>

<p>DirectInputはシステムが認知しているすべての入力デバイスを巡回し、連結されているかないか、そしてデバイスの情報を取得することが出来るようになっている。このデバイス全体を巡回して情報を要請することを<strong>Enumeration</strong>という。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417804(v%3dvs.85)">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417804%28v%3dvs.85%29</a></p>
</blockquote>

<p>Enumerationを行うためには、先程取得したDirectInput Objectの<code>EnumDevices</code>関数を使う。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">EnumDevices</span><span class="p">(</span>
         <span class="n">DWORD</span> <span class="n">dwDevType</span><span class="p">,</span>
         <span class="n">LPDIENUMDEVICESCALLBACK</span> <span class="n">lpCallback</span><span class="p">,</span>
         <span class="n">LPVOID</span> <span class="n">pvRef</span><span class="p">,</span>
         <span class="n">DWORD</span> <span class="n">dwFlags</span>
<span class="p">)</span>
</code></pre></div>
<p><code>dwDevType</code>は<code>DI8DEVCLASS_</code>列挙型の値を入れて、巡回させるデバイスの種類を縛る。コントローラーだけで縛って検証させるなら<code>DI8DEVCLASS_GAMECTRL</code>だけでいいかも。</p>

<p><code>lpCallback</code>は巡回するデバイスの情報などを取得ためのコールバック関数のポインターを指定する。関数の型は以下のようにしなければならない。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">BOOL</span> <span class="p">(</span><span class="o">*</span><span class="n">LPDIENUMDEVICESCALLBACK</span><span class="p">)(</span><span class="n">LPCDIDEVICEINSTANCE</span> <span class="n">lpddi</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">pvRef</span><span class="p">);</span>
</code></pre></div>
<p><code>pvRef</code>引数はコールバック関数に持っていくことが出来るポインター変数である。<code>lpddi</code>は<code>EnumDevices</code>関数で取得できたデバイスリストのデバイスインスタンスのポインターである。</p>

<p>普通はコールバック関数で、縛ったデバイスインスタンスの情報を検証して<code>pvRef</code>の構造体に情報を入れて使えるように準備をするようにしていればOKかもしれない…</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416610(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416610(v=vs.85)?redirectedfrom=MSDN</a></p>
</blockquote>

<p>コールバック関数で持ってこれる<code>DIDEVICEINSTANCE</code>構造体は以下のようになっている。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">DIDEVICEINSTANCE</span> <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">dwSize</span><span class="p">;</span>
    <span class="n">GUID</span> <span class="n">guidInstance</span><span class="p">;</span>
    <span class="n">GUID</span> <span class="n">guidProduct</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwDevType</span><span class="p">;</span>
    <span class="n">TCHAR</span> <span class="n">tszInstanceName</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
    <span class="n">TCHAR</span> <span class="n">tszProductName</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
    <span class="n">GUID</span> <span class="n">guidFFDriver</span><span class="p">;</span>
    <span class="n">WORD</span> <span class="n">wUsagePage</span><span class="p">;</span>
    <span class="n">WORD</span> <span class="n">wUsage</span><span class="p">;</span>
<span class="p">}</span> <span class="n">DIDEVICEINSTANCE</span><span class="p">,</span> <span class="o">*</span><span class="n">LPDIDEVICEINSTANCE</span><span class="p">;</span>
</code></pre></div>
<p>注意する点は、新しいAPIの<strong>xinput</strong>がデバイスによって同時にサポートされていることがありうるので、<code>guidProduct</code>を使ってxinputを支援しているかを確認しなければならない。</p>

<p>とにかく取得したいデバイスを探したら、<code>CreateDevice</code>関数を使ってDIDOを取得する。</p>

<h2 id="3-適合なデバイスからdirectinput-device-object取得">3. 適合なデバイスからDirectInput Device Object取得</h2>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417803(v%3Dvs.85">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417803(v%3Dvs.85</a>)</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">CreateDevice</span><span class="p">(</span>
         <span class="n">REFGUID</span> <span class="n">rguid</span><span class="p">,</span>
         <span class="n">LPDIRECTINPUTDEVICE</span> <span class="o">*</span> <span class="n">lplpDirectInputDevice</span><span class="p">,</span>
         <span class="n">LPUNKNOWN</span> <span class="n">pUnkOuter</span>
<span class="p">)</span>
</code></pre></div>
<p><code>rguid</code>にGUIDを入れるが、必ずインスタンスのGUIDである必要がある。<code>pUnkOuter</code>はCOM Aggregationのための引数であるため、今は使わない。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// 3. Get DirectInput Device Object pointer.
</span><span class="c1"></span><span class="n">IDirectInputDevice8</span><span class="o">*</span> <span class="n">p_device</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">p_dio</span><span class="o">-&gt;</span><span class="n">CreateDevice</span><span class="p">(</span><span class="n">lpddi</span><span class="o">-&gt;</span><span class="n">guidInstance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p_device</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DI_OK</span><span class="p">)</span>
<span class="p">{</span> 
    <span class="k">return</span> <span class="n">DIENUM_CONTINUE</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>
<h2 id="4-didoのco-operation-level-format-properties設定">4. DIDOのco-operation level、format、properties設定</h2>

<h3 id="co-operation-level">co-operation level</h3>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417921(v%3Dvs.85">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417921(v%3Dvs.85</a>)</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">SetCooperativeLevel</span><span class="p">(</span>
         <span class="n">HWND</span> <span class="n">hwnd</span><span class="p">,</span>
         <span class="n">DWORD</span> <span class="n">dwFlags</span>
<span class="p">)</span>
</code></pre></div>
<p>生成した窓の状態に対し（バックかフォアか、それとも特別な状態を持っているか）、取得したDIDOからのシグナル検知の権限を設定する。</p>

<p>僕の個人プロジェクトでは、表に見える窓だけではなくてバックグラウンドで動く窓もあるため、<code>dwFlags</code>は<code>DISCL_BACKGROUND | DISCL_EXCLUSIVE</code>にする。</p>

<h3 id="data-formats">Data formats</h3>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417925(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417925(v=vs.85)?redirectedfrom=MSDN</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">SetDataFormat</span><span class="p">(</span>
         <span class="n">LPCDIDATAFORMAT</span> <span class="n">lpdf</span>
<span class="p">)</span>
</code></pre></div>
<p>取得したDIDOから、どのようにデータを解釈して取得させるようにするかを設定する。実は<code>DIDATAFORMAT</code>構造体に値を入れてポインターとして入れなければならないか、DINPUTヘッダーファイル自体ですでに決まったものを入れれば良いらしい。</p>

<ul>
<li>c_dfDIKeyboard</li>
<li>c_dfDIMouse</li>
<li>c_dfDIJoystick</li>
<li>c_dfDIJoystick2</li>
</ul>

<blockquote>
<p>&hellip;
ちなみに実はジョイスティックには2種類の入力フォーマットがあり、そのもう1つが<strong>c_dfDIJoystick2</strong>と定義されています。
実際にはボタンやアナログの数が増えただけなので、PS2などの標準コントローラを使う分には特に意味はありませんが、
入力の多いデバイスを使用する場合はこちらの方を使う必要があります。
※<strong>c_dfDIJoystick</strong>と<strong>c_dfDIJoystick2</strong>のどちらを使用しても取得出来る分は取得できます
&hellip;</p>

<p>from : <a href="http://www.charatsoft.com/develop/otogema/page/07input/joystick.html">http://www.charatsoft.com/develop/otogema/page/07input/joystick.html</a></p>
</blockquote>

<p>データフォーマットを入れたら、後でデバイスのキー状態などを取得する際には入れた値にあっている構造体を入れなければならない。例えば、<code>c_dfDIJoystick</code>を入れた時には<code>DIJOYSTATAE</code>を使う。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416627(v%3Dvs.85">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416627(v%3Dvs.85</a>)</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">DIJOYSTATE</span> <span class="p">{</span>
    <span class="n">LONG</span> <span class="n">lX</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">lY</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">lZ</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">lRx</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">lRy</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">lRz</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">rglSlider</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">DWORD</span> <span class="n">rgdwPOV</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="n">BYTE</span> <span class="n">rgbButtons</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">}</span> <span class="n">DIJOYSTATE</span><span class="p">,</span> <span class="o">*</span><span class="n">LPDIJOYSTATE</span><span class="p">;</span>
</code></pre></div>
<h3 id="properties">Properties</h3>

<p>普通のゲームコントローラーって、デジタルのボタンなどを除くと、Lスティック、Rスティックそしてタッチパネルまたは特殊トリガーのような<strong>アナログ</strong>数値を持つ要素が残る。コントローラーごとにこのスティックなどの読み取り値が違うかもしれないので、それを一つの範囲などに合わせなければならない。その設定を<code>GetCapabilities</code>と<code>SetProperty</code>で設定することが出来るらしい。</p>

<p>まず、<code>GetCapabilities</code>と<code>DIDIVCAPS</code>構造体でDIDOのDevice Object情報を取得する必要がある。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417892(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417892(v=vs.85)?redirectedfrom=MSDN</a></p>

<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416607(v%3dvs.85)">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416607%28v%3dvs.85%29</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="nf">GetCapabilities</span><span class="p">(</span><span class="n">LPDIDEVCAPS</span> <span class="n">lpDIDevCaps</span><span class="p">)</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">DIDEVCAPS</span> <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">dwSize</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwFlags</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwDevType</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwAxes</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwButtons</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwPOVs</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwFFSamplePeriod</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwFFMinTimeResolution</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwFirmwareRevision</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwHardwareRevision</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwFFDriverVersion</span><span class="p">;</span>
<span class="p">}</span> <span class="n">DIDEVCAPS</span><span class="p">,</span> <span class="o">*</span><span class="n">LPDIDEVCAPS</span><span class="p">;</span>
</code></pre></div>
<p>そしてプロパティーを設定するなら、<code>SetProperty</code>を使う。ただし、設定したいプロパティーによって記述する構造体がそれぞれ違う。例えばスティック軸の数値の範囲を決めたい場合には下のコードのようにしなければならない。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416638(v%3dvs.85)">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416638%28v%3dvs.85%29</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">DIPROPHEADER</span> <span class="n">header</span><span class="p">;</span>
<span class="n">header</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DIPROPRANGE</span><span class="p">);</span>
<span class="n">header</span><span class="p">.</span><span class="n">dwHeaderSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DIPROPHEADER</span><span class="p">);</span>
<span class="n">header</span><span class="p">.</span><span class="n">dwObj</span> <span class="o">=</span> <span class="o">???</span><span class="p">;</span>
<span class="n">header</span><span class="p">.</span><span class="n">dwHow</span> <span class="o">=</span> <span class="o">???</span><span class="p">;</span>

<span class="n">DIPROPRANGE</span> <span class="n">range</span><span class="p">;</span>
<span class="n">range</span><span class="p">.</span><span class="n">diph</span> <span class="o">=</span> <span class="n">header</span><span class="p">;</span>
<span class="n">range</span><span class="p">.</span><span class="n">lMin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span><span class="p">;</span>
<span class="n">range</span><span class="p">.</span><span class="n">lMax</span> <span class="o">=</span> <span class="o">+</span><span class="mi">100</span><span class="p">;</span>

<span class="n">gameController</span><span class="o">-&gt;</span><span class="n">SetProperty</span><span class="p">(</span><span class="n">DIPROP_RANGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">range</span><span class="p">.</span><span class="n">header</span><span class="p">);</span>
</code></pre></div>
<p>注目すべき所は、<code>DIPROPHEADER</code>構造体の<code>dwObj</code>と<code>dwHow</code>である。公式の説明ページを見ればわかるかもしれないが、<code>dwHow</code>にはデバイスではなく、DIDOの中にある軸、ボタンなどのインスタンスを指すための<code>DIPH_BYID</code>を入れなければならない。</p>

<p>ただし、<code>DIPH_BYID</code>を入れたら、<code>dwObj</code>には<code>EnumObjects</code>関数で呼び出しするコールバック関数の中で取得できるインスタンスのIDを<code>dwObj</code>に入れなければならなくなる。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417889(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417889(v=vs.85)?redirectedfrom=MSDN</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">EnumObjects</span><span class="p">(</span>
         <span class="n">LPDIENUMDEVICEOBJECTSCALLBACK</span> <span class="n">lpCallback</span><span class="p">,</span>
         <span class="n">LPVOID</span> <span class="n">pvRef</span><span class="p">,</span>
         <span class="n">DWORD</span> <span class="n">dwFlags</span>
<span class="p">)</span>
  
<span class="c1">// Callback function pointer type
</span><span class="c1"></span><span class="n">BOOL</span> <span class="p">(</span><span class="o">*</span><span class="n">LPDIENUMDEVICEOBJECTSCALLBACK</span><span class="p">)(</span><span class="n">LPCDIDEVICEOBJECTINSTANCE</span> <span class="n">lpddoi</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">pvRef</span><span class="p">)</span>
</code></pre></div>
<p>書き方は上の<code>EnumDevices</code>と同じだが、<code>dwFlags</code>のフラグ値とコールバック関数の中での<code>SetProperty</code>コールに使われる構造体がよく合っていなければならない。（かもしれない）</p>

<p>ということで手順をまとめると、</p>

<ol>
<li><code>IDirectInputDevice8</code>のDIDOを取得し、</li>
<li><code>EnumObjects</code>関数で調べたいインスタンスの縛ってイテレーションさせ、</li>
<li>その中で適切なインスタンスがあったら<code>DIPROPHEADER</code>の入っている適切な構造体を記述して</li>
<li><code>SetProperty</code>でインスタンスに設定をする。</li>
</ol>

<p>アナログスティックの場合には、<strong>デッドゾーン（Deadzone)</strong>っていうのがあって、スティックを動かさないと必ず中立（0）の数値になるのではなく0に違い数値を表す時があって、それに対する誤動作を防ぐための判定範囲を設けなければならない。</p>

<p>アナログスティックなどのデッドゾーンを決めるには<code>DIPROPWORD</code>と<code>DIPROP_DEADZONE</code>を使う。ここで中止することは、デッドゾーンの数値は固定された0~10000までの範囲から決めなかればならない。例えばスティック入力の1%以内をデッドゾーンとして決めたいなら、100を入れる。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416636(v%3dvs.85)">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416636%28v%3dvs.85%29</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">DIPROPDWORD</span> <span class="p">{</span>
    <span class="n">DIPROPHEADER</span> <span class="n">diph</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwData</span><span class="p">;</span>
<span class="p">}</span> <span class="n">DIPROPDWORD</span><span class="p">,</span> <span class="o">*</span><span class="n">LPDIPROPDWORD</span><span class="p">;</span>
</code></pre></div>
<p>ちなみに元記事ではRANGEとWORDを同時に設定している。</p>

<h2 id="5-device-objectを取得-acquire">5. Device Objectを取得(Acquire)</h2>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417818(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417818(v=vs.85)?redirectedfrom=MSDN</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">Acquire</span><span class="p">()</span>
</code></pre></div>
<p>設定した入力デバイスに接近する権限を得る。アプリケーションを終了したり、それとも使っているコントローラーのアクセス権限を返却する場合には</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417931(v=vs.85">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417931(v=vs.85</a>)</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">Unacquire</span><span class="p">()</span>
<span class="c1">// and
</span><span class="c1"></span><span class="n">HRESULT</span> <span class="n">Release</span><span class="p">()</span>
</code></pre></div>
<p>を使う。（Releaseを連続で呼び出すのは、CreateDeviceで参照カウントが１増加されたから）</p>

<h2 id="6-デバイスの入力をpollするかreadを行う">6. デバイスの入力をPollするかReadを行う</h2>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417913(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417913(v=vs.85)?redirectedfrom=MSDN</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">Poll</span><span class="p">()</span>
</code></pre></div>
<p>取得したデバイスによって違われるかもしれないが、大体は<code>Poll()</code>関数でデバイスか入力情報を取得しなおさなければならない。あるデバイスは自分からインターラプト（Interrupt）をかけて入力データを取得するようにするものもあるが、そのデバイスに限っては<code>Poll()</code>を呼び出す必要はない（読んだとしてもエラーにはならない）</p>

<p>もしかして<code>Poll</code>関数を呼ぶ必要があるかを確かめる為には、<code>GetCapabilities()</code>関数で<code>DIDEVCAPS</code>の<code>DIDC_POLLEDDATAFORMAT</code>を確認すれば良いらしい。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417897(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417897(v=vs.85)?redirectedfrom=MSDN</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">GetDeviceState</span><span class="p">(</span>
         <span class="n">DWORD</span> <span class="n">cbData</span><span class="p">,</span>
         <span class="n">LPVOID</span> <span class="n">lpvData</span>
<span class="p">)</span>
</code></pre></div>
<p>デバイスで更新された情報を持ってくるためには上の関数を使う。ただし、この関数を使うには<code>lpvData</code>は前にDIDOのデータフォーマット（DataFormat）を設定した時の値に対応している構造体を入れなければならない。</p>

<table>
<thead>
<tr>
<th>Data Format</th>
<th>State Structure</th>
</tr>
</thead>

<tbody>
<tr>
<td>c_dfDIMouse</td>
<td><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416630(v%3dvs.85)">DIMOUSESTATE</a></td>
</tr>

<tr>
<td>c_dfDIMouse2</td>
<td><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416631(v%3dvs.85)">DIMOUSESTATE2</a></td>
</tr>

<tr>
<td>c_dfDIKeyboard</td>
<td>array of 256 bytes</td>
</tr>

<tr>
<td>c_dfDIJoystick</td>
<td><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416627(v%3dvs.85)"> DIJOYSTATE</a></td>
</tr>

<tr>
<td>c_dfDIJoystick2</td>
<td><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416628(v%3dvs.85)">DIJOYSTATE2</a></td>
</tr>
</tbody>
</table>

<h2 id="7-directinput-objectを開放して終わり">7. DirectInput Objectを開放して終わり</h2>

<p>「5. Device Objectを取得(Acquire)」を見ること。</p>
]]></content>
		</item>
		
		<item>
			<title>TLSF Allocatorを作ってみた</title>
			<link>https://liliilli.github.io/posts/tlsf_basic/</link>
			<pubDate>Sun, 15 Mar 2020 19:13:14 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/tlsf_basic/</guid>
			<description>TLSFとは何なのか http://www.gii.upv.es/tlsf/ http://www.gii.upv.es/tlsf/files/ecrts04_tlsf.pdf https://www.researchgate.net/publication/234785757_A_comparison_of_memory_allocators_for_real-time_applications TLSF（Two-Level Segregate Fit）は、リアルタイムで要求される速度、安定性、決定性（Deterministic</description>
			<content type="html"><![CDATA[

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<h1 id="tlsfとは何なのか">TLSFとは何なのか</h1>

<blockquote>
<p><a href="http://www.gii.upv.es/tlsf/">http://www.gii.upv.es/tlsf/</a><br>
<a href="http://www.gii.upv.es/tlsf/files/ecrts04_tlsf.pdf">http://www.gii.upv.es/tlsf/files/ecrts04_tlsf.pdf</a><br>
<a href="https://www.researchgate.net/publication/234785757_A_comparison_of_memory_allocators_for_real-time_applications">https://www.researchgate.net/publication/234785757_A_comparison_of_memory_allocators_for_real-time_applications</a></p>
</blockquote>

<p>TLSF（Two-Level Segregate Fit）は、リアルタイムで要求される速度、安定性、決定性（Deterministic）を重視としたメモリ割当のアルゴリズム、そしてそれを実装したメモリアロケータを示します。普通のかんたんなメモリプール（Pool）とは違って、割当をしたいサイズを入れればその分のメモリを割り当ててくれる汎用性も持ちます。</p>

<p>普通に<code>malloc</code>とか<code>free</code>とかすれば良いんじゃね？と思う方もいると思いますが、メモリが十分なら普通にシステムコールをして構わないと思います。しかし、組み込み系とかビデオゲーム機の中に仕込まれた限定的なメモリを十分活用しくちゃという状況なら<code>malloc</code>とか<code>free</code>だけでは内部メモリのフラグメンテーションを抑えることは出来ません。</p>

<p>（OS自体でメモリの管理を行ってフラグメンテーションを抑えることは出来ると思いますが、厳密にはAPP側でもそれを制御したいですね）</p>

<p>なんでそのフラグメンテーションを抑えながらも速度を保つためにいろんなDMA（Dynamic Memory Allocator（動的メモリ確保））アルゴリズムが出ました。その中で一つのアルゴリズムがTLSFです。</p>

<p>TLSFは以下の特徴を持つそうです。</p>

<ul>
<li>メモリの確保、解除などに最悪<code>O(1)</code>の処理時間を持つ。</li>
<li>x86アーキテクチャで最悪168個のアセンブリコードを持つため、比較的速い。</li>
<li>平均15~25％のフラグメンテーション性能向上している。</li>
<li>リアルタイム条件のプログラムなでど使える。</li>
<li>確保したメモリの領域を拡張・縮小することが出来る。（この記事ではこれの実装は扱いません）</li>
</ul>

<h1 id="tlsfの概略な構造">TLSFの概略な構造</h1>

<blockquote>
<p><a href="http://www.gii.upv.es/tlsf/files/papers/tlsf_desc.pdf">http://www.gii.upv.es/tlsf/files/papers/tlsf_desc.pdf</a></p>
</blockquote>

<p>上の説明文をお読みください。</p>

<h1 id="なんでtlsfを実装しようとしたの">なんでTLSFを実装しようとしたの</h1>

<p>いくつかのゲームエンジンの中で、メモリを制御するために実装されているのがTLSFだったからです。それにOSでも使ってるらしいし、インターネットで一番明確ながらもソースコードも公開がされ、勉強になりそうなアルゴリズム（ライブラリー）だったので、まずTLSFから始めようとして実装することになりました。</p>

<p>また、TLSF自体はソースが公開されてはいるんですが、ライセンスがGPLまたはLPGLであるため自分の作っているプロジェクトに取り入れることが難しかったです。なので勉強兼ねて新しく実装し、それを個人プロジェクトに入れようとしたいこともあります。</p>

<h1 id="ソースコード">ソースコード</h1>

<blockquote>
<p><a href="https://gist.github.com/liliilli/01d0a8505dcc3fe4f5c951fbc179c769">https://gist.github.com/liliilli/01d0a8505dcc3fe4f5c951fbc179c769</a></p>
</blockquote>

<p>説明する前に、まずコードを見せたいと思います。</p>

<p>TSLF関数の全体を説明するのではなく、一部だけを取って説明したいですので、全体のフローはソースコードを見てください。</p>

<h1 id="基本apiリスト">基本APIリスト</h1>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//! @brief Create tlsf pool.
</span><span class="c1">//! @param pool_size Overall memory pool size.
</span><span class="c1">//! @param p_pool Memory pool pointer to start.
</span><span class="c1">//! @return If successful, return available memory size of pool.
</span><span class="c1">//!     If failed, return one of error codes below.
</span><span class="c1">//!     * ADDRESS_IS_NULL : given p_pool is nullptr.
</span><span class="c1">//!     * SIZE_IS_ZERO : pool_size is 0.
</span><span class="c1">//!     * NOT_SUFFICIENT_MEM_SIZE : pool_size is not sufficient to create tlsf allocator.
</span><span class="c1">//!     * NOT_ALIGNED_ADDRESS : p_pool is not aligned.
</span><span class="c1"></span><span class="n">u64</span> <span class="nf">tlsf_raw_create</span><span class="p">(</span><span class="n">u64</span> <span class="n">pool_size</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">p_pool</span><span class="p">)</span> <span class="n">DY_NOEXCEPT</span><span class="p">;</span>

<span class="c1">//! @brief Destroy tlsf memory pool trivially.
</span><span class="c1">//!     This function does not check tlsf has a valid object.
</span><span class="c1">//! @param p_pool Valid tlsf memory pool pointer.
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">tlsf_raw_destroy</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p_pool</span><span class="p">)</span> <span class="n">DY_NOEXCEPT</span><span class="p">;</span>

<span class="c1">//! @brief Check if tlsf memory pool can be destroyed safely.
</span><span class="c1">//!     This function checks tlsf has valid and every objects are released.
</span><span class="c1">//! @param p_pool valid tlsf memory pool pointer.
</span><span class="c1"></span><span class="kt">bool</span> <span class="nf">tlsf_can_destroy</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p_pool</span><span class="p">)</span> <span class="n">DY_NOEXCEPT</span><span class="p">;</span>

<span class="c1">//! @brief Try allocate memory with given mem_size.
</span><span class="c1">//!     Created memory block may not have same mem_size size value, but aligned memory size.
</span><span class="c1">//!     This function only should be used POD types. (trivial or standard_layout type)
</span><span class="c1">//! @param mem_size Minimum memory size to allocate.
</span><span class="c1">//! @param p_tlsf Tlsf pool pointer.
</span><span class="c1">//! @return If successful, return buffer pointer. Otherwise, return nullptr.
</span><span class="c1"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">tlsf_malloc</span><span class="p">(</span><span class="n">u64</span> <span class="n">mem_size</span><span class="p">,</span> <span class="n">tlsf_raw_t</span><span class="o">*</span> <span class="n">p_tlsf</span><span class="p">)</span> <span class="n">DY_NOEXCEPT</span><span class="p">;</span>

<span class="c1">//! @brief Try reallocate valid memory trivially.
</span><span class="c1">//!     Reallocated memory block may not have same mem_size size value, but aligned memory size.
</span><span class="c1">//!     This function only must be used POD types. (trivial or standard_layout type)
</span><span class="c1">//! @param p_data Valid data pointer. This pointer should be in given p_tlsf pool.
</span><span class="c1">//! @param mem_size Minimum memory size to reallocate.
</span><span class="c1">//! @param p_tlsf Tlsf pool pointer.
</span><span class="c1">//! @return If successful, return reallocated buffer pointer.
</span><span class="c1">//!     Otherwise, return nullptr.
</span><span class="c1"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">tlsf_realloc</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p_data</span><span class="p">,</span> <span class="n">u64</span> <span class="n">new_size</span><span class="p">,</span> <span class="n">tlsf_raw_t</span><span class="o">*</span> <span class="n">p_tlsf</span><span class="p">)</span> <span class="n">DY_NOEXCEPT</span><span class="p">;</span>

<span class="c1">//! @brief Try calloc memory trivially.
</span><span class="c1">//!     Created memory block may not have same mem_size size value, but aligned memory size.
</span><span class="c1">//!     This function only should be used POD types. (trivial or standard_layout type)
</span><span class="c1">//!     Created memory will be initialized with 0 (i32)
</span><span class="c1">//! @param mem_size Minimum memory size to allocate.
</span><span class="c1">//! @param elem_cnt The count of element list to allocate.
</span><span class="c1">//! @param p_tlsf Tlsf pool pointer.
</span><span class="c1">//!
</span><span class="c1">//! @return If successful, return buffer pointer. Otherwise, return nullptr.
</span><span class="c1"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">tlsf_calloc</span><span class="p">(</span><span class="n">u64</span> <span class="n">mem_size</span><span class="p">,</span> <span class="n">u64</span> <span class="n">elem_cnt</span><span class="p">,</span> <span class="n">tlsf_raw_t</span><span class="o">*</span> <span class="n">p_tlsf</span><span class="p">)</span> <span class="n">DY_NOEXCEPT</span><span class="p">;</span>

<span class="c1">//! @brief Free valid memory trivially.
</span><span class="c1">//!     This function only should be called when p_data is POD type. (trivial or standard_layout)
</span><span class="c1">//! @param p_data Valid data pointer.
</span><span class="c1">//! @param p_tlsf_pool Tlsf pool pointer.
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">tlsf_free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p_data</span><span class="p">,</span> <span class="n">tlsf_raw_t</span><span class="o">*</span> <span class="n">p_tlsf_pool</span><span class="p">)</span> <span class="n">DY_NOEXCEPT</span><span class="p">;</span>
</code></pre></div>
<ul>
<li><code>tlsf_raw_create</code>：確保したメモリ領域にTLSFプールを作ろうとします。<br>TLSF自体は確保されたオブジェクトのメモリ領域を管理するために、ちょっと大きいヘッダー構造体が入れるので、メモリ数値がそれの大きさ以上にならないとTLSFプールの生成は失敗になります。</li>
<li><code>tlsf_raw_destroy</code>：有効なTLSFプールを解除します。ただし、この関数はオブジェクトの確保されたメモリは解除してくれないため、この関数を呼ぶ前に<code>tlsf_can_destroy</code>でTLSFプールが解除できるかを確認することが必要です。</li>
<li><code>tlsf_can_destroy</code>：有効なTLSFプールが解除できるかを問います。TLSFプールのメモリ管理をするTLSFヘッダー構造体は、プールで確保または解除が行われるたびにいくらのメモリ数値が変動されたかを覚えます。その数値が<code>0</code>かではないかを検査してプールが最終的に解除できるかを判断します。</li>
<li><code>tlsf_malloc</code>：TLSFプールに対しmalloc（メモリ確保）をやってくれます。もし確保されたプールで入れられるメモリブロックがなければ、確保失敗で<code>nullptr</code>が返されます。また注意する点は、メモリが成功的に確保されるとき、必ずしも<code>mem_size</code>サイズだけが確保されるわけではないです。TLSF自体は出来る限り8Byteまたは16Byte桁アドレスに合わせようとするので、実際に確保されるメモリも当然8または16バイトに合わせようとします。</li>
<li><code>tlsf_realloc</code>：同一TLSFプールから確保したメモリを再確保（realloc）します。TLSFプールのフラグメンテーションによって別の領域で再確保を行うか、それともメモリを拡張するだけで収めれるか分かれることがあります。また、再確保するメモリサイズに比べてプールの現状確保出来るメモリ量が足りなかったら、再確保は失敗します。</li>
<li><code>tlsf_calloc</code>：Cライブラリーの<code>calloc</code>と一緒です。メモリ確保が成功したら、メモリ空間を0で初期化してくれます。</li>
<li><code>tlsf_free</code>：TLSFメモリプールから確保したメモリを解除します。</li>
</ul>

<h1 id="説明">説明</h1>

<h2 id="1-tlsf-raw-create">1.<code>tlsf_raw_create</code></h2>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="n">mem_pool_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tlsf_raw_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">block_header_t</span><span class="o">::</span><span class="n">sk_block_header_ovhd</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">error_info</span><span class="p">{</span> <span class="n">NOT_SUFFICIENT_MEM_SIZE</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div>
<p>確保しようとするTLSFメモリプールのサイズが一定値以上かをチェックします。<code>tlsf_raw_t</code>はTLSFメモリプールを管理する構造体です。<code>block_header_t</code>は確保されるオブジェクトのメモリ空間の前に出てくるヘッダーです。現在オブジェクトのメモリサイズがいくらか、前、次のメモリブロックはどこに位置しているかについて情報を持ちます。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">tlsf_raw_t</span> <span class="k">final</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">u64</span> <span class="n">k_fli_max</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">u64</span> <span class="n">k_fli_offset</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">u64</span> <span class="n">k_fli_real</span> <span class="o">=</span> <span class="n">k_fli_max</span> <span class="o">-</span> <span class="n">k_fli_offset</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">u64</span> <span class="n">k_sli_log2_max</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">u64</span> <span class="n">k_sli_max</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">k_sli_log2_max</span><span class="p">;</span>

    <span class="n">u32</span>             <span class="n">m_tlsf_signature</span><span class="p">;</span>
    <span class="n">area_info_t</span><span class="o">*</span>    <span class="n">m_area_head</span><span class="p">;</span>
    <span class="n">u32</span>             <span class="n">m_fl_bitmap</span><span class="p">;</span>
    <span class="n">u32</span>             <span class="n">m_sl_bitmap</span><span class="p">[</span><span class="n">k_fli_real</span><span class="p">];</span>
    <span class="n">block_header_t</span><span class="o">*</span> <span class="n">mp_matrix</span><span class="p">[</span><span class="n">k_fli_real</span><span class="p">][</span><span class="n">k_sli_max</span><span class="p">];</span>
    <span class="n">u64</span>             <span class="n">m_max_mem</span><span class="p">;</span> <span class="c1">// いらなくて良し
</span><span class="c1"></span>    <span class="n">u64</span>             <span class="n">m_used_mem</span><span class="p">;</span>

    <span class="c1">// 以下メンバー関数宣言
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>
<p><code>tlsf_raw_t</code>で注目する変数は、<code>m_fl_bitmap</code>と<code>m_sl_bitmap</code>、そして<code>mp_matrix</code>です。</p>

<p><code>fl_bitmap</code>と<code>sl_bitmap</code>はメモリ解除されて使えるブロックのハッシュ情報をビット単位で刻んで入れられるようになった変数らしいです。TLSFはメモリの要求される容量によって２階層のリストから適度な空きブロックへのポインターを持ってこれるようになってるので、この変数でFirst-IndexとSecond-Indexを取得するようになってます。この変数を用いた取得のやり方は<code>find_suitable_block</code>関数で見れます。</p>

<p><code>mp_matrix</code>はメモリ解除されたメモリブロックのポインター先を持ちます。<code>find_suitable_block</code>の中で返されたFirst-IndexとSecond-Index数値でこの配列変数から割当をするブロックのヘッダーを取得します。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">block_header_t</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">u64</span> <span class="n">sk_min_block_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">free_ptr_t</span><span class="p">);</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">u64</span> <span class="n">sk_block_header_ovhd</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">u8</span> <span class="n">sk_free_block</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">u8</span> <span class="n">sk_prev_free</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">;</span>

    <span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_prev_header</span><span class="p">;</span>
    <span class="n">u64</span>             <span class="n">stored_size</span><span class="p">;</span>
    <span class="k">union</span>
    <span class="p">{</span>
        <span class="n">free_ptr_t</span>      <span class="n">free_ptr</span><span class="p">;</span>
        <span class="n">block_buffer_t</span>  <span class="n">buffer</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">ptr</span><span class="p">;</span>
  
    <span class="c1">// 以下メンバー関数宣言
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>
<p><code>block_header_t</code>は確保された（または解除した後の）メモリブロックについての情報を持ちます。実際のデータバッファは<code>ptr.buffer</code>から始まり、<code>stored_size &gt;&gt; 2</code>バイトまで続きます。もしブロックが解除した状態なら<code>ptr</code>は<code>free_ptr</code>に前と後のブロックヘッダー情報を入れるようになっています。</p>

<p>また、<code>stored_size</code>はデータバッファのサイズだけではなく、0番と1番のビットに自分がフリーブロックなのか、そして前のブロックがフリーかをフラグとして設定するようにしています。なので、TLSFの中で確保されたデータバッファのサイズは必ず4倍の数値になります。（こうしてキャッシュラインなどが整頓される効果も得られます。）</p>

<p><code>tlsf_raw_create</code>関数にまた戻ってTLSFシグニチャーを設定し、<code>memset</code>で0に初期化を行います。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_area_info_bhdr</span> <span class="o">=</span> <span class="n">process_area</span><span class="p">(</span>
    <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">get_first_block_header</span><span class="p">(),</span> 
    <span class="n">get_rddn_size_default</span><span class="p">(</span><span class="n">mem_pool_size</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tlsf_raw_t</span><span class="p">))</span>
<span class="p">);</span>
<span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_area_head</span> <span class="o">=</span> <span class="p">(</span><span class="n">area_info_t</span><span class="o">*</span><span class="p">)</span><span class="n">p_area_info_bhdr</span><span class="o">-&gt;</span><span class="n">get_buffer</span><span class="p">();</span>
<span class="c1">// make first block of tlsf pool.
</span><span class="c1"></span><span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_first_bhdr</span> <span class="o">=</span> <span class="n">p_area_info_bhdr</span><span class="o">-&gt;</span><span class="n">get_next_block</span><span class="p">();</span>
<span class="n">tlsf_free</span><span class="p">(</span><span class="n">p_first_bhdr</span><span class="o">-&gt;</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">p_tlsf</span><span class="p">);</span>
</code></pre></div>
<p>TLSFメモリプールは普通のメモリプールとは違って扱うメモリ空間自体を拡張することが出来ます。ただし、拡張した別途のメモリ領域のアドレスは既存のTLSFと連続してない可能性があるので、リンクリスト（連結リスト）でアドレスを保持する必要があります。</p>

<p>そのため、<code>tlsf_raw_t</code>の後には追加メモリ領域が保持するブロックのアドレス情報を持つ構造体、<code>area_info_t</code>がついて来ます。（ただし、<code>area_info_t</code>自体も特殊ブロックのバッファ部分に置かれるようになっています。）</p>

<h3 id="process-area"><code>process_area()</code></h3>

<p><code>process_area()</code>関数は、TLSFプールの初期メモリブロックを設定する関数です。初期で設定されるメモリブロックは以下となります。</p>

<ul>
<li><code>p_ib</code>：<code>area_info_t</code>のブロック：別途のメモリ領域を使えるようにする。</li>
<li><code>p_next_b</code>：任意オブジェクトメモリ確保のためのブロック</li>
<li><code>p_next_next_b</code>：メモリ領域の終わりを示すブロック（バッファのサイズは0）</li>
</ul>

<p><code>p_next_b</code>のバッファサイズを初期化するとき、または<code>p_ib</code>のバッファサイズを設定する時には必ずメモリが整列されなければならないため、<code>get_rddn_size_default()</code>と<code>get_rddn_size_default()</code>関数を使ってメモリサイズを調整します。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_next_b</span> <span class="o">=</span> <span class="n">p_ib</span><span class="o">-&gt;</span><span class="n">get_next_block</span><span class="p">();</span>
<span class="n">p_next_b</span><span class="o">-&gt;</span><span class="n">set_buffer_size</span><span class="p">(</span><span class="n">get_rddn_size_default</span><span class="p">(</span>
    <span class="n">size</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">block_header_t</span><span class="o">::</span><span class="n">sk_min_block_size</span> <span class="o">-</span> <span class="n">p_ib</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">())</span>
<span class="p">);</span>
</code></pre></div>
<p><code>size - 3 * block_header_t::sk_min_block_size - p_ib-&gt;get_block_size()</code>は、まずTLSF構造体を除外したメモリサイズに３つのブロックヘッダーサイズと、<code>area_info_t</code>分のメモリサイズを引いた、TLSFプールが生成された後で使えるメモリ量を示します。</p>

<hr />

<p>本関数に戻って、</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"> <span class="c1">// make first block of tlsf pool.
</span><span class="c1"></span> <span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_first_bhdr</span> <span class="o">=</span> <span class="n">p_area_info_bhdr</span><span class="o">-&gt;</span><span class="n">get_next_block</span><span class="p">();</span>
 <span class="n">tlsf_free</span><span class="p">(</span><span class="n">p_first_bhdr</span><span class="o">-&gt;</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">p_tlsf</span><span class="p">);</span>
</code></pre></div>
<p><code>p_next_b</code>部分のブロックがまだ使える状態ではないので、TLSFを管理する構造体の<code>bitmap</code>変数と<code>matrix</code>にアドレスをフラグを更新して使えるため<code>free</code>関数を呼びます。最後には<code>p_next_b</code>の使えるメモリ量を返して終わりです。</p>

<h2 id="2-tlsf-malloc">2.<code>tlsf_malloc</code></h2>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">mem_size</span> <span class="o">=</span> <span class="n">calc_min_memblock_size</span><span class="p">(</span><span class="n">mem_size</span><span class="p">);</span>
<span class="k">const</span> <span class="k">auto</span> <span class="n">rs_search</span>   <span class="o">=</span> <span class="n">mapping_search</span><span class="p">(</span><span class="n">mem_size</span><span class="p">);</span>
<span class="k">const</span> <span class="k">auto</span> <span class="n">rs_suitable</span> <span class="o">=</span> <span class="n">find_suitable_block</span><span class="p">(</span><span class="n">p_tlsf_pool</span><span class="p">,</span> <span class="n">rs_search</span><span class="p">.</span><span class="n">flv</span><span class="p">,</span> <span class="n">rs_search</span><span class="p">.</span><span class="n">slv</span><span class="p">);</span>

<span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_b</span> <span class="o">=</span> <span class="n">rs_suitable</span><span class="p">.</span><span class="n">p_block_hdr</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">rs_suitable</span><span class="p">.</span><span class="n">flv</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">rs_suitable</span><span class="p">.</span><span class="n">slv</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>
<p>まず、TLSFプールから適当なメモリブロックを探します。一次に<code>mapping_search</code>関数で、First-IndexとSecond-Indexを取得し、最終に<code>find_suitable_block</code>で取得出来たブロックヘッダーのポインターと最終First-Index、Second-Indexを持ってくるようにします。</p>

<h3 id="mapping-search"><code>mapping_search()</code></h3>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">const</span> <span class="k">auto</span> <span class="n">fl_sl</span> <span class="o">=</span> <span class="n">mapping_insert</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="n">result</span><span class="p">.</span><span class="n">flv</span> <span class="o">=</span> <span class="n">fl_sl</span><span class="p">.</span><span class="n">first_lv</span><span class="p">;</span>
<span class="n">result</span><span class="p">.</span><span class="n">slv</span> <span class="o">=</span> <span class="n">fl_sl</span><span class="p">.</span><span class="n">scnd_lv</span><span class="p">;</span>
</code></pre></div>
<p>まず<code>mapping_insert()</code>という関数を使って、First-Level Index（<code>flv</code>）とSecond-Level Index（<code>slv</code>）を取得します。</p>

<h3 id="mapping-insert"><code>mapping_insert()</code></h3>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">k_small_block</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">result</span><span class="p">.</span><span class="n">first_lv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">scnd_lv</span>  <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="p">(</span><span class="n">k_small_block</span> <span class="o">/</span> <span class="n">tlsf_raw_t</span><span class="o">::</span><span class="n">k_sli_max</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="n">result</span><span class="p">.</span><span class="n">first_lv</span> <span class="o">=</span> <span class="n">ms_bit</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="n">result</span><span class="p">.</span><span class="n">scnd_lv</span>  <span class="o">=</span> 
        <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">first_lv</span> <span class="o">-</span> <span class="n">tlsf_raw_t</span><span class="o">::</span><span class="n">k_sli_log2_max</span><span class="p">))</span> 
      <span class="o">-</span> <span class="n">tlsf_raw_t</span><span class="o">::</span><span class="n">k_sli_max</span><span class="p">;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">first_lv</span> <span class="o">-=</span> <span class="n">tlsf_raw_t</span><span class="o">::</span><span class="n">k_fli_offset</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>この関数でFirst-Level IndexとSecond-Level Indexを持ってきます。ところで、ここで<code>size</code>は8Byte整列されたサイズです。そして定数は以下となります。</p>

<ul>
<li>k_small_block：128Byte</li>
<li>tlsf_raw_t::k_sli_max：32</li>
<li>tlsf_raw_t::k_sli_log2_max：5</li>
<li>tlsf_raw_t::k_fli_offset：6（2^6 == 128Bytes）</li>
</ul>

<p>まず、<code>size</code>が128Byte以下になると、TLSFプールで提供されてるメモリブロックの中で一番小さいものが確保されるようになります。しかし、それ以上になるともっと適切なFLIとSLIの数値を持って来るため、下のようなアルゴリズムを通します。
$$
\begin{align}
\text{mapping}(\text{size}) &amp;\rightarrow (f, s) \\<br />
\text{mapping}(\text{size}) &amp;=
\begin{cases}
f := \lfloor log_2(size) \rfloor \\<br />
s := size * \frac{2^{SLI}}{2^f} - 2^{SLI}
\end{cases}
\end{align}
$$
真ん中の<code>result.first_lv - tlsf_raw_t::k_sli_log2_max</code>は以下となります。
$$
\alpha = log_2(2^{f - SLI})
$$
上の関数では128Byte以下のブロックは全部FLIが0になるし、128Byte以上から1以上のインデックスを持つため、6を引く必要があります。最後に<code>first_lv</code>に6を引くのはそのためです。</p>

<h3 id="find-suitable-block"><code>find_suitable_block()</code></h3>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">const</span> <span class="n">u32</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_sl_bitmap</span><span class="p">[</span><span class="n">fl</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="n">sl</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
<span class="p">{</span>   <span class="c1">// if tmp is not 0.
</span><span class="c1"></span>    <span class="n">result</span><span class="p">.</span><span class="n">flv</span> <span class="o">=</span> <span class="n">fl</span><span class="p">;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">slv</span> <span class="o">=</span> <span class="n">ls_bit</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="n">result</span><span class="p">.</span><span class="n">p_block_hdr</span> <span class="o">=</span> <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">mp_matrix</span><span class="p">[</span><span class="n">result</span><span class="p">.</span><span class="n">flv</span><span class="p">][</span><span class="n">result</span><span class="p">.</span><span class="n">slv</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>   <span class="c1">// if tmp is 0
</span><span class="c1"></span>    <span class="n">result</span><span class="p">.</span><span class="n">flv</span> <span class="o">=</span> <span class="n">ls_bit</span><span class="p">(</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_fl_bitmap</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">fl</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">flv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">result</span><span class="p">.</span><span class="n">slv</span> <span class="o">=</span> <span class="n">ls_bit</span><span class="p">(</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_sl_bitmap</span><span class="p">[</span><span class="n">result</span><span class="p">.</span><span class="n">flv</span><span class="p">]);</span>
        <span class="n">result</span><span class="p">.</span><span class="n">p_block_hdr</span> <span class="o">=</span> <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">mp_matrix</span><span class="p">[</span><span class="n">result</span><span class="p">.</span><span class="n">flv</span><span class="p">][</span><span class="n">result</span><span class="p">.</span><span class="n">slv</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><code>find_suitable_block()</code>関数は、<code>fl</code>と<code>sl</code>を使って最終的にマトリックスに登録されている、要請されたサイズより大きいか同じの適当なメモリブロックを返します。まず、最初にはSLI（Second-Level Index）を探索し、そしてFLIを探索する形でフリーブロックが位置されているFirst-IndexとSecond-Indexを取得します。そして、TLSF管理構造体にある配列から空いているブロックのアドレスを持って来るようにします。</p>

<p>ただし、この<code>flv</code>と<code>slv</code>が0より低い値になると適合なブロック探しは失敗になります。</p>

<h3 id="ls-bit-ms-bit"><code>ls_bit()</code> &amp; <code>ms_bit()</code></h3>

<ul>
<li>ls_bit：Find First Set（最初の１の値を持つビットの番地）を探します。</li>
<li>ms_bit：Find Last Set（最後に１の値を持つビットの番地）を探します。</li>
</ul>

<p>普通のアルゴリズムでも値を計算することは出来るんですが、この関数の中ではもっとビットを早く計算するためにテーブルを使ってます。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">static</span> <span class="k">constexpr</span> <span class="n">i32</span> <span class="n">sk_table</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> 
     <span class="c1">// ...
</span><span class="c1"></span>     <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span>
<span class="p">};</span>

<span class="c1">// in ms_bit (tls)
</span><span class="c1"></span><span class="k">const</span> <span class="n">u32</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">val</span><span class="p">;</span>
<span class="k">const</span> <span class="n">u32</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">u32</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;=</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="mh">0xFF</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">else</span>             <span class="p">{</span> <span class="k">return</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="mh">0xFFFFFF</span> <span class="o">?</span> <span class="mi">16</span> <span class="o">:</span> <span class="mi">24</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}(</span><span class="n">x</span><span class="p">);</span>
<span class="k">return</span> <span class="n">sk_table</span><span class="p">[</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>
</code></pre></div>
<hr />

<p>malloc関数に戻って…</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">extract_block_hdr</span><span class="p">(</span><span class="n">p_b</span><span class="p">,</span> <span class="n">p_tlsf_pool</span><span class="p">,</span> <span class="n">rs_suitable</span><span class="p">.</span><span class="n">flv</span><span class="p">,</span> <span class="n">rs_suitable</span><span class="p">.</span><span class="n">slv</span><span class="p">);</span>

<span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_nb</span> <span class="o">=</span> <span class="n">p_b</span><span class="o">-&gt;</span><span class="n">get_next_block</span><span class="p">();</span>
<span class="n">mem_size</span> <span class="o">=</span> <span class="n">rs_search</span><span class="p">.</span><span class="n">rdup_size</span><span class="p">;</span>
</code></pre></div>
<p>有効なフリーメモリブロックを取得した後には、それをマトリックスから外す必要があります。そして、ブロックと連結されている（リンクリストとして）メモリブロックがある場合には、そのブロックをマトリックスに登録する必要があります。<code>extract_block_hdr</code>はそれをやってくれます。</p>

<h3 id="extract-block-hdr"><code>extract_block_hdr()</code></h3>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"> <span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_item</span> <span class="o">=</span> 
     <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">mp_matrix</span><span class="p">[</span><span class="n">final_fl</span><span class="p">][</span><span class="n">final_sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_b</span><span class="o">-&gt;</span><span class="n">get_free_ptrs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
 <span class="k">if</span> <span class="p">(</span><span class="n">p_item</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="n">p_item</span><span class="o">-&gt;</span><span class="n">get_free_ptrs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">p_prev</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="k">else</span>
 <span class="p">{</span>
     <span class="n">clear_bit</span><span class="p">(</span><span class="n">final_sl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_sl_bitmap</span><span class="p">[</span><span class="n">final_fl</span><span class="p">]);</span>
     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_sl_bitmap</span><span class="p">[</span><span class="n">final_fl</span><span class="p">])</span>
     <span class="p">{</span>
         <span class="n">clear_bit</span><span class="p">(</span><span class="n">final_fl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_fl_bitmap</span><span class="p">);</span>
     <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div>
<p>この関数は、フリーブロック<code>p_b</code>に連結しているまた新しいフリーブロックを同じFirst、Second-Indexに連結して次のメモリ確保に対する準備を行うことをやってくれます。またインデックスに該当する新しいフリーブロックがない場合にはTLSF構造体からFirst、Second-Indexを参照するためのビットマップ（<code>m_sl_bitmap</code>、<code>m_fl_bitmap</code>）から自分のインデックス値が取得出来ないようにリセットします。</p>

<hr />
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="n">tmp_size</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">block_header_t</span><span class="p">))</span>
<span class="p">{</span>   <span class="c1">// 分割する。
</span><span class="c1"></span>    <span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_b2</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_header_t</span><span class="o">*</span><span class="p">)((</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">p_b</span><span class="o">-&gt;</span><span class="n">get_buffer</span><span class="p">()</span> <span class="o">+</span> <span class="n">mem_size</span><span class="p">);</span>
    <span class="c1">// Set p_b2 information...
</span><span class="c1"></span>  
    <span class="n">p_nb</span><span class="o">-&gt;</span><span class="n">set_prev_bhdr</span><span class="p">(</span><span class="n">p_b2</span><span class="p">);</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">split_fl</span><span class="p">,</span> <span class="n">split_sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping_insert</span><span class="p">(</span><span class="n">tmp_size</span><span class="p">);</span>
    <span class="n">insert_block</span><span class="p">(</span><span class="n">p_b2</span><span class="p">,</span> <span class="n">p_tlsf_pool</span><span class="p">,</span> <span class="n">split_fl</span><span class="p">,</span> <span class="n">split_sl</span><span class="p">);</span>
  
    <span class="c1">// p_b2の設定が終わったら、p_bのサイズを更新する。
</span><span class="c1"></span><span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="n">p_nb</span><span class="o">-&gt;</span><span class="n">set_prev_freed</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>最後に、<code>tmp_size := p_b-&gt;block_size - mem_size</code>を計算し、確保されたメモリの量に対して新しい空きブロックが作れたら作るようにします。空きブロックが作られたら、<code>insert_block()</code>関数でTLSF構造体の空きブロック管理マトリックスに入れるようにします。</p>

<h3 id="insert-block"><code>insert_block()</code></h3>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">free_ptr_t</span><span class="o">*</span> <span class="n">p_free_ptr</span> <span class="o">=</span> <span class="n">p_b</span><span class="o">-&gt;</span><span class="n">get_free_ptrs</span><span class="p">();</span>
<span class="n">p_free_ptr</span><span class="o">-&gt;</span><span class="n">p_prev</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="n">p_free_ptr</span><span class="o">-&gt;</span><span class="n">p_next</span> <span class="o">=</span> <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">mp_matrix</span><span class="p">[</span><span class="n">final_fl</span><span class="p">][</span><span class="n">final_sl</span><span class="p">];</span>

<span class="k">if</span> <span class="p">(</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">mp_matrix</span><span class="p">[</span><span class="n">final_fl</span><span class="p">][</span><span class="n">final_sl</span><span class="p">])</span>
<span class="p">{</span>
    <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">mp_matrix</span><span class="p">[</span><span class="n">final_fl</span><span class="p">][</span><span class="n">final_sl</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">get_free_ptrs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">p_prev</span><span class="o">=</span> <span class="n">p_b</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">mp_matrix</span><span class="p">[</span><span class="n">final_fl</span><span class="p">][</span><span class="n">final_sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_b</span><span class="p">;</span>
</code></pre></div>
<p>空きブロック<code>p_b</code>を空きブロック管理マトリックスに入れます。ただし、指定されたインデックスにはすでに空きブロックがあるかもしれません。そのときにはリンクリストで２つを繋ぐようにします。こうすることで、<code>extract_block_hdr</code>などで接近した複数のブロックが一つずつ抜かれて使えるようになります。</p>

<hr />

<p>最後に、取得出来た空きブロック<code>p_b</code>の設定をし、リターン値として返せば終わります。</p>

<h2 id="3-tlsf-realloc">3.<code>tlsf_realloc</code></h2>

<p>TLSFの<code>realloc</code>アルゴリズムは３つの分岐に分かれます。</p>

<ol>
<li>再確保するサイズが既存のサイズより小さく、使ってるブロックが使い回せる場合</li>
<li>確保するサイズは既存より大きいが、隣接する次のブロックを使って確保できる場合</li>
<li>１も２も当てはまらなく、<code>malloc</code>をして完全に新しいブロックを確保する場合</li>
</ol>

<h3 id="1-サイズが既存のサイズより小さい時">1. サイズが既存のサイズより小さい時</h3>

<p>まず、サイズが小さくて隣接したブロックが空きブロックの場合には、その空きブロックと今の余りのメモリバッファを合わせて大きい空きブロックが作れるかを判断することが出来ます。以下のロジックではそれを判断し、満足したら併合するようにしています。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="n">p_next_bhdr</span><span class="o">-&gt;</span><span class="n">is_freed</span><span class="p">())</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">next_fl</span><span class="p">,</span> <span class="n">next_sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping_insert</span><span class="p">(</span><span class="n">p_next_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">());</span>
    <span class="n">extract_block</span><span class="p">(</span><span class="n">p_next_bhdr</span><span class="p">,</span> <span class="n">p_tlsf</span><span class="p">,</span> <span class="n">next_fl</span><span class="p">,</span> <span class="n">next_sl</span><span class="p">);</span>

    <span class="n">old_size</span> <span class="o">+=</span> <span class="n">p_next_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size_with_header</span><span class="p">();</span>
    <span class="n">p_next_bhdr</span> <span class="o">=</span> <span class="n">p_next_bhdr</span><span class="o">-&gt;</span><span class="n">get_next_block</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="n">new_free_size</span> <span class="o">=</span> <span class="n">old_size</span> <span class="o">-</span> <span class="n">new_size</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">new_free_size</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">block_header_t</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">new_free_size</span> <span class="o">-=</span> <span class="n">block_header_t</span><span class="o">::</span><span class="n">sk_block_header_ovhd</span><span class="p">;</span>
    <span class="k">auto</span><span class="o">*</span> <span class="n">p_new_bhdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_header_t</span><span class="o">*</span><span class="p">)((</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_buffer</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_size</span><span class="p">);</span>
    <span class="c1">// p_new_bhdrの設定
</span><span class="c1"></span>    <span class="c1">// p_next_next_bhdr (既存p_next_bhdrの次ブロック)をp_newに連結
</span><span class="c1"></span>　　 <span class="c1">// p_new_bhdrをマトリックスに挿入
</span><span class="c1"></span>    <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">new_fl</span><span class="p">,</span> <span class="n">new_sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping_insert</span><span class="p">(</span><span class="n">new_free_size</span><span class="p">);</span>
    <span class="n">insert_block</span><span class="p">(</span><span class="n">p_new_bhdr</span><span class="p">,</span> <span class="n">p_tlsf</span><span class="p">,</span> <span class="n">new_fl</span><span class="p">,</span> <span class="n">new_sl</span><span class="p">);</span>
    <span class="c1">// 最後にp_bの情報を更新
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>
<h3 id="extract-block"><code>extract_block()</code></h3>

<p>この関数は<code>extract_block_hdr()</code>に似ていますが、自分の前後ブロックを連結させて、空きブロックマトリックスから自分を抜いて参照させないようにしています。ただし、マトリックスリストに先頭に見えないとマトリックスでの削除はされません。</p>

<p>なぜ先頭に出てからこそ削除できるかはわからないですが、多分マトリックスに接近する時に必要となるFirst-IndexとSecond-Indexが前後同じになるから、わざとリンクリストを一通り回って削除するかを判断しなくても済ませるのではないかと思ってます。（間違ってるかもしれません）</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="n">p_free_ptr</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">p_free_ptr</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="o">-&gt;</span><span class="n">get_free_ptrs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">p_prev</span> <span class="o">=</span> <span class="n">p_free_ptr</span><span class="o">-&gt;</span><span class="n">p_prev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">p_free_ptr</span><span class="o">-&gt;</span><span class="n">p_prev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">p_free_ptr</span><span class="o">-&gt;</span><span class="n">p_prev</span><span class="o">-&gt;</span><span class="n">get_free_ptrs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">p_next</span> <span class="o">=</span> <span class="n">p_free_ptr</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="k">auto</span><span class="o">*</span> <span class="n">p_matrix_b</span> <span class="o">=</span> <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">mp_matrix</span><span class="p">[</span><span class="n">final_fl</span><span class="p">][</span><span class="n">final_sl</span><span class="p">];</span> <span class="n">p_matrix_b</span> <span class="o">==</span> <span class="n">p_b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">p_matrix_b</span> <span class="o">=</span> <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">mp_matrix</span><span class="p">[</span><span class="n">final_fl</span><span class="p">][</span><span class="n">final_sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_free_ptr</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_matrix_b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">clear_bit</span><span class="p">(</span><span class="n">final_sl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_sl_bitmap</span><span class="p">[</span><span class="n">final_fl</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_sl_bitmap</span><span class="p">[</span><span class="n">final_fl</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">clear_bit</span><span class="p">(</span><span class="n">final_fl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_fl_bitmap</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<hr />

<h3 id="2-サイズが既存より大きいが-隣接空きブロックで解決できる場合">2. サイズが既存より大きいが、隣接空きブロックで解決できる場合</h3>

<p>隣接した空きブロックをくっつけることでサイズの問題が解決できれば、空きブロックをマトリックスから抜いてくっつけて、そして余ったメモリ空間を新しい空きブロックとして作ります。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">+</span> <span class="n">p_next_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">()))</span>
<span class="p">{</span>
    <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_used_mem</span> <span class="o">-=</span> <span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size_with_header</span><span class="p">();</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">next_fl</span><span class="p">,</span> <span class="n">next_sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping_insert</span><span class="p">(</span><span class="n">p_next_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">());</span>
    <span class="n">extract_block</span><span class="p">(</span><span class="n">p_next_bhdr</span><span class="p">,</span> <span class="n">p_tlsf</span><span class="p">,</span> <span class="n">next_fl</span><span class="p">,</span> <span class="n">next_sl</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="n">p_next_bhdr</span> <span class="o">=</span> <span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_next_block</span><span class="p">();</span>
    <span class="c1">// ...
</span><span class="c1"></span>
    <span class="n">u64</span> <span class="n">new_free_size</span> <span class="o">=</span> <span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">()</span> <span class="o">-</span> <span class="n">new_size</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">new_free_size</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">block_header_t</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">new_free_size</span> <span class="o">-=</span> <span class="n">block_header_t</span><span class="o">::</span><span class="n">sk_block_header_ovhd</span><span class="p">;</span>
        <span class="k">auto</span><span class="o">*</span> <span class="n">p_new_bhdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_header_t</span><span class="o">*</span><span class="p">)((</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_buffer</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_size</span><span class="p">);</span>
        <span class="c1">// ...
</span><span class="c1"></span>        <span class="c1">// ...
</span><span class="c1"></span>
        <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">new_fl</span><span class="p">,</span> <span class="n">new_sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping_insert</span><span class="p">(</span><span class="n">new_free_size</span><span class="p">);</span>
        <span class="n">insert_block</span><span class="p">(</span><span class="n">p_new_bhdr</span><span class="p">,</span> <span class="n">p_tlsf</span><span class="p">,</span> <span class="n">new_fl</span><span class="p">,</span> <span class="n">new_sl</span><span class="p">);</span>
        <span class="c1">// ...
</span><span class="c1"></span>    <span class="p">}</span>
  
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">p_data</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="3-mallocで新しいブロックを探すしかない場合">3. mallocで新しいブロックを探すしかない場合</h3>

<p>どうしようもないので<code>malloc</code>で新しいブロックを探します。探すことが出来たら、<code>memcpy</code>で既存のブロックの内容を新しいブロックにコピーします。ただし、この場合だとPODでしかちゃんとコピーが出来ないのでC++のクラスの情報が入ったブロックをコピーしたい場合には特殊なロジックが要るかもしれません。</p>

<p>最後には既存のブロックを<code>free</code>します。（<code>tlsf_free()</code>）</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// Otherwise, we need to find another free-block.
</span><span class="c1"></span><span class="n">block_buffer_t</span><span class="o">*</span> <span class="n">p_new_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_buffer_t</span><span class="o">*</span><span class="p">)</span><span class="n">tlsf_malloc</span><span class="p">(</span><span class="n">new_size</span><span class="p">,</span> <span class="n">p_tlsf</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_new_buffer</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>

<span class="k">const</span> <span class="n">u64</span> <span class="n">copy_size</span> <span class="o">=</span> <span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">new_size</span> 
    <span class="o">?</span> <span class="nl">new_size</span> 
    <span class="p">:</span> <span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">();</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">p_new_buffer</span><span class="p">,</span> <span class="n">p_buffer</span><span class="p">,</span> <span class="n">copy_size</span><span class="p">);</span>
<span class="n">tlsf_free</span><span class="p">(</span><span class="n">p_buffer</span><span class="p">,</span> <span class="n">p_tlsf</span><span class="p">);</span>
</code></pre></div>
<h2 id="4-tlsf-free">4.<code>tlsf_free()</code></h2>

<p>確保したメモリブロックを解除したい場合にはこの関数を使います。（ただし、PODタイプのみ）<br>しかしメモリ解除をする時に、今解除するメモリブロックに隣接したブロックが空き（フリー）かを確認し、空きだったら併合して一つのブロックに纏めさせることも出来ます。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// 消す前に次のブロックがFreeなのかを確認する。
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_temp_bhdr</span> <span class="o">=</span> <span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_next_block</span><span class="p">();</span>
    <span class="n">p_temp_bhdr</span><span class="o">-&gt;</span><span class="n">is_freed</span><span class="p">())</span>
<span class="p">{</span>   <span class="c1">// 併合
</span><span class="c1"></span>    <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">fl</span><span class="p">,</span> <span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping_insert</span><span class="p">(</span><span class="n">p_temp_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">());</span>
    <span class="n">extract_block</span><span class="p">(</span><span class="n">p_temp_bhdr</span><span class="p">,</span> <span class="n">p_tlsf_pool</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">sl</span><span class="p">);</span>
    <span class="c1">// 後処理
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 消す前に前のブロックがFreeなのかを確認する。
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">is_prev_freed</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_prev_bhdr</span> <span class="o">=</span> <span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_prev_bhdr</span><span class="p">();</span>
    <span class="c1">// 併合
</span><span class="c1"></span>    <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">fl</span><span class="p">,</span> <span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping_insert</span><span class="p">(</span><span class="n">p_prev_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">());</span>
    <span class="n">extract_block</span><span class="p">(</span><span class="n">p_prev_bhdr</span><span class="p">,</span> <span class="n">p_tlsf_pool</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">sl</span><span class="p">);</span>
    <span class="c1">// 後処理
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>
<p>最後に空いたブロックを空きブロック管理マトリックスに入れます。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// Final mapping insert.
</span><span class="c1"></span><span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">fl</span><span class="p">,</span> <span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping_insert</span><span class="p">(</span><span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">());</span>
<span class="n">insert_block</span><span class="p">(</span><span class="n">p_bhdr</span><span class="p">,</span> <span class="n">p_tlsf_pool</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">sl</span><span class="p">);</span>
</code></pre></div>
<h2 id="5-tlsf-raw-destroy">5.<code>tlsf_raw_destroy</code></h2>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">tlsf_raw_t</span><span class="o">*</span> <span class="n">p_tlsf</span> <span class="o">=</span> <span class="p">(</span><span class="n">tlsf_raw_t</span><span class="o">*</span><span class="p">)</span><span class="n">p_pool</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">has_signature</span><span class="p">())</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_used_mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div>
<p>TLSF構造体のシグニチャーを無効化します。それだけです。</p>

<h1 id="改善点">改善点</h1>

<h3 id="ビットシフトアルゴリズムがまだ完全に理解できてない">・ビットシフトアルゴリズムがまだ完全に理解できてない</h3>

<p>First-IndexとSecond-Indexの数値をビットマップ変数に更新するためのアルゴリズムが完全には理解できませんでした。テストケースを作って、どのようにフラグ値が変わるのかを詳しく調べてみたいですね。</p>

<h3 id="まだscalableではない">・まだScalableではない</h3>

<p>TLSFの特徴の一つである、メモリプールをくっつけて更に多くのメモリが確保出来るようにするための機能がまだ実装してませんでした。次の記事を書くときには今抜かれた機能まで付けて、それの説明までしたいです。</p>

<h1 id="まとめ">まとめ</h1>

<p>最後までがんばります。（適当）</p>
]]></content>
		</item>
		
		<item>
			<title>行列変数のネーミングについて</title>
			<link>https://liliilli.github.io/posts/matrix_name/</link>
			<pubDate>Fri, 13 Mar 2020 13:11:47 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/matrix_name/</guid>
			<description>https://www.sebastiansylvan.com/post/matrix_naming_convention/ D3Dスタイル（Row-Major、左から右へ演算していくスタイル）でやると、 vector4_t transformed_point = point * M * A; が普通だけど、このままじゃ後でまた見る時に何</description>
			<content type="html"><![CDATA[<p><a href="https://www.sebastiansylvan.com/post/matrix_naming_convention/">https://www.sebastiansylvan.com/post/matrix_naming_convention/</a></p>

<p>D3Dスタイル（Row-Major、左から右へ演算していくスタイル）でやると、</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">vector4_t</span> <span class="n">transformed_point</span> <span class="o">=</span> <span class="n">point</span> <span class="o">*</span> <span class="n">M</span> <span class="o">*</span> <span class="n">A</span><span class="p">;</span>
</code></pre></div>
<p>が普通だけど、このままじゃ後でまた見る時に何をしているかが分からないかもしれない。</p>

<p>なので、お勧めしている変数名の書き方としては、<code>foo_to_bar</code>または<code>bar_from_too</code>（これはOpenGLかVulkan系列）みたいに座標空間から別の座標空間の名前を書くのが良いらしい。例えば、<code>world_to_view</code>または<code>view_to_projection</code>みたいな…<code>transform_matrix</code>のような名前よりは全然意味がわかるようになってる。</p>

<p>ということで、お勧めした変数ネーミングスタイルで例を書いてみると、</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">const</span> <span class="n">matrix4_t</span> <span class="n">object_to_view</span> <span class="o">=</span> <span class="n">object_to_world</span> <span class="o">*</span> <span class="n">world_to_view</span><span class="p">;</span>
<span class="k">const</span> <span class="n">matrix4_t</span> <span class="n">object_to_proj</span> <span class="o">=</span> <span class="n">object_to_view</span> <span class="o">*</span> <span class="n">view_to_proj</span><span class="p">;</span>

<span class="k">const</span> <span class="n">vector4_t</span> <span class="n">point_in_proj</span> <span class="o">=</span> <span class="n">point</span> <span class="o">*</span> <span class="n">object_to_proj</span><span class="p">;</span>
</code></pre></div>
<p>逆行列の場合には、単純に前の座標空間と後ろの座標空間の名前を書き換えることだけ。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">const</span> <span class="n">matrix4_t</span> <span class="n">view_to_object</span> <span class="o">=</span> <span class="p">(</span><span class="n">object_to_world</span> <span class="o">*</span> <span class="n">world_to_view</span><span class="p">).</span><span class="n">to_inverse</span><span class="p">();</span>

<span class="k">const</span> <span class="n">matrix4_t</span> <span class="n">head_to_right_hand</span> <span class="o">=</span> <span class="n">rigth_hand_to_head</span><span class="p">.</span><span class="n">to_inverse</span><span class="p">();</span>
<span class="k">const</span> <span class="n">matrix4_t</span> <span class="n">object_to_right_hand</span> <span class="o">=</span> 
    <span class="n">object_to_world</span> <span class="o">*</span> <span class="n">world_to_head</span> <span class="o">*</span> <span class="n">head_to_right_hand</span><span class="p">;</span>
</code></pre></div>
<p>OpenGLでは、<code>to</code>の代わりに<code>from</code>を使い、そして演算の手順に沿って逆に書く。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">const</span> <span class="n">matrix4_t</span> <span class="n">proj_from_object</span> <span class="o">=</span> 
    <span class="n">proj_from_view</span> <span class="o">*</span> <span class="n">view_from_world</span> <span class="o">*</span> <span class="n">world_from_object</span><span class="p">;</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>自分でやるDyのCMakeListsファイル説明</title>
			<link>https://liliilli.github.io/posts/dy_cmake/</link>
			<pubDate>Sun, 08 Mar 2020 11:48:19 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/dy_cmake/</guid>
			<description>はじめに 自分の個人プロジェクトのDyという、ゲームエンジンプロジェクトがあって、たまに時間がある時開発をしています。ですけど今は表じゃなく裏</description>
			<content type="html"><![CDATA[

<h1 id="はじめに">はじめに</h1>

<p>自分の個人プロジェクトの<code>Dy</code>という、ゲームエンジンプロジェクトがあって、たまに時間がある時開発をしています。ですけど今は表じゃなく裏で色々と構造上の問題の修正とか、会社で勉強になったところを適用しつつ<code>git</code>を使用せずにこっそりとやったのです。（伏線）</p>

<p>ところで、何日前に酔っ払って家に帰ってきてから開発をしようとしたけど、無闇に<code>CMakeLists.txt</code>ファイルを消してしまいました。やべぇと思いながら削除したファイルを戻そうとしましたが、VS自体で削除したせいで戻せませんでした。当然ビルドも通らなくなりました。</p>

<p>ということで結局書き直さざるを得ませんでしたが、最後に<code>CMakeLists.txt</code>を書いてから半年も過ぎているんでどう書けばいいか全然思いつきませんでした。結局最初からやり直す気持ちで<code>cmake</code>のメモ記事を書いて勉強し、なんとか書き直したんです。</p>

<p>ここからは真下の全文を最初から読み通して、リマインド用としてどんな要素を使ってコードを書いたかを説明したいと思います。</p>

<h1 id="説明">説明</h1>

<h2 id="function-find-platform">・function(_find_platform)</h2>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">function</span><span class="p">(</span><span class="s">_find_platform</span> <span class="s">IVerbose</span> <span class="s">OPlatform</span><span class="p">)</span></code></pre></div>
<blockquote>
<p><a href="https://cmake.org/cmake/help/v3.14/manual/cmake.1.html#build-tool-mode">https://cmake.org/cmake/help/v3.14/manual/cmake.1.html#build-tool-mode</a><br>
<a href="https://cmake.org/cmake/help/v3.14/envvar/VERBOSE.html">https://cmake.org/cmake/help/v3.14/envvar/VERBOSE.html</a></p>
</blockquote>

<p><code>_find_platform</code>という名前をもつ関数です。<code>IVerbose</code>では変数または<code>VERBOSE</code>が入ります。<code>VERBOSE</code>はcmakeで設定ファイルを作るとき、コマンド引数で<code>-v --verbose</code>を入れることで<code>true</code>になるらしいです。</p>

<p>それで<code>IVerbose</code>が<code>true</code>であれば、変数とかログを出力しようとしてます。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">if</span> <span class="p">(</span><span class="s">IVerbose</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">CMAKE_HOST_SYSTEM_NAME</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<blockquote>
<p><a href="https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_SYSTEM_NAME.html">https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_SYSTEM_NAME.html</a></p>
</blockquote>

<p><code>CMAKE_HOST_SYSTEM_NAME</code>は今使っているOSの名前を返します。リナックス、ウィンドウズ、マックの場合には<code>Linux</code>、<code>Windows</code>、<code>Darwin</code>を返します。それじゃないOSの場合には<code>uname -s</code>で返される文字列を持つようです。</p>

<p>文字列を<code>OPlatform</code>変数に入れときます。関数から外側からの変数引数に値を更新する場合には<code>PARENT_SCOPE</code>を使います。もし、どの分岐にも当たらなかったら変数の値は未定です。（<code>-NOTFOUND</code>かもしれませんね）</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OPlatform</span><span class="o">}</span> <span class="s2">&#34;WIN&#34;</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span></code></pre></div>
<h2 id="function-check-supported-platform-iplatformkey-oissupported">・function(_check_supported_platform IPlatformKey OIsSupported)</h2>

<p><code>function(_find_platform)</code>から取得したキーを検証し、ビルドできるプラットフォームなのかを確認してくれます。まず、<code>if</code>で<code>IPlatformKey</code>変数を検証する時には以下のようにします。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">if</span> <span class="p">(</span><span class="s2">&#34;${IPlatformKey}&#34;</span> <span class="s">STREQUAL</span> <span class="s2">&#34;WIN&#34;</span><span class="p">)</span></code></pre></div>
<p><code>&quot;&quot;</code>を抜いて書いてもいいと思いますが、一応安全策として。<code>${}</code>はできるなら必須だと思います。単純に<code>IPlatformKey</code>で書いちゃうよりはマシ…だと思います。ただし、<code>${}</code>つけられるのはcmake 3.0バージョンから出来るらしいです。</p>

<p>関数は別の言語のように早めにリターンすることも出来ます。<code>return()</code>を使いましょう。</p>

<h2 id="function-is-windows-obool">・function(_is_windows OBool)</h2>

<p>プラットフォームがウィンドウズかを確認してくれます。中身は単純に<code>_find_platform</code>関数の呼び出しとウィンドウズなのかを検証する分岐を書いたことに過ぎません。</p>

<h2 id="function-find-winsdk-iverbose-odir-olibdir-oincdir">・function(_find_winsdk IVerbose &hellip; ODir OLibDir OIncDir)</h2>

<blockquote>
<p><a href="https://github.com/rpavlik/cmake-modules/blob/master/FindWindowsSDK.cmake">https://github.com/rpavlik/cmake-modules/blob/master/FindWindowsSDK.cmake</a></p>
</blockquote>

<p>今使っているOSのがウィンドウズかを確認し、ウィンドウズなら一番最新のSDKのルートパス、Includeパス、そしてライブラリーディレクトリのパスを返します。ここでは<code>FindWindowsSDK</code>というモジュールを使って、いちいち手作業でSDKのパス情報などを取得するようにしなくても提供された関数を呼び、変数を参照するだけで情報が取得できるようにしてくれます。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">include</span><span class="p">(</span><span class="s">FindWindowsSDK</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="c"># ... DO SOMETHING
</span><span class="c"></span><span class="nb">get_windowssdk_library_dirs</span><span class="p">(</span><span class="o">${</span><span class="nv">_in_ODir</span><span class="o">}</span> <span class="s">_in_OLibDir</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">get_windowssdk_include_dirs</span><span class="p">(</span><span class="o">${</span><span class="nv">_in_ODir</span><span class="o">}</span> <span class="s">_in_OIncDir</span><span class="p">)</span></code></pre></div>
<h2 id="macro-dy-setup-build-settings">・macro(dy_setup_build_settings)</h2>

<p>基本的なビルド設定を書いてくれます。ソースファイルの取得、IncludeとかInlineフォルダーの検知、C++バージョンの設定、属性（Property）の設定とビルドオプションを付けること等をやってくれます。</p>

<p>関数とは違ってマクロなため、各種要素のスコープ管理処理が若干ややこしくなります。</p>

<h3 id="cmake-build-type">CMAKE_BUILD_TYPE</h3>

<blockquote>
<p><a href="https://cmake.org/cmake/help/v3.0/variable/CMAKE_BUILD_TYPE.html">https://cmake.org/cmake/help/v3.0/variable/CMAKE_BUILD_TYPE.html</a></p>
</blockquote>

<p>プロジェクト全般のビルドタイプの文字列を持ちます。例えば、デバッグモードでビルドする時には<code>Debug</code>または<code>DEBUG</code>を、リリースモードでやる時には<code>Release</code>とか<code>RELEASE</code>という文字列を持ちます。（環境によって異なる可能性もあります。）</p>

<p>そしてこの文字列は<code>CMAKE_CXX_FLAGS_&lt;CONFIG&gt;</code>の<code>&lt;CONFIG&gt;</code>にも影響を及ぶそうです。ビルドモードによって<code>CMAKE_CXX_FLAGS_Debug</code>、<code>_Release</code>になれるらしいです。僕の書いたコードではこの<code>&lt;CONFIG&gt;</code>を後で見る*Generator Expression*を制御する時に使います。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;${PROJECT_NAME} is built with ${CMAKE_BUILD_TYPE} mode.&#34;</span><span class="p">)</span></code></pre></div>
<h3 id="cc-ファイルリストの取得-フィルタリング"><code>.cc</code>ファイルリストの取得、フィルタリング</h3>

<p>以前の<code>CMakeLists.txt</code>ファイルでは、各プロジェクトごとに一々ソースファイルを登録しなければなりませんでした。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">target_sources</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
<span class="s">PRIVATE</span>
	<span class="s">XTFVector.cc</span>
	<span class="s">XString.cc</span>
	<span class="s">XFMemPool.cc</span>
	<span class="c"># などなど...
</span><span class="c"></span>	<span class="s">Utility/test_bit_operation.cc</span>
<span class="p">)</span></code></pre></div>
<p>ですが、今新しく設定ファイルを書く時には一々ファイルのパスを書く手間をなくすよう、<code>Src</code>フォルダーから子フォルダーの中に入っているファイルを検索して、<code>cpp</code>ソースファイルを自動に取得するようにしてくれるようにしました。</p>

<blockquote>
<p><a href="https://cmake.org/cmake/help/v3.14/command/file.html">https://cmake.org/cmake/help/v3.14/command/file.html</a><br><a href="https://cmake.org/cmake/help/v3.14/command/file.html#filesystem">https://cmake.org/cmake/help/v3.14/command/file.html#filesystem</a></p>
</blockquote>

<p><code>file()</code>はファイルシステムのファイルまたはディレクトリに接近するときに使うコマンドです。ここでフォルダーの中のファイルを全部取得するために<code>GLOB_RECURSE</code>を使います。<code>file()</code>コマンド構文の最後に出るのが<code>${CMAKE_CURRENT_SOURCE_DIR}/Src</code>フォルダーから特定ファイルを探すための表現式となります。下の場合にはすべての<code>.cc</code>ファイルのパスを探して、<code>${PROJECT_NAME}_InGetSrcs</code>変数に値を更新します。ただし<code>RELATIVE</code>があるため、絶対パスじゃなく相対パスとなります。</p>

<p>cmake 3.12バージョンからは<code>CONFIGURE_DEPENDS</code>が追加されたため、追加しときました。そもそもソースファイルを取得するために<code>GLOB</code>系列を使うのはおすすめしない方法です。なぜならこのソースファイルリストはファイルを追加するか削除するたびに更新してくれず、あくまでcmakeのキャッシュなどを再設定（Reconfiguration）する時だけ更新するからです。</p>

<p>なので<code>CONFIGURE_DEPENDS</code>を追加することで、一応ビルドタイムでもソースファイルリストを更新する必要があるかをチェックし、<code>GLOB</code>コマンドを再度回してくれるようになります。ですが、ソースファイルの量が多くなると以前よりは時間がかかるかもしれません。</p>

<p>リストを取得する名前もちょっと変わってます。変数のスコープが全域になるかもしれないので、接頭詞としてプロジェクトの名前を付けた変数を使ってます。例えば、プロジェクトの名前が<code>HogeFuga</code>だとしたら、変数の名前は<code>HogeFuga_InGetSrcs</code>になります。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="s">_InGetSrcs</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">file</span><span class="p">(</span>
	<span class="s">GLOB_RECURSE</span> <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="s">_InGetSrcs</span>
	<span class="s">RELATIVE</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/Src&#34;</span>
	<span class="s">CONFIGURE_DEPENDS</span> <span class="s">*.cc</span>
<span class="p">)</span></code></pre></div>
<p>ソースファイルのリストを取得してターゲット（プロジェクト）に追加する前に、<code>_xxxx.cc</code>みたいに接頭詞<code>_</code>が付いたファイルは除外する必要があります。なぜなら上のコードではビルドする必要がないソースファイルまで取得してしまうからです。</p>

<blockquote>
<p><a href="https://cmake.org/cmake/help/latest/command/string.html#regex-specification">https://cmake.org/cmake/help/latest/command/string.html#regex-specification</a><br><a href="https://cmake.org/cmake/help/latest/command/foreach.html">https://cmake.org/cmake/help/latest/command/foreach.html</a></p>
</blockquote>

<p>ここでビルドしないソースファイルをフィルタリングするため、正規表現パターンを使います。ただ、一般正規表現エンジンみたいに複雑な表現をマッチングさせることは出来ないみたいです。使える正規表現は上のURLで見れます。</p>

<p>とにかく複数の値を持つ変数を巡回させるには<code>foreach()</code>と<code>endforeach()</code>を使います。<code>SrcItem</code>は<code>${PROJECT_NAME}_InGetSrcs</code>の持っている複数の値を一個ずつ持ち、中身で何らかのロジックを行います。また、ループ文の中で次のループに移りたい場合には<code>continue()</code>を使います。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">foreach</span><span class="p">(</span><span class="s">SrcItem</span> <span class="o">${</span><span class="nv">${PROJECT_NAME</span><span class="o">}</span><span class="s">_InGetSrcs}</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">if</span> <span class="p">(</span><span class="s2">&#34;Src/${SrcItem}&#34;</span> <span class="s">MATCHES</span> <span class="s2">&#34;/_+[a-zA-Z0-9_ -]*.cc$&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">continue</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>		<span class="nb">target_sources</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PRIVATE</span> <span class="s2">&#34;Src/${SrcItem}&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nb">endforeach</span><span class="p">()</span></code></pre></div>
<h3 id="inc-inlフォルダーの確認-取得">Inc、Inlフォルダーの確認・取得</h3>

<blockquote>
<p><a href="https://cmake.org/cmake/help/latest/command/if.html#condition-syntax">https://cmake.org/cmake/help/latest/command/if.html#condition-syntax</a></p>
</blockquote>

<p>ディレクトリまたはファイルがあるかを確認するには、<code>if (EXISTS &lt;path&gt;)</code>を使います。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">if</span> <span class="p">(</span><span class="s">EXISTS</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/Inc&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">target_include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s">Inc</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nb">if</span> <span class="p">(</span><span class="s">EXISTS</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/Inl&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">target_include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s">Inl</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<h3 id="windows専用include-ライブラリー追加">Windows専用Include・ライブラリー追加</h3>

<p>cmakeを使っているOSがWindowsならば、Windowsから提供している昨日などを使うためにIncludeとLibraryのパスを指定する必要があります。なので追加でSDKのインクルードパスとライブラリーパスを指定するようしてます。</p>

<p>ですが、今はライブラリーパスのみターゲットへ反映するようにしています。インクルードはやっちゃうとWarningエラーがめちゃくちゃ出てるせいでコメント化してます。多分Clang-ClまたはMSVCは自動でSDKのパスをインクルードかけてくれるみたいです。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake">	<span class="c"># It seems it have not to be inserted into all project when WIN.
</span><span class="c"></span>	<span class="c"># target_include_directories(${PROJECT_NAME} PRIVATE ${WinInc})
</span><span class="c"></span>	<span class="nb">target_link_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PRIVATE</span> <span class="o">${</span><span class="nv">WinLib</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="err">
</span><span class="err"></span>	<span class="nb">target_compile_definitions</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> 
	<span class="s">PRIVATE</span> 
		<span class="s2">&#34;UNICODE&#34;</span> 
		<span class="s2">&#34;_UNICODE&#34;</span>
		<span class="s2">&#34;_CRT_SECURE_NO_WARNINGS&#34;</span>
	<span class="p">)</span></code></pre></div>
<p>ちなみに僕のプロジェクトではマルチバイト文字ではなく、ユニコード文字を使います。</p>

<h3 id="propertyの適用">Propertyの適用</h3>

<blockquote>
<p><a href="https://cmake.org/cmake/help/latest/command/set_target_properties.html">https://cmake.org/cmake/help/latest/command/set_target_properties.html</a><br><a href="https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html#target-properties">https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html#target-properties</a></p>
</blockquote>

<p>ターゲットプロジェクトに属性（Property）を適用するためには、<code>set_target_properties</code>を使います。このコマンドが出来る前までは、<code>CXX_...</code>で始まる全域変数を使って、全てのプロジェクトに同一な属性をつけるしかなかったそうですが、バージョン3.0からは<code>..._target_...</code>みたいなコマンドで個別ターゲットを制御するようになったそうです。</p>

<p>とにかく、ターゲットの属性をつけるには<code>PROPERTIES</code>の後から属性を付けます。下のコードでは<code>CXX_STANDARD</code>という、Cppのバージョンを付けませんでしたが、それは後でコマンドラインまたは別個のプロジェクトCMakeLists.txtでつけるようになってます。もし何も指定されなかった場合にはC++17を自動に付けてあげます。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">set_target_properties</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
	<span class="s">PROPERTIES</span>
	<span class="s">LINKER_LANGUAGE</span> <span class="s">CXX</span>
	<span class="s">CXX_STANDARD_REQUIRED</span> <span class="s">ON</span>
	<span class="s">CXX_EXTENSIONS</span> <span class="s">ON</span>
	<span class="s">ARCHIVE_OUTPUT_DIRECTORY</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/lib/${CMAKE_BUILD_TYPE}&#34;</span>
	<span class="s">LIBRARY_OUTPUT_DIRECTORY</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/lib/${CMAKE_BUILD_TYPE}&#34;</span>
	<span class="s">RUNTIME_OUTPUT_DIRECTORY</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/bin/${CMAKE_BUILD_TYPE}&#34;</span>
<span class="p">)</span></code></pre></div>
<h3 id="コンパイルオプション">コンパイルオプション</h3>

<p>最後にプロジェクトをビルドする時のフラグを入れます。ただし、コンパイラごとにフラグに入れ方が違うため、<code>CMAKE_CXX_COMPILER_ID</code>全域変数を参照してコンパイラごとのフラグを入れる分岐を作ります。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">if</span> <span class="p">((</span>	<span class="c"># MSVC or Clang-Cl (Simulated MSVC on Clang)
</span><span class="c"></span>			<span class="o">${</span><span class="nv">CMAKE_CXX_COMPILER_ID</span><span class="o">}</span> <span class="s">STREQUAL</span> <span class="s2">&#34;Clang&#34;</span> 
			<span class="s">AND</span> <span class="s2">&#34;x${CMAKE_CXX_SIMULATE_ID}&#34;</span> <span class="s">STREQUAL</span> <span class="s2">&#34;xMSVC&#34;</span>
		<span class="p">)</span> 
		<span class="s">OR</span> <span class="o">${</span><span class="nv">CMAKE_CXX_COMPILER_ID</span><span class="o">}</span> <span class="s">STREQUAL</span> <span class="s2">&#34;MSVC&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="c"># Clang-Cl, MSVC Flags
</span><span class="c"></span><span class="nb">elseif</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_CXX_COMPILER_ID</span><span class="o">}</span> <span class="s">STREQUAL</span> <span class="s2">&#34;Clang&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="c"># Clang Flags
</span><span class="c"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="nb">message</span><span class="p">(</span><span class="s">FATAL_ERROR</span> <span class="s2">&#34;This project only supports Clang/Clang-cl or MSVC compiler now.&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<p>ここで注意すべきところは、WindowsのVS（Visual Studio）でcmakeを使い、そしてVSから提供しているClangコンパイラではなく、自分のclangを取り入れてビルドさせる場合には<code>CMAKE_CXX_SIMULATE_ID</code>も検査する必要があります。（基本提供しているClangコンパイラでも起こりえる可能性はあります。）</p>

<p>なので、<code>Clang-Cl</code>を使ってる時には、</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">if</span> <span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_CXX_COMPILER_ID</span><span class="o">}</span> <span class="s">STREQUAL</span> <span class="s2">&#34;Clang&#34;</span> <span class="s">AND</span> <span class="o">${</span><span class="nv">CMAKE_CXX_SIMULATE_ID</span><span class="o">}</span> <span class="s">STREQUAL</span> <span class="s2">&#34;MSVC&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="c"># DO SOMETHING
</span><span class="c"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<p>で検査します。</p>

<p>コンパイラの検査が通ったら、<code>target_compile_options</code>を使い、フラグを入れます。3.0以前のバージョンでは<code>CXX_FLAGS</code>みたいなものを使ってたそうですが、あのやり方じゃ全体プロジェクトのフラグへ影響がありえます。なので今は<code>target_compile_options</code>を使ってターゲットごとのフラグを設定します。</p>

<p>ちょっと注目すべきところは、<code>generator expression</code>を使ってるとこです。<code>$&lt;$&lt;CONFIG:Debug&gt;:${ComOpts_MsvcDebug}&gt;</code>またはDebugがReleaseにされているのが２つも存在しているのは、上で説明していた<code>&lt;CONFIG&gt;</code>の文字列を見て、ビルドする時にビルドモードによってフラグを洗濯的に入れるためです。</p>

<p>例えば、<code>Debug</code>モードの場合には２つめは無視され、１つ目は<code>ComOpts_MscvDebug</code>変数で指定されたフラグリストがターゲットに入ります。<code>Release</code>モードならば逆です。各フラグ変数はコード一番下で書いています。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;$&lt;$&lt;CONFIG:Debug&gt;:${ComOpts_MsvcDebug}&gt;&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;$&lt;$&lt;CONFIG:Release&gt;:${ComOpts_MsvcRelease}&gt;&#34;</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">ComOpts_MsvcCommon</span> 
	<span class="s">/GR-</span> <span class="s">/W4</span> <span class="s">/WX</span> <span class="s">/MP</span> 
	<span class="s">-Wno-error=unused-command-line-argument</span>
	<span class="s">-Wno-error=expansion-to-defined</span>
	<span class="s">-Wno-error=ignored-pragma-intrinsic</span>
<span class="p">)</span> <span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">ComOpts_MsvcDebug</span> <span class="s">/Od</span> <span class="o">${</span><span class="nv">ComOpts_MsvcCommon</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">ComOpts_MsvcRelease</span> <span class="s">/O2</span> <span class="o">${</span><span class="nv">ComOpts_MsvcCommon</span><span class="o">}</span><span class="p">)</span></code></pre></div>
<h1 id="プロジェクトごとのcmakelists-txt">プロジェクトごとのCMakeLists.txt</h1>

<p>各プロジェクトでは下だけを書くことで終わります。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.12</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">DyCommon</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">STATIC</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">dy_setup_build_settings</span><span class="p">()</span></code></pre></div>
<p>または</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span> <span class="p">(</span><span class="s">VERSION</span> <span class="s">3.12</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">TestD3D12</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">add_dependencies</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">DyCommon</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s">DyCommon</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PROPERTIES</span> <span class="s">CXX_STANDARD</span> <span class="s">20</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">dy_setup_build_settings</span><span class="p">()</span></code></pre></div>
<p>ほとんどは<code>dy_setup_build_settings</code>マクロが設定してくれます。はい、おわり。</p>

<h1 id="反省点">反省点</h1>

<h3 id="unity-buildまたは類似unityの導入">Unity Buildまたは類似Unityの導入？</h3>

<p>今は<code>file(GLOB_RECURSE)</code>でソースファイルをまとめてターゲットにバインディングしているようにしてますが、やるなら<code>file</code>コマンドをより活用して一時のUnityビルドファイルを作り、そこにリストをインクルードするコードをCmake側から書いてUnityファイルだけビルド通るようにすることも良さそうじゃないかな～と思いました。</p>

<p>まず、<code>file(GLOB)</code>自体が設定時にコマンド実行が行うため、設定後で新しいファイルを追加しようとしたら再度設定をし直さなければならないです。生産性も下がりそうだし、ビルドするまでの時間もかかりそうだから、やるならUnityビルドしかけたりする方が良いんじゃね…？とふと思いつきました。</p>

<p>後で試してみて、上手く出来たらコード改良して切り換えたいです。</p>

<h3 id="d3d12ライブラリ導入の制御が足りない">D3D12ライブラリ導入の制御が足りない</h3>

<p>現在のコードでは、WindowsならD3D12も自動に入れるようにしています。ですが、D3D12のライブラリは基本的にはWindows10以上のみ対応しているらしく、以前のWindowsOSでは当然ビルドエラーが出ちゃうか、意図してない挙動になれると思います。</p>

<p>なんで、解決策として<code>option</code>コマンドなどでD3D12を入れるかないかを設定するようにし、OSのプラットフォームを詳しく区別させてWin10ではなければD3D12のインポートを解除するようにしつつ、フラグの<code>true/false</code>によって洗濯的にライブラリを入れるようにコードを修正すれば良いんじゃないかなと思いますね。</p>

<h3 id="add-subdirectoryではなく-importで出来るのでは">add_subdirectoryではなく、IMPORTで出来るのでは？</h3>

<blockquote>
<p><a href="https://www.youtube.com/watch?v=y7ndUhdQuU8">https://www.youtube.com/watch?v=y7ndUhdQuU8</a><br><a href="https://www.youtube.com/watch?v=y9kSr5enrSk">https://www.youtube.com/watch?v=y9kSr5enrSk</a></p>
</blockquote>

<p><code>add_subdirectory</code>ではなく、<code>IMPORT</code>でプロジェクトを関連させたりビルドさせたりすることが出来るらしいけど、詳しくは存じないです。単純に勘違いしたかもしれませんね…</p>

<h3 id="警告メッセージをむりやり抑えてしまった">警告メッセージをむりやり抑えてしまった</h3>

<p>Cmake＋Clang-Clでは<code>/MP</code>（マルチプロセッサで並列ビルドを行う）フラグが通じないみたいです。<code>/W4 /WX</code>まで付けたせいでエラーが出まくって、一応<code>-Wno</code>フラグでなんとか警告として扱うように抑えましたが、ちょっと気に食わないですね。</p>

<h1 id="全文">全文</h1>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.12</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">Dy</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># @brief Find platform key string if found.
</span><span class="c">#	Returned `OPlatform` key string is one of below list when found.
</span><span class="c">#	* WIN : Windows
</span><span class="c">#	* LNX : Linux
</span><span class="c">#	* MAC : MacOS (Darwin)
</span><span class="c">#	If not found, key string will be `-NOTFOUND`.
</span><span class="c">#
</span><span class="c"># @param IVerbose verbosity flag. input value is true / false.
</span><span class="c"># @return_var OPlatform 
</span><span class="c"></span><span class="nb">function</span><span class="p">(</span><span class="s">_find_platform</span> <span class="s">IVerbose</span> <span class="s">OPlatform</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">if</span> <span class="p">(</span><span class="s">IVerbose</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">CMAKE_HOST_SYSTEM_NAME</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="nb">if</span> <span class="p">(</span><span class="s2">&#34;${CMAKE_HOST_SYSTEM_NAME}&#34;</span> <span class="s">STREQUAL</span> <span class="s2">&#34;Windows&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s">IVerbose</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Found Windows.&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OPlatform</span><span class="o">}</span> <span class="s2">&#34;WIN&#34;</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">elseif</span><span class="p">(</span><span class="s2">&#34;${CMAKE_HOST_SYSTEM_NAME}&#34;</span> <span class="s">STREQUAL</span> <span class="s2">&#34;Linux&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s">IVerbose</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Found Linux.&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OPlatform</span><span class="o">}</span> <span class="s2">&#34;LNX&#34;</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">elseif</span><span class="p">(</span><span class="s2">&#34;${CMAKE_HOST_SYSTEM_NAME}&#34;</span> <span class="s">STREQUAL</span> <span class="s2">&#34;Darwin&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s">IVerbose</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Found MacOS.&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OPlatform</span><span class="o">}</span> <span class="s2">&#34;MAC&#34;</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nb">endfunction</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># @brief Check given platform is supported with `IPlatformKey` variable.
</span><span class="c">#	Returned `OIsSupported` key have true or false whether given platform is supported or not.
</span><span class="c">#	* true : Detected platform is suppported.
</span><span class="c">#	* false : Detected platform is not supported yet.
</span><span class="c"># 
</span><span class="c"># @param IPlatformKey Get platform key by using _find_platform function.
</span><span class="c"># @return_var OIsSupported
</span><span class="c"></span><span class="nb">function</span><span class="p">(</span><span class="s">_check_supported_platform</span> <span class="s">IPlatformKey</span> <span class="s">OIsSupported</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">if</span> <span class="p">(</span><span class="s2">&#34;${IPlatformKey}&#34;</span> <span class="s">STREQUAL</span> <span class="s2">&#34;WIN&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OIsSupported</span><span class="o">}</span> <span class="s">true</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">return</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="c"># If there is no matched key, just return with false.
</span><span class="c"></span>	<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OISSupported</span><span class="o">}</span> <span class="s">false</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endfunction</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># @brief Check if platform is windows.
</span><span class="c">#
</span><span class="c"># @return_var OBool
</span><span class="c"></span><span class="nb">function</span><span class="p">(</span><span class="s">_is_windows</span> <span class="s">OBool</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">_find_platform</span><span class="p">(</span><span class="s">false</span> <span class="s">_in_key</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">if</span> <span class="p">(</span><span class="s2">&#34;${_in_key}&#34;</span> <span class="s">STREQUAL</span> <span class="s2">&#34;WIN&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OBool</span><span class="o">}</span> <span class="s">true</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">return</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="c"># If not matched, return false.
</span><span class="c"></span>	<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OBool</span><span class="o">}</span> <span class="s">false</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endfunction</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># @brief Find Windows SDK pathes and properties information.
</span><span class="c">#
</span><span class="c"># @return_var ODirs All found SDK path list.
</span><span class="c"># @return_var OBuildVers NOt used
</span><span class="c"># @return_var ONames Not used
</span><span class="c"># @return_var ODir Latest SDK path. 
</span><span class="c"># @return_var OLibDir Latest SDK include file path.
</span><span class="c"># @return_var OIncDir Latest SDK library file path.
</span><span class="c"></span><span class="nb">function</span><span class="p">(</span><span class="s">_find_winsdk</span> <span class="s">IVerbose</span> <span class="s">ODirs</span> <span class="s">OBuildVers</span> <span class="s">ONames</span> <span class="s">ODir</span> <span class="s">OLibDir</span> <span class="s">OIncDir</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">_is_windows</span><span class="p">(</span><span class="s">_in_flag</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">if</span> <span class="p">(</span><span class="s">_in_flag</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">include</span><span class="p">(</span><span class="s">FindWindowsSDK</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="c">#
</span><span class="c"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s">NOT</span> <span class="s">WINDOWSSDK_FOUND</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">message</span><span class="p">(</span><span class="s">FATAL_ERROR</span> <span class="s2">&#34;Proper Windows SDK is not found.&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">return</span><span class="p">()</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="c">#
</span><span class="c"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s">IVerbose</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WINDOWSSDK_DIRS</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WINDOWSSDK_FOUND_PREFERENCE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WINDOWSSDK_LATEST_NAME</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WINDOWSSDK_LATEST_DIR</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="c"># Update variables.
</span><span class="c"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">ODirs</span><span class="o">}</span> <span class="o">${</span><span class="nv">WINDOWSSDK_DIRS</span><span class="o">}</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">ODir</span><span class="o">}</span> <span class="o">${</span><span class="nv">WINDOWSSDK_LATEST_DIR</span><span class="o">}</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="s">_in_ODir</span> <span class="o">${</span><span class="nv">WINDOWSSDK_LATEST_DIR</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">get_windowssdk_library_dirs</span><span class="p">(</span><span class="o">${</span><span class="nv">_in_ODir</span><span class="o">}</span> <span class="s">_in_OLibDir</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">get_windowssdk_include_dirs</span><span class="p">(</span><span class="o">${</span><span class="nv">_in_ODir</span><span class="o">}</span> <span class="s">_in_OIncDir</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="nb">windowssdk_name_lookup</span><span class="p">(</span><span class="o">${</span><span class="nv">_in_ODir</span><span class="o">}</span> <span class="s">_in_ONames</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">windowssdk_build_lookup</span><span class="p">(</span><span class="o">${</span><span class="nv">_in_ODir</span><span class="o">}</span> <span class="s">_in_OBuildVers</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OBuildVers</span><span class="o">}</span> <span class="o">${</span><span class="nv">_in_OBuildVers</span><span class="o">}</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">ONames</span><span class="o">}</span> <span class="o">${</span><span class="nv">_in_ONames</span><span class="o">}</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OLibDir</span><span class="o">}</span> <span class="o">${</span><span class="nv">_in_OLibDir</span><span class="o">}</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OIncDir</span><span class="o">}</span> <span class="o">${</span><span class="nv">_in_OIncDir</span><span class="o">}</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nb">endfunction</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># @macro dy_setup_build_settings
</span><span class="c">#
</span><span class="c"># @brief Set up default build settings.
</span><span class="c">#	Every project that needs to be built should be call this macro.
</span><span class="c"></span><span class="nb">macro</span><span class="p">(</span><span class="s">dy_setup_build_settings</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;${PROJECT_NAME} is built with ${CMAKE_BUILD_TYPE} mode.&#34;</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="c"># If there are source files in /Src, add source files (.cc) but except for prefix `_` files.
</span><span class="c"></span>	<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="s">_InGetSrcs</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">file</span><span class="p">(</span>
		<span class="s">GLOB_RECURSE</span> <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="s">_InGetSrcs</span>
		<span class="s">RELATIVE</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/Src&#34;</span>
		<span class="s">CONFIGURE_DEPENDS</span> <span class="s">*.cc</span>
	<span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="c"># Check if there are `Inc` and `Inl` directory in ${CMAKE_CURRENT_SOURCE_DIR}.
</span><span class="c"></span>	<span class="nb">if</span> <span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="s">_InGetSrcs</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="c"># If exist, add target_include_directories as PUBLIC.
</span><span class="c"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s">EXISTS</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/Inc&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">target_include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s">Inc</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s">EXISTS</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/Inl&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">target_include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s">Inl</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>		<span class="c"># If exist, add target_include_directories as INTERFACE.
</span><span class="c"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s">EXISTS</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/Inc&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">target_include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">INTERFACE</span> <span class="s">Inc</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s">EXISTS</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/Inl&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">target_include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">INTERFACE</span> <span class="s">Inl</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="c"># ...To match a literal - using brackets, 
</span><span class="c"></span>	<span class="c"># make it the first or the last character e.g. [+*/-] matches basic mathematical operators.
</span><span class="c"></span>	<span class="nb">foreach</span><span class="p">(</span><span class="s">SrcItem</span> <span class="o">${</span><span class="nv">${PROJECT_NAME</span><span class="o">}</span><span class="s">_InGetSrcs}</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s2">&#34;Src/${SrcItem}&#34;</span> <span class="s">MATCHES</span> <span class="s2">&#34;/_+[a-zA-Z0-9_ -]*.cc$&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">continue</span><span class="p">()</span><span class="err">
</span><span class="err"></span>		<span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>			<span class="nb">target_sources</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PRIVATE</span> <span class="s2">&#34;Src/${SrcItem}&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="nb">endforeach</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="c"># Set CXX Properties
</span><span class="c"></span>	<span class="nb">get_target_property</span><span class="p">(</span><span class="s">CxxStdVersion</span> <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">CXX_STANDARD</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">if</span> <span class="p">(</span><span class="s">CxxStdVersion</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;${PROJECT_NAME} is built with C++${CxxStdVersion}&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">else</span> <span class="p">()</span><span class="err">
</span><span class="err"></span>		<span class="c"># -NOTFOUND 
</span><span class="c"></span>		<span class="nb">set</span><span class="p">(</span><span class="s">CxxStdVersion</span> <span class="s">17</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">set_property</span><span class="p">(</span><span class="s">TARGET</span> <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PROPERTY</span> <span class="s">CXX_STANDARD</span> <span class="s">17</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">target_compile_definitions</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s">CPP_DyCommon_VER_17</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="c"># Set properties.
</span><span class="c"></span>	<span class="nb">set_target_properties</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
		<span class="s">PROPERTIES</span>
		<span class="s">LINKER_LANGUAGE</span> <span class="s">CXX</span>
		<span class="s">CXX_STANDARD_REQUIRED</span> <span class="s">ON</span>
		<span class="s">CXX_EXTENSIONS</span> <span class="s">ON</span>
		<span class="s">ARCHIVE_OUTPUT_DIRECTORY</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/lib/${CMAKE_BUILD_TYPE}&#34;</span>
		<span class="s">LIBRARY_OUTPUT_DIRECTORY</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/lib/${CMAKE_BUILD_TYPE}&#34;</span>
		<span class="s">RUNTIME_OUTPUT_DIRECTORY</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/bin/${CMAKE_BUILD_TYPE}&#34;</span>
	<span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="c"># Add compile option flags.
</span><span class="c"></span>	<span class="nb">if</span> <span class="p">((</span>	<span class="c"># MSVC or Clang-Cl (Simulated MSVC on Clang)
</span><span class="c"></span>			<span class="o">${</span><span class="nv">CMAKE_CXX_COMPILER_ID</span><span class="o">}</span> <span class="s">STREQUAL</span> <span class="s2">&#34;Clang&#34;</span> 
			<span class="s">AND</span> <span class="s2">&#34;x${CMAKE_CXX_SIMULATE_ID}&#34;</span> <span class="s">STREQUAL</span> <span class="s2">&#34;xMSVC&#34;</span>
		<span class="p">)</span> 
		<span class="s">OR</span> <span class="o">${</span><span class="nv">CMAKE_CXX_COMPILER_ID</span><span class="o">}</span> <span class="s">STREQUAL</span> <span class="s2">&#34;MSVC&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="c"># CXX Flags.
</span><span class="c"></span>		<span class="nb">if</span> <span class="p">(</span><span class="o">${</span><span class="nv">CxxStdVersion</span><span class="o">}</span> <span class="s">EQUAL</span> <span class="s2">&#34;20&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;/std:c++latest&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>			<span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;/std:c++${CxxStdVersion}&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="c"># Additional Flags.
</span><span class="c"></span>		<span class="c"># https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html
</span><span class="c"></span>		<span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;$&lt;$&lt;CONFIG:Debug&gt;:${ComOpts_MsvcDebug}&gt;&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;$&lt;$&lt;CONFIG:Release&gt;:${ComOpts_MsvcRelease}&gt;&#34;</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="nb">elseif</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_CXX_COMPILER_ID</span><span class="o">}</span> <span class="s">STREQUAL</span> <span class="s2">&#34;Clang&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="c"># CXX Flags.
</span><span class="c"></span>		<span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;-std=c++${CxxStdVersion}&#34;</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="c"># Additional Flags.
</span><span class="c"></span>		<span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;$&lt;$&lt;CONFIG:Debug&gt;:${ComOpts_ClangDebug}&gt;&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;$&lt;$&lt;CONFIG:Release&gt;:${ComOpts_ClangRelease}&gt;&#34;</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>		<span class="nb">message</span><span class="p">(</span><span class="s">FATAL_ERROR</span> <span class="s2">&#34;This project only supports Clang/Clang-cl or MSVC compiler now.&#34;</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="c"># If windows, let project add WIN32 and D3D12 libraries.
</span><span class="c"></span>	<span class="nb">_is_windows</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="s">IsWin</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">if</span> <span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="s">IsWin</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="c"># It seems it have not to be inserted into all project when WIN.
</span><span class="c"></span>		<span class="c"># target_include_directories(${PROJECT_NAME} PRIVATE ${WinInc})
</span><span class="c"></span>		<span class="nb">target_link_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PRIVATE</span> <span class="o">${</span><span class="nv">WinLib</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="nb">target_compile_definitions</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> 
		<span class="s">PRIVATE</span> 
			<span class="s2">&#34;UNICODE&#34;</span> 
			<span class="s2">&#34;_UNICODE&#34;</span>
			<span class="s2">&#34;_CRT_SECURE_NO_WARNINGS&#34;</span>
		<span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">target_link_libraries</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> 
		<span class="s">PRIVATE</span> 
			<span class="s2">&#34;d3d12.lib&#34;</span> 
			<span class="s2">&#34;d3dcompiler.lib&#34;</span> 
			<span class="s2">&#34;dxgi.lib&#34;</span>
		<span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nb">endmacro</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># -----------------------------------------------------------------------------
</span><span class="c"># 
</span><span class="c"># MAIN ROUTINES
</span><span class="c">#
</span><span class="c"># -----------------------------------------------------------------------------
</span><span class="c"></span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_VERBOSE_MAKEFILE</span> <span class="s">true</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_MODULE_PATH</span> <span class="s2">&#34;${CMAKE_SOURCE_DIR}/Module&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">include</span><span class="p">(</span><span class="s">CMakePrintHelpers</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">include</span><span class="p">(</span><span class="s">cotire</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">_find_platform</span><span class="p">(</span><span class="s">VERBOSE,</span> <span class="s">PlatformKey</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">_check_supported_platform</span><span class="p">(</span><span class="s">PlatformKey,</span> <span class="s">IsSupportedPlatform</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">if</span> <span class="p">(</span><span class="s">IsSupportedPlatform</span> <span class="s">EQUAL</span> <span class="s">false</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">message</span><span class="p">(</span><span class="s">FATAL_ERROR</span> <span class="s2">&#34;${PlatformKey} is not supported platform.&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">_is_windows</span><span class="p">(</span><span class="s">_out_iswindows</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">if</span> <span class="p">(</span><span class="s">_out_iswindows</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">_find_winsdk</span><span class="p">(</span><span class="s">VERBOSE</span> <span class="s">WinDirs</span> <span class="s">WinBuildVers</span> <span class="s">WinName</span> <span class="s">WinDir</span> <span class="s">WinLib</span> <span class="s">WinInc</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">if</span> <span class="p">(</span><span class="s">VERBOSE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WinDirs</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WinDir</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WinLib</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WinInc</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WinName</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WinBuildVers</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c">#
</span><span class="c"># Compiler Flags
</span><span class="c">#
</span><span class="c"></span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">ComOpts_MsvcCommon</span> 
	<span class="s">/GR-</span> <span class="s">/W4</span> <span class="s">/WX</span> <span class="s">/MP</span> 
	<span class="s">-Wno-error=unused-command-line-argument</span>
	<span class="s">-Wno-error=expansion-to-defined</span>
	<span class="s">-Wno-error=ignored-pragma-intrinsic</span>
<span class="p">)</span> <span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">ComOpts_MsvcDebug</span> <span class="s">/Od</span> <span class="o">${</span><span class="nv">ComOpts_MsvcCommon</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">ComOpts_MsvcRelease</span> <span class="s">/O2</span> <span class="o">${</span><span class="nv">ComOpts_MsvcCommon</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">ComOpts_ClangCommon</span> <span class="s">-Wall</span> <span class="s">-Werror</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">ComOpts_ClangDebug</span> <span class="o">${</span><span class="nv">ComOpts_ClangCommon</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">ComOpts_ClangRelease</span> <span class="s">-O3</span> <span class="o">${</span><span class="nv">ComOpts_ClangCommon</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c">#
</span><span class="c"># Subdirectory (Need to be changed with IMPORT module.)
</span><span class="c">#
</span><span class="c"></span><span class="err">
</span><span class="err"></span><span class="nb">add_subdirectory</span><span class="p">(</span><span class="s">Engine</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">add_subdirectory</span><span class="p">(</span><span class="s">TestPrj</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">add_subdirectory</span><span class="p">(</span><span class="s">ThirdParty</span><span class="p">)</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>CMakeのメモまとめ</title>
			<link>https://liliilli.github.io/posts/cmake_memo/</link>
			<pubDate>Tue, 03 Mar 2020 23:59:05 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/cmake_memo/</guid>
			<description>https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1 Do&amp;rsquo;s and Don&amp;rsquo;ts CMakeで避けるべきのパターン https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1 link_directories、include_librariesなどのグローバル関数を使わ</description>
			<content type="html"><![CDATA[

<p><a href="https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html">https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html</a></p>

<p><a href="https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1">https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1</a></p>

<h1 id="do-s-and-don-ts">Do&rsquo;s and Don&rsquo;ts</h1>

<h2 id="cmakeで避けるべきのパターン">CMakeで避けるべきのパターン</h2>

<blockquote>
<p><a href="https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html">https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html</a><br><a href="https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1">https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1</a></p>
</blockquote>

<ul>
<li><code>link_directories</code>、<code>include_libraries</code>などのグローバル関数を使わないこと。</li>
<li><code>PUBLIC</code>はあんまり使わずにできる限り<code>PRIVATE</code>にすべき。</li>
<li>ファイルを取得するために<code>GLOB</code>を使わないこと。もしかして使わざるをえない場合には<code>CONFIGURE_DEPENDS</code>フラグを使えば使わないままに<code>GLOB</code>を使うようはうまく動作するらしい。</li>
</ul>

<p><a href="https://cmake.org/cmake/help/latest/command/file.html">公式マニュアル</a>によれば、<code>GLOB</code>は<code>&lt;globbing-expressions&gt;</code>に当てはまるファイルのリストを取得し、それを変数に入れ込むらしい。この表現式は正規表現パターンみたいな文法を持ってる。<code>GLOB</code>の詳しいことはマニュアルを見ること。</p>

<ul>
<li>リンキングする時には<code>PUBLIC/PRIVATE</code>の指定を忘れないこと。</li>
</ul>

<h2 id="cmakeでやればイイかもパターン">CMakeでやればイイかもパターン</h2>

<ul>
<li>Make <code>ALIAS</code> targets to keep usage consistent.</li>
<li>関数の名前は小文字を推薦。変数は大文字でやる方が良いらしい。</li>
<li><code>cmake_policy</code>を使うこと。<a href="https://cmake.org/cmake/help/latest/command/cmake_policy.html">「リンク」</a></li>
<li>ビルトインコマンドなどはだいたい文字の大小を区別してないが、出来れば少文字でやる方が良いらしい。</li>
</ul>

<h1 id="basics">Basics</h1>

<h2 id="最低限バージョンを指定">最低限バージョンを指定</h2>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.1</span><span class="p">)</span></code></pre></div>
<p><code>VERSION &lt;version&gt;</code>によってCMakeのコードをビルドする時の規定が決まる。一番最新のCMakeを持っているとしても上の<code>VERSION</code>の後について来る数値によってビルドが通るか否かが決まる。バージョンによるポリシー（規定・規則）の違いは<a href="https://cmake.org/cmake/help/latest/manual/cmake-policies.7.html">リンク</a>を見ること。</p>

<p>特にCMakeのバージョンが3.12にアップグレードするに連れて</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.1...3.15</span><span class="p">)</span></code></pre></div>
<p>のように<strong>範囲</strong>を決めることが出来るようになった。<br>なので厳密には上記の構文は以下のように書かなかればならないらしい。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.1...3.15</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># CMakeのバージョンが3.12より下なら、CMakeのバージョンに合うポリシーを入れてビルドを行う。
</span><span class="c"></span><span class="nb">if</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_VERSION</span><span class="o">}</span> <span class="s">VERSION_LESS</span> <span class="s">3.12</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nb">cmake_policy</span><span class="p">(</span><span class="s">VERSION</span> <span class="o">${</span><span class="nv">CMAKE_MAJOR_VERSION</span><span class="o">}</span><span class="s">.</span><span class="o">${</span><span class="nv">CMAKE_MINOR_VERSION</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<p>または<code>cmake_minimum_required</code>を使うことも出来る。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.1</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_VERSION</span><span class="o">}</span> <span class="s">VERSION_LESS</span> <span class="s">3.15</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nb">cmake_policy</span><span class="p">(</span><span class="s">VERSION</span> <span class="o">${</span><span class="nv">CMAKE_MAJOR_VERSION</span><span class="o">}</span><span class="s">.</span><span class="o">${</span><span class="nv">CMAKE_MINOR_VERSION</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>    <span class="nb">cmake_policy</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.15</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<h2 id="プロジェクトセッティング">プロジェクトセッティング</h2>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">project</span><span class="p">(</span><span class="s">MyProject</span> 
	<span class="s">VERSION</span> <span class="s">1.0</span> <span class="c"># `MyProject_Version`とか`PROJECT_VERSION`変数などに数値が更新される
</span><span class="c"></span>    <span class="s">DESCRIPTION</span> <span class="s2">&#34;Very nice project&#34;</span> <span class="c"># 3.8以降から付けられる
</span><span class="c"></span>    <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span> <span class="err">#</span> <span class="err">基本</span> <span class="err">`C</span> <span class="err">CXX`で指定されている</span></code></pre></div>
<h2 id="ターゲット-targets-をよく使うべき">ターゲット（Targets）をよく使うべき</h2>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">target_include_directories</span><span class="p">(</span><span class="s">&lt;target&gt;</span> <span class="s">PUBLIC</span> <span class="s">&lt;rel/abs_directory_path&gt;</span><span class="p">)</span></code></pre></div>
<p><a href="https://cmake.org/cmake/help/latest/command/target_include_directories.html">target_include_directories</a>コマンドは<code>target</code>にディレクトリーのパスを関連付ける。</p>

<p><code>PUBLIC</code>でできたパスの場合は、他のターゲットがこのターゲットを参照するときに、このターゲットに関連付けられたディレクトリーパスも一緒に参照するということである。<code>PRIVATE</code>にした場合には自分だけ参照して他のターゲットなどには干渉しないらしい。<code>INTERFACE</code>はヘッダー専用ライブラリーに使うものである。</p>

<p>ターゲットを別のターゲットの関連付ける時にはこう使う。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">add_library</span><span class="p">(</span><span class="s">&lt;another_target&gt;</span> <span class="s">STATIC</span> <span class="s">another.cpp</span> <span class="s">another.h</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">&lt;another_target&gt;</span> <span class="s">PUBLIC</span> <span class="s">&lt;target&gt;</span><span class="p">)</span></code></pre></div>
<p><a href="https://cmake.org/cmake/help/latest/command/target_link_libraries.html">target_link_libraries</a>は<code>&lt;another_target&gt;</code>に他のライブラリまたはターゲットを依存させる時に使う。もしターゲットがCMakeのターゲットリストで見えなかったら、ライブラリーで探してくれる。<code>&lt;target&gt;</code>ではなく、パスでも指定することが出来る。</p>

<p>ターゲットはそれぞれ<code>include_directories</code>とか<code>linked_libraries</code>などを持っているので、ターゲットの依存するスコープなどを制限したい場合に<code>PUBLIC</code>または<code>PRIVATE/INTERFACE</code>などを使うらしい。</p>

<h1 id="変数とキャッシュ">変数とキャッシュ</h1>

<h2 id="ローカル変数">ローカル変数</h2>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">set</span><span class="p">(</span><span class="s">MY_VARIABLE</span> <span class="s2">&#34;value&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">MY_LIST</span> <span class="s2">&#34;one&#34;</span> <span class="s2">&#34;two&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">MY_LIST_THAT_SAME_ABOVE</span> <span class="s2">&#34;one;two&#34;</span><span class="p">)</span></code></pre></div>
<p><code>set</code>コマンドで変数を設定し、設定した変数に接近する時には<code>${}</code>を使って値を取得出来る。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="err">${MY_LIST}</span></code></pre></div>
<p>変数のスコープは、<code>set</code>などで変数を決めてから下のディレクトリーのCMakeLists.txtファイルまで及ぶ。現在ファイルだけスコープを決めたければ、<code>set</code>コマンドで変数を設定する時に最後に<code>PARENT_SCOPE</code>を入れれば現在ファイルだけでスコープが決まるらしい。</p>

<p>またCMakeの変数はスペース（空白）文字に寄って区切られているため、空白文字が入ってそうなパスが入った変数に接近する時には、<code>&quot;&quot;</code>を付けて接近するほうが良さそうかも。</p>

<h2 id="キャッシュ変数">キャッシュ変数</h2>

<p>CMakeでビルドする時に変数の値などを決めたいなら、<strong>キャッシュ変数</strong>を使う。BOOLならば普通の<strong>OPTION</strong>でも良いが、</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">option</span><span class="p">(</span><span class="s">MY_OPTION</span> <span class="s2">&#34;This is settable from the command line&#34;</span> <span class="s">OFF</span><span class="p">)</span></code></pre></div>
<p>それじゃなく複雑な値を入れたい場合には以下のように中に<code>CACHE</code>を入れる。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">set</span><span class="p">(</span><span class="s">MY_CACHE_VARIABLE</span> <span class="s2">&#34;VALUE&#34;</span> <span class="s">CACHE</span> <span class="s">STRING</span> <span class="s2">&#34;Description&#34;</span><span class="p">)</span></code></pre></div>
<p>ただしこれじゃGUIまたは外部からCMakeをビルドする時に変数の値を変更することは出来ない。なので（１）のようにするか、それとも<code>INTERNAL</code>を使って（２）のように書いて外部から値が設定するようにするしかない。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">set</span><span class="p">(</span><span class="s">MY_CACHE_VARIABLE</span> <span class="s2">&#34;VALUE&#34;</span> <span class="s">CACHE</span> <span class="s">STRING</span> <span class="s2">&#34;&#34;</span> <span class="s">FORCE</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">mark_as_advanced</span><span class="p">(</span><span class="s">MY_CACHE_VARIABLE</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">MY_CACHE_VARIABLE</span> <span class="s2">&#34;VALUE&#34;</span> <span class="s">CACHE</span> <span class="s">INTERNAL</span> <span class="s2">&#34;&#34;</span><span class="p">)</span></code></pre></div>
<p>このキャッシュ変数を使って実装されたビルトイン変数は<a href="https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html">リンク</a>で見れる。</p>

<h2 id="properties">Properties</h2>

<p>属性（Properties）は変数と使い方は同じだが、ターゲットまたはディレクトリーにくっ付いたものである。Propertiesもグローバル属性があるんだけど、ターゲットの大体の属性は<code>CMAKE_</code>として始まる変数を見て、属性を値を埋めるように設計されているらしい。</p>

<p>例えば、<code>CMAKE_CXX_STANDARD</code>の場合にはすべてのターゲットの<code>CXX_STANDARD</code>造成の値を更新するようになっている。もしかして一つ一つ属性を付けようとしたら、以下のようにすれば良い。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">set_property</span><span class="p">(</span><span class="s">TARGET</span> <span class="s">TargetName</span>
             <span class="s">PROPERTY</span> <span class="s">CXX_STANDARD</span> <span class="s">11</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="c"># または複数で
</span><span class="c"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">TargetName</span> <span class="s">PROPERTIES</span> <span class="s">CXX_STANDARD</span> <span class="s">11</span><span class="p">)</span></code></pre></div>
<p>ターゲットから属性の値を持ってくる時には<code>get_property</code>を使う。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">get_property</span><span class="p">(</span><span class="s">ResultVariable</span> <span class="s">TARGET</span> <span class="s">TargetName</span> <span class="s">PROPERTY</span> <span class="s">CXX_STANDARD</span><span class="p">)</span></code></pre></div>
<p>属性のリストは<a href="https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html">リンク</a>で見れるらしい。</p>

<h1 id="programming-in-cmake">Programming in CMake</h1>

<h2 id="if-構文"><code>if</code>構文</h2>

<p><code>if</code>構文は変数と表現式をどう使うかによって<code>THEN</code>に入ることと<code>ELSE</code>に入ることが変わる。例えば、ある変数<code>variable</code>がある時、普通に<code>variable</code>に入れたら、</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">if</span> <span class="p">(</span><span class="s">variable</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="c"># &#39;ON&#39;, &#39;YES&#39;, &#39;Y&#39;, または０じゃない数字
</span><span class="c"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="c"># &#39;0&#39;, &#39;OFF&#39;, &#39;NO&#39;, &#39;N&#39;, &#39;IGNORE&#39;, &#39;NOTFOUND&#39;, &#39;&#34;&#34;&#39; または最後に&#39;-NOTFOUND&#39;で終わる時
</span><span class="c"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<p>ただし、検証しようとする変数がどちらに当てはまらないと、自動に<code>${variable}</code>としてまた検証を行う。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">if</span> <span class="p">(</span><span class="o">${</span><span class="nv">variable</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="c"># false-like 表現式じゃなければすべてtrueになる
</span><span class="c"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="c"># &#39;&#34;&#34;&#39; または true になれない表現式はすべてこっちへ
</span><span class="c"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<h2 id="generator-expressions">Generator-Expressions</h2>

<h2 id="マクロと関数">マクロと関数</h2>

<blockquote>
<p><a href="https://cmake.org/cmake/help/latest/command/macro.html">macro</a><br><a href="https://cmake.org/cmake/help/latest/command/function.html">function</a></p>
</blockquote>

<p><code>function</code>と<code>macro</code>はほとんど同じだが、関数は引数として入れる変数が外部から見えないようになっている。もしかし入れられた引数を結果値または関数の内部で更新したい場合には<code>PARENT_SCOPE</code>を使う。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">function</span><span class="p">(</span><span class="s">SIMPLE</span> <span class="s">REQUIRED_ARG</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">message</span><span class="p">(</span><span class="s">STATUE</span> <span class="s2">&#34;Simple arguments: ${REQUIRED_ARG}, followed by ${ARGV}&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">REQUIRED_ARG</span><span class="o">}</span> <span class="s2">&#34;From SIMPLE&#34;</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endfunction</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">simple</span><span class="p">(</span><span class="s">This</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s2">&#34;Output: ${This}&#34;</span><span class="p">)</span> <span class="err">#</span> <span class="err">Output:</span> <span class="err">From</span> <span class="err">SIMPLE</span></code></pre></div>
<p>ここで<code>${ARGV}</code>と<code>${ARGN}</code>という関数で呼べるビルトイン変数があってこれを使い渡した引数を出力することができるだろう。そして、CMakeの関数では他の言語とは違いリターン値がない。なので関数から何かを返したい場合には出力専用の引数を作ってそこに<code>PARENT_SCOPE</code>でセットすること。</p>

<h1 id="デバッグ">デバッグ</h1>

<h2 id="変数などを出力">変数などを出力</h2>

<p>普通<code>message</code>で出力することができる。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;MY_VARIABLE=${MY_VARIABLE}&#34;</span><span class="p">)</span></code></pre></div>
<p>ただし、ビルトインのモジュールを使えば<code>printf</code>でやってる感覚を無くし、よりモーダンな接近法で変数リストを出力することができる。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">include</span><span class="p">(</span><span class="s">CMakePrintHelpers</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">MY_VARIABLE</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">cmake_print_properties</span><span class="p">(</span>
    <span class="s">TARGETS</span> <span class="s">my_target</span>
    <span class="s">PROPERTIES</span> <span class="s">POSITION_INDEPENDENT_CODE</span>
<span class="p">)</span></code></pre></div>
<h2 id="デバッグモードでビルド">デバッグモードでビルド</h2>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="err">-DCMAKE_BUILD_TYPE=Debug</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Hugoブログを使いこなせるためのメモ</title>
			<link>https://liliilli.github.io/posts/hugo_memo/</link>
			<pubDate>Tue, 03 Mar 2020 23:10:28 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/hugo_memo/</guid>
			<description>すごく久しぶりにHugoのブログを使おうとしましたが、ブログに記事を書くどころかHugoの使い方すらすっかり忘れてしまいました。だもんで自分</description>
			<content type="html"><![CDATA[

<p>すごく久しぶりにHugoのブログを使おうとしましたが、ブログに記事を書くどころかHugoの使い方すらすっかり忘れてしまいました。だもんで自分用のメモみたいなことを書いていつでも覚えさせられるようにしたいと思います。</p>

<p>ちなみにブログの設定環境はWindowsです。新しくインストールするなら<code>$ brew install hugo</code>みたいなもんは当然出来ないし、Windowsのパッケージをダウンロードして設置するしかないみたいですね。</p>

<h1 id="覚えておくといい-かも-メモリスト">覚えておくといい（かも）メモリスト</h1>

<h2 id="レポジトリー登録">レポジトリー登録</h2>

<ul>
<li><p>WindowsではHugoをインストールしてから環境変数に登録する必要があります。</p></li>

<li><p>HugoはDeployで生成された本サイトページと、そのページを生成するためのリソースが一つのディレクトリの中にまとまっているので、遠隔リポジトリーなどにリソースをセーブする為には２つのリポジトリーを作ることが一番良いらしい。</p>

<ul>
<li>例えば、Hugoの本コンテンツとリソースを入れ込む用途として使う<code>&lt;YOUR-PROJECT&gt;</code>と
結果としてDeployされた<code>&lt;USERNAME&gt;.github.io</code>レポジトリ。
<br /></li>
</ul></li>

<li><p><code>&lt;YOUR-PROJECT&gt;</code>は本プロジェクトとして<br></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git remote add origin git@github.com:integerous/blog.git</code></pre></div></li>

<li><p><code>&lt;USERNAME&gt;.github.io</code>はSubmoduleとして登録する。<br></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git submodule add -b master <span class="se">\
</span><span class="se"></span>git@github.com:integerous/integerous.github.io.git public</code></pre></div></li>
</ul>

<p>上記のようにすることで<code>public</code>っていうDeployされた時に作られるウェブサイトフォルダーは本プロジェクトとは違って<code>&lt;USERNAME&gt;.github.io</code>を持つことになる。</p>

<h2 id="コンテンツ生成">コンテンツ生成</h2>

<ul>
<li>コンテンツ生成はブログのフォルダーから<code>$ hugo new posts/test1.md</code>みたいなコマンドを売ってファイルを生成する。Draftで生成したい場合には<code>-D</code>を最後につける。</li>
<li>コンテンツをローカルで見る為には<code>hugo server</code>または<code>hugo server -D</code>で確認できる。</li>
</ul>

<h2 id="コンテンツアップロード">コンテンツアップロード</h2>

<ol>
<li>まず<code>$ hugo -t テーマの名前</code>で設置されたテーマが適用されたコンテンツを<code>public</code>フォルダーに生成。</li>
<li><code>public</code>フォルダーに移動し、gitなどで<code>&lt;USERNAME&gt;.github.io</code>にコミットする。</li>

<li><p>ルートフォルダーに戻り、生リソースを<code>&lt;YOUR-PROJECT&gt;</code>にコミットする。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git push origin master</code></pre></div></li>
</ol>

<h1 id="最後に">最後に</h1>

<p>ちなみにほぼ３ヶ月ぐらい放置してたブログをまだ使おうとしたのは、個人プロジェクトの<code>CMakeLists.txt</code>を削除してしまい、また書こうとしても<code>CMake</code>なんてすっかり忘れてしまってブログにメモとりながら再実装する必要があったからです。これで一日無駄使いしてしまいWINAPIのFiberのサンプルを書く時間なんてなくなってしまいました。</p>

<p>ソースコードはちゃんとバックアップしましょうね。</p>

<h1 id="リンク">リンク</h1>

<p><a href="https://github.com/Integerous/Integerous.github.io">Hugo로 Github.io 블로그 만들기</a></p>
]]></content>
		</item>
		
		<item>
			<title>C&#43;&#43;2aのconceptsを使ってみた。</title>
			<link>https://liliilli.github.io/posts/cpp_concept/</link>
			<pubDate>Thu, 21 Nov 2019 20:33:04 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/cpp_concept/</guid>
			<description>C++のConceptを簡略説明 C++2a（20）から追加する文法の一つであるconceptは、あるタイプの制約条件を記すことができる識別子</description>
			<content type="html"><![CDATA[

<h1 id="c-のconceptを簡略説明">C++のConceptを簡略説明</h1>

<p>C++2a（20）から追加する文法の一つである<code>concept</code>は、あるタイプの制約条件を記すことができる識別子です。制約条件というのは<code>Constraints</code>と呼びますが、あくまでも付与された<code>concept</code>を満足するための一連の条件組だと言えます。以下はある<code>concept</code>を宣言するコードです。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">is_floating_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<p>注意することは、宣言したconceptは、他のconceptを宣言する時に型引数で<code>typename</code>または<code>class</code>の代わりに使うことはできません。また、<code>requires</code>を使うこともできません。ただし、定義する構文で使うことはできます。</p>

<p>constraintsはconceptだけじゃなくて、<code>requires</code>文法を使ってタイプの条件を設定することができます。C#に例えたら、多分<code>where</code>が一番近いんじゃないかな？と思いますね。下はconceptを使わずにconstraintsだけを使っているコードです。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// First syntax of `requires` and `constraints`
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go3</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">v2</span><span class="p">)</span> <span class="k">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>宣言したconceptは次のように使えます。conceptじゃない構文であれば、<code>typename</code>と<code>class</code>の代わりに使えることがわかります。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="n">is_floating_point</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go4</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>ただし、上のコードではあくまでも<code>v1</code>と<code>v2</code>が<code>Float</code>という型に縛られているので、<code>v1</code>に<code>double</code>を入れたり<code>v2</code>に<code>float</code>を入れてコンパイルすることはできません。下のコードでは、上記の問題点を解決するため<code>template</code>を使わず、conceptを型として使います。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">auto</span> <span class="nf">go5</span><span class="p">(</span><span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>[const/volatile] concept auto [&amp;, &amp;&amp;]</code>を使うことで<code>v1</code>と<code>v2</code>のタイプは別々のタイプが持てるようになります。実はリターン型<code>auto</code>の前にもconceptをくっつけることが出来ます。</p>

<p>最後に、変数にもconceptが使えます。<code>auto</code>を一緒に使いますが、前にconceptを書けることでタイプ自体じゃなくてできる行動・特性をもつタイプの一連として考えるようになり、もっと柔軟なロジックを組むことが出来ます。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//floating_point auto val2 = go6(1.2f, 3.4f); 
</span><span class="c1">// go6は`int`を返しますが、`int`はfloating_pointコンセプトの条件が満たしていないので
</span><span class="c1">// コンパイルエラーが出ます。
</span><span class="c1"></span><span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">val3</span> <span class="o">=</span> <span class="n">go5</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>
</code></pre></div>
<h1 id="もっと詳しく知りたい方へ">もっと詳しく知りたい方へ</h1>

<p>上の説明は、<code>concept</code>と<code>requires</code>、そして条件構文でできることの一部しか紹介していません。詳しく知りたい型には以下の文書をお読みいただけましたら嬉しいです。</p>

<p><a href="https://en.cppreference.com/w/cpp/language/constraints">https://en.cppreference.com/w/cpp/language/constraints</a></p>

<p>また、C++のコードがウェブで作成できるCompiler Explorerというサイトで、gcc (trunk)またはclang (concepts)を選択しましたら<code>concept</code>が実装されたバージョンでコードが組めることが出来ます。</p>

<h1 id="full-code">Full code</h1>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go1</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">value1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">value2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">Float</span><span class="p">,</span>
    <span class="k">typename</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;&gt;</span>
<span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go2</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">value1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">value2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// First syntax of `requires`.
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go3</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">v2</span><span class="p">)</span> 
    <span class="k">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Using concept instead of typename or class in template.
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">is_floating_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">is_floating_point</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go4</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">floating_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// We can write `floating_point` explicitly before `auto` return.
</span><span class="c1">// When `floating_point` is written before auto, return value should
</span><span class="c1">// satisfy `floating_point` constraint.
</span><span class="c1"></span><span class="k">auto</span> <span class="nf">go5</span><span class="p">(</span><span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="nf">go6</span><span class="p">(</span><span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="kt">int</span><span class="p">{</span><span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">};</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//go1(1, 2.3);
</span><span class="c1"></span>    <span class="c1">//go1(1.2f, 2.3);
</span><span class="c1"></span>    <span class="n">go1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>          <span class="c1">// Float is int.
</span><span class="c1"></span>    <span class="n">go1</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">2.3f</span><span class="p">);</span>    <span class="c1">// Float is float.
</span><span class="c1"></span>    <span class="n">go1</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">);</span>      <span class="c1">// Float is double.
</span><span class="c1"></span>
    <span class="c1">//go2(1, 2);        // Substitution is failed, and output message is bizzare.
</span><span class="c1"></span>    <span class="n">go2</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">);</span>      <span class="c1">// Float is double.
</span><span class="c1"></span>
    <span class="c1">// Substitution is failed 
</span><span class="c1"></span>    <span class="c1">// but output message is humble and more readable.
</span><span class="c1"></span>    <span class="c1">//go3(1, 2);
</span><span class="c1"></span>    <span class="c1">//go3(1, 2.3);
</span><span class="c1"></span>    <span class="n">go3</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>        

    <span class="c1">// constraints not satisfied
</span><span class="c1"></span>    <span class="c1">//go4(1, 10);
</span><span class="c1"></span>    <span class="c1">// Also need one uniformed type.
</span><span class="c1"></span>    <span class="c1">// template argument deduction/substitution failed:
</span><span class="c1"></span>    <span class="c1">//go4(1.2f, 3.4);     
</span><span class="c1"></span>    <span class="n">go4</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>
    <span class="n">go4</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>

    <span class="c1">// error: use of function &#39;auto go5(auto:1, auto:2) 
</span><span class="c1"></span>    <span class="c1">// [with auto:1 = int; auto:2 = int]&#39; with unsatisfied constraints
</span><span class="c1"></span>    <span class="c1">//go5(1, 10);
</span><span class="c1"></span>    <span class="n">go5</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>
    <span class="n">go5</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>
    <span class="n">go5</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>
    <span class="n">go5</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">val1</span> <span class="o">=</span> <span class="n">go6</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span> <span class="c1">// This outputs warning but not error,
</span><span class="c1"></span>    <span class="c1">// But below is failed to compile.
</span><span class="c1"></span>    <span class="c1">// &lt; constraints not satisfied
</span><span class="c1"></span>    <span class="c1">// &lt; the expression &#39;is_floating_point_v&lt;T&gt;&#39; evaluated to &#39;false&#39;
</span><span class="c1"></span>    <span class="c1">//floating_point auto val2 = go6(1.2f, 3.4f);
</span><span class="c1"></span>    <span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">val3</span> <span class="o">=</span> <span class="n">go5</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>
    <span class="k">return</span> <span class="kt">int</span><span class="p">{</span><span class="n">val3</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>ShaderToyでPBRを書いてから、自ら解説してみた。</title>
			<link>https://liliilli.github.io/posts/shadertoy_pbr/</link>
			<pubDate>Sat, 16 Nov 2019 19:51:58 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/shadertoy_pbr/</guid>
			<description>実は2週前に、ShaderToyというウェブでGLSLがかけて、それをレンダリングすることができるサイトで、上のシェーダーを書いてました。前</description>
			<content type="html"><![CDATA[

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/WsdSDf?gui=true&t=10&paused=true&muted=false" allowfullscreen></iframe>
実は2週前に、ShaderToyというウェブでGLSLがかけて、それをレンダリングすることができるサイトで、上のシェーダーを書いてました。前にもShaderToyで色々と書いたんですが、PBRを本格に適用して書いたのは今が初めてです。</p>

<p>なんで、このシェーダーを書きながら、どうやってPBRのDiffuseとSpecularを実装したのかを簡単と大雑把に書きたいと思います。図形の作り方、またはレイマーチングのやり方に関しては説明いたしません。</p>

<h1 id="本編">本編</h1>

<p>PBRレンダリングを勉強するときによく見られるDisneyの<code>Physical-Based Shading at Disney</code>、または色々のPBRが基づく理論文書を読みますと、光と視点のよるある地点の色は以下になります。</p>

<p>$$
f(\pmb{l}, \pmb{v}) = \text{diffuse} + \text{specular}
$$
<code>Diffuse</code>と<code>Specular</code>はそれぞれの特性を独立的に持てると言えます。なので、実施に最終色を入れるときに次のように単純に<code>Diffuse</code>と<code>Specular</code>を入れます。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="c1">// fragColorは[0,1]のvec4(R,G,B,A)です。</span>
<span class="n">fragColor</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">dif</span> <span class="o">+</span> <span class="n">spc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></code></pre></div>
<blockquote>
<p>$$ f(\pmb{l}, \pmb{v}) $$ は実際には色そのまのを表してはいません。あくまでBRDF（Bidirectional-Reflectance Distribution Funciton）のモデルを表したものであり、実際にはぶつかった入射光線と表面の法線での半球で、すべての反射光線がどの角度とエナジーを持つのかを調べて、全部合わせないと正確な数値が計算できません。</p>

<p>ただし、今はもっと抽象化した数式を使ってレンダリングをしようとします。リアルタイムで完全な数式を解いて色を得ることはほぼ不可能だし、もっと抽象化したモデルでもだいたい通じます。</p>
</blockquote>

<h2 id="diffuse">Diffuse</h2>

<p>普通よく使うのは<code>Lambertian</code>ですが<code>Oren-Nayar</code>っていう、もっと正確なPBRモデルもあります。僕は最初は<code>Lambertian</code>を使いましたが、最終は<code>Oren-Nayar</code>にしました。</p>

<h3 id="lambertian">Lambertian</h3>

<p>$$
f(\pmb{l}, \pmb{v}) = \frac{\rho_{ss}}{\pi}
$$</p>

<p><code>Diffuse</code>モデルの中で一番簡単なモデルです。色だけでモデルBRDFが決まりますし、だとしてもそれっぽく見えるようになるので普通のゲームでもよく使います。</p>

<p>ここで
$$
\rho_{ss}
$$
は、表面のアルベド（物体が光を弾いたときの反射率）を表します。これだけがLambertianのモデルの数値になります。</p>

<p>下のコードはLambertianモデルを使って、実際のピクセルのカラーを表現するコードです。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">FactorDiffLambertian</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">/</span> <span class="n">pi</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">vec3</span> <span class="n">DiffuseLambertian</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> 
                       <span class="k">in</span> <span class="k">vec3</span> <span class="n">diffuse</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">ambient</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mix</span><span class="p">(</span><span class="n">ambient</span><span class="p">,</span> <span class="n">diffuse</span><span class="p">,</span> <span class="n">FactorDiffLambertian</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>注意するとこは、<code>FactorDiffLamberitan</code>の中の<code>dot(l, n)</code>は実際はLambertianのモデルの数式に含まれていません。<code>mix(ambient, diffuse, ...)</code>の<code>diffuse</code>が上記の
$$
\rho_{ss}
$$
になります。
そして、<code>FactorDiffLambertian</code>関数は、以下の数式
$$
L_o(\mathbf{v}) = \int_{\mathbf{l}\in\Omega}{f(\mathbf{l}, \mathbf{v})L_i(\mathbf{l})(\mathbf{n}\cdot\mathbf{l})d\mathbf{l}}
$$
の<code>dot(l, n)</code>項を表しています。（ただし、πは事前に入れときました。反省するとこですね。）</p>

<p>このモデルの特徴は表面が平坦だと見なしてレンダリングを行うところです。Roughnessが関与するとこが無く、単純にアルベドと光と表面の法線ベクトルによる明度だけをレンダリングします。ということで、ちょっと単純だけどコストが速いし、それなりにごまかせば他のモデルとあんまり違いは出ないと思います。</p>

<h3 id="oren-nayar">Oren-Nayar</h3>

<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model">https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model</a>
<a href="https://mimosa-pudica.net/improved-oren-nayar.html">https://mimosa-pudica.net/improved-oren-nayar.html</a></p>
</blockquote>

<p>このモデルは上のLambertianとは違って、表面の粗さによって明度の違いのレンダリングを調節できます。Oren-Nayarとともに表面の粗さによるDiffuseレンダリングモデルを総じて、<code>Rough-surface diffuse BRDF</code>と呼びます。</p>

<p>とりあえずOren-Nayarは論文をみますとFull-Model（完全モデル）とQuantitive-Model（ある程度省略したモデル）に分かれています。ウィキペディアに乗っているのはQuantitive-Modelだし、僕もフールモデルじゃなくてQuantitive-Modelを使ってOren-Nayarを実装してます。</p>

<p>Oren-Nayar（Quantitiveバージョン）は以下の数式となります。
$$
\begin{align}
L_{r} &amp;=
    \frac{\rho}{\pi}
    \cdot (\mathbf{l} \cdot \mathbf{n})
    \cdot (A + (B \cdot \max[0, \cos(\phi_{i} - \phi_{v})]
        \cdot \sin\alpha
        \cdot \tan\beta))
    \cdot E_0
\\<br />
A &amp;= 1 - 0.5\frac{\sigma^2}{\sigma^2 + 0.33}
\\<br />
B &amp;= 0.45 \frac{\sigma^2}{\sigma^2 + 0.09}
\\<br />
\alpha &amp;= \max(
    \theta_{\mathbf{l} \cdot \mathbf{n}},
    \theta_{\mathbf{v} \cdot \mathbf{n}})
\\<br />
\beta &amp;= \min(
    \theta_{\mathbf{l} \cdot \mathbf{n}},
    \theta_{\mathbf{v} \cdot \mathbf{n}})
\end{align}
$$
しかし僕は2番目のリンクにあるベクトルを使った数式を使いました。
$$
\begin{align}
L_o &amp;= \frac{\rho}{\pi}\cdot(\mathbf{l}\cdot\mathbf{n})(A + B\frac{\mathbf{s}}{t})
\\<br />
s &amp;= \mathbf{l}\cdot\mathbf{v} - (\mathbf{n}\cdot\mathbf{l})(\mathbf{n}\cdot\mathbf{v})
\\<br />
t &amp;=
\begin{cases}
1 &amp; \text{if $s \le 0$} \\<br />
\max(\mathbf{n}\cdot\mathbf{v}, \mathbf{n}\cdot\mathbf{l}) &amp; \text{if $s \gt 0$}
\end{cases}
\\<br />
A &amp;= (1 - 0.5\frac{\sigma^2}{\sigma^2 + 0.33} + 0.17\rho\frac{\sigma^2}{\sigma^2 + 0.13})
\\<br />
B &amp;= 0.45\frac{\sigma^2}{\sigma^2 + 0.09}
\end{align}
$$
なぜなら、上の数式を直接反映してみたらところどころでバグによる明るい曲線が見えるからです。多分<code>tan()</code>項でバグったりして不具合が描画されると思いますが、直せずに下のベクトル形態の数式を使ってOren-NayarのQuantitive-Modelを実装しました。</p>

<p>数式で見れる<code>\rho</code>（$ \rho $ ）はアルベドを表します。普通Lamberitanのアルベドのように、アルベドカラーを入れます。そして<code>\sigma</code>（$ \sigma $）は表面の粗さ（Roughness）を示します。だいたい０～１の値を持ちます。</p>

<p>上の数式を表したコードは下にあります。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">OrenNayarAlpha</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">OrenNayarBeta</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mix</span><span class="p">(</span>
        <span class="mf">1.</span><span class="n">f</span><span class="p">,</span>
        <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)),</span>
        <span class="n">step</span><span class="p">(</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">OrenNayarAlpha</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">OrenNayarA</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">-</span> <span class="mf">0.5</span><span class="n">f</span> <span class="o">*</span> <span class="p">(</span>
         		<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
    <span class="o">/</span> <span class="c1">// ----------------------</span>
        	<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.33</span><span class="n">f</span><span class="p">)</span>           
    <span class="p">)</span>
    <span class="o">+</span> <span class="mf">0.17</span><span class="n">f</span> <span class="o">*</span> <span class="p">(</span>
        		<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
    <span class="o">/</span> <span class="c1">// ----------------------</span>
        	<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.13</span><span class="n">f</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">OrenNayarB</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mf">0.45</span><span class="n">f</span> <span class="o">*</span> <span class="p">(</span>
         		<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
    <span class="o">/</span> <span class="c1">// ----------------------</span>
        	<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.09</span><span class="n">f</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">FactorDiffOrenNayar</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">float</span> <span class="n">A</span>  	<span class="o">=</span> <span class="n">OrenNayarA</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    <span class="k">float</span> <span class="n">B</span> 	<span class="o">=</span> <span class="n">OrenNayarB</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    <span class="k">float</span> <span class="n">_a</span> 	<span class="o">=</span> <span class="n">OrenNayarAlpha</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">float</span> <span class="n">_b</span> 	<span class="o">=</span> <span class="n">OrenNayarBeta</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">FactorDiffLambertian</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span> <span class="o">*</span> <span class="p">(</span><span class="n">_a</span> <span class="o">/</span> <span class="n">_b</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">vec3</span> <span class="n">DiffuseOrenNayar</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> 
                      <span class="k">in</span> <span class="k">vec3</span> <span class="n">diffuse</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">ambient</span><span class="p">,</span> 
                      <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mix</span><span class="p">(</span><span class="n">ambient</span><span class="p">,</span> <span class="n">diffuse</span><span class="p">,</span> <span class="n">FactorDiffOrenNayar</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>一気にコードの量が増えましたが、分析していただきましたら大したものはないことがわかります。</p>

<p>実は、2番目のリンク先で投稿した方の改良したOren-Nayarモデルも実装はしたんですが、光が表面全体を照らすときの描画が好きじゃなかったので断念してOren-NayarのQuantitive-Modelを最終採用しました。</p>

<h2 id="specular">Specular</h2>

<p>SpecularのBRDFも、上のDiffuseのようにMicrofacet理論に基づいたモデルを使っています。Specular（ハイライト）は、Diffuseとは違ってカメラの目線によってある位置にハイライトの陰影がつけられるかが異なります。（なんで、Lambertianみたいな単純なモデルは無いです）</p>

<p>普通に使ってるPBRのSpecularモデルは、以下の<strong>Cook-Torrance Model</strong>です。
$$
f_{spec}(\mathbf{l}, \mathbf{v}) = \frac
    {F(\mathbf{h}, \mathbf{l})G_{2}(\mathbf{l},\mathbf{v},\mathbf{h})D(\mathbf{h})}
    {4|\mathbf{n}\cdot\mathbf{l}||\mathbf{n}\cdot\mathbf{v}|}
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">cn</span> <span class="o">=</span> <span class="mf">4.</span><span class="n">f</span> <span class="o">*</span> <span class="n">max</span><span class="p">(</span><span class="mf">.25</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ld</span><span class="p">))</span> <span class="o">*</span> <span class="n">max</span><span class="p">(</span><span class="mf">.25</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="n">fwd</span><span class="p">));</span>
            
<span class="k">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">GTR</span><span class="p">(</span><span class="mi">9</span><span class="n">e</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="n">kBx1</span><span class="p">.</span><span class="n">mRough</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="mf">2.</span><span class="n">f</span><span class="p">);</span>
<span class="k">float</span> <span class="n">f</span> <span class="o">=</span> <span class="n">Schlick</span><span class="p">(</span><span class="n">kBx1</span><span class="p">.</span><span class="n">mR0</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
<span class="k">float</span> <span class="n">g</span> <span class="o">=</span> <span class="n">SeparableMaskingShadowing</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">kBx1</span><span class="p">.</span><span class="n">mRough</span><span class="p">);</span>
            
<span class="n">spc</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">f</span> <span class="o">*</span> <span class="n">g</span> <span class="o">/</span> <span class="n">cn</span><span class="p">;</span></code></pre></div>
<h3 id="fresnel-reflection">Fresnel Reflection</h3>

<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Fresnel_equations">https://en.wikipedia.org/wiki/Fresnel_equations</a>
<a href="https://en.wikipedia.org/wiki/Schlick%27s_approximation">https://en.wikipedia.org/wiki/Schlick%27s_approximation</a></p>
</blockquote>

<p>上記のCook-Torrance Modelにて、分子の
$$
F(\mathbf{h}, \mathbf{l})
$$
はフレネルの式を示します。要するに、光の入射光線がある物体の表面にぶつかるときの正反射率を表す数式です。全ての物質は自分のIOR（屈折率）と外部のIORによってそれぞれ違う反射率を持ちます。</p>

<p>ウィキペディアを見ていただきますと正確な数式がありますが、CGでシェーダープログラムにフレネルの式の全部をやらせるには負担がかかりすぎます。なので、下の単純なモデルを使いながらある程度フレネルの式を従います。
$$
F(\mathbf{h}, \mathbf{l}) \approx F_0 + (1 - F_0)(1 - (\mathbf{h}\cdot\mathbf{l})^+)^5
$$
この数式は<strong>Schlick-Approximation</strong>と言います。空気中の物質に対するフレネルの式の数値を得たいときの使います。もちろん、抽象化されたモデルなので正確ではありません。ですがフレネルの式の数値のグラフでの変動をある程度沿っています。</p>

<p>ここで、
$$
F_0
$$
は垂直入射の時のFresnel反射係数の実部です。この数値はRGBまたは普通のグレースケールの数値として入れられます。グレースケールになる場合には、物質が金属ではない場合で使えます。RGBは金属の物質のフレネルの数値を求めたい場合に使えます。（大雑把でしたけど、もっと詳しくお調べしたい方々は*Real-Time Rendering 4th*のChapter9をお読みくださいませ）
$$
\mathbf{h} = \text{normalize($\mathbf{l} + \mathbf{v}$)}
$$
<code>h</code>はハーフウェイベクトル（Halfway Vector）と言います。DiffuseとSpecularを一つに統合したレンダリングモデルである、Blinn-Phong Reflectance Modelでも使うやつです。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">Schlick</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r0</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">r0</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">r0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)),</span> <span class="mf">5.</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// または</span>

<span class="k">float</span> <span class="n">Schlick</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r0</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">td</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">r0</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">r0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="n">cos</span><span class="p">(</span><span class="n">td</span><span class="p">)),</span> <span class="mf">5.</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>上のコードはSchlick Approximationを2つのバージョンで実装したものです。下のバージョンの<code>td</code>は、<code>n</code>と<code>v</code>の角度差を表します。</p>

<h3 id="normal-distribution-function">Normal Distribution Function</h3>

<p>法線分布関数だと呼ばれる<strong>Normal Distribution Function</strong>は、微小面の法線がどうやって分布されているかを示す関数です。この関数は統計的に測定されて使っているか、それともある抽象化した数学関数を用いて使います。詳しくはmicrofacet理論の触れますので割愛します。</p>

<p>ですけどこのNDFに特徴の一つは、あるNDF関数があって、そしてある表面の法線ベクトル <code>N</code> があった時に、球面を覆う単位ベクトルを入れたNDFの値の積分は、<code>N</code> を持つ微細表面の面積になります。ということで、
$$
\int_{\mathbf{m} \in \Theta} {D(\mathbf{m})(\mathbf{n} \cdot \mathbf{m})d\mathbf{m}} = 1
$$
になります。</p>

<p>また、カメラまたは目線のベクトル<code>v</code>があるとき、ある表面の法線ベクトルが<code>n</code>で、そして微細表面の球体の単位ベクトルが<code>m</code>だとしたら、
$$
\int_{\mathbf{m} \in \Theta}{D(\mathbf{m})(\mathbf{v}\cdot\mathbf{m})d\mathbf{m}} = \mathbf{v}\cdot\mathbf{n}
$$
です。目によって実際に見える微小面の面積は微小面の凸凹の法線ベクトルたちを目線のベクトルとの内積し、結果値を全部足したのと同じです。<code>v * m</code>で目に見えない微小面はなくなりまし、見える表面は残ります。</p>

<p>一応これもリアルタイムでは計算しにくいので、上の特性から派生した様々な抽象化したモデルがあります。僕はDisney BRDFで使った<strong>GTR (Generalized-Trowbridge-Reitz）</strong>モデルを使いました。このモデルはGGX（Trowbridge-Reitz）モデルを一般化したものです。
$$
D_{GTR} = \frac{c}{(a^2\cos^2(\theta_{h})+\sin^2(\theta_{h}))^\gamma}
$$</p>

<blockquote>
<p>実はこの数式も実使用で使うために簡略化された数式です。Realtime-RenderingでGTRの完全数式を見てみますと結構ひどいです。（白目）</p>
</blockquote>

<p>上の数式で、<code>gamma</code>が2ならGGXと同じになります。以下はGTRをコードに写したものです。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">GTR</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">c</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">dh</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">gamma</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> 
        						 <span class="n">c</span>
    <span class="o">/</span> <span class="c1">//--------------------------------------------------------</span>
        <span class="n">pow</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">dh</span><span class="p">),</span> <span class="n">gamma</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h3 id="joint-masking-shadowing-function">Joint Masking Shadowing Function</h3>

<p>Joint Masking Shadowing Functionを説明する前に、簡単に一般Masking Function <code>G</code>を説明させていただきたいと思います。日本語でいうと<strong>幾何減衰項</strong>（読み方はわかりません）と言います。Masking Functionは微小面（Microfacet）によって発生するシャドウィング（自己陰影）、マスキング（自己遮蔽）を表したものです。</p>

<p>幾何減衰項は上で説明したNDFに（法線分布関数）と密接に関連されます。上の表面の法線・微小面の法線・目線の法線との関係がある数式は、以下のように変形できます。
$$
\int_{\in\Theta}{G_1(\mathbf{m}, \mathbf{v})D(\mathbf{m})(\mathbf{v}\cdot\mathbf{m})^+d\mathbf{m}} = \mathbf{v}\cdot\mathbf{n}
$$
ここで <code>G_1(m, v)</code>は<strong>Smith Function</strong>といい、<code>v</code>に対して見える<code>m</code>の比率を表します。ですけど、G1は実際には<code>m</code>が目線の反対方向を向いていなければ、G1の数値に全然影響がない特徴を持ちます。なのでSmith Function G1の数式は
$$
G_1(\mathbf{m}, \mathbf{v}) = \frac{\chi^+(\mathbf{m}\cdot\mathbf{v})}{1 + \Lambda(\mathbf{v})}
$$
となります。コードでは上の分子の項は、<code>m</code>と<code>v</code>の内積が0より大きければ1として置換できます。ですがこれをこのまま使うのではなく、BRDFを建てる時には以下のようにG1の代わりにG2を使います。
$$
f(\mathbf{l}, \mathbf{v}) =
    \int_{\mathbf{m}\in\Theta}
        f_{\mu}(\mathbf{l}, \mathbf{v}, \mathbf{m})
        G_2(\mathbf{l}, \mathbf{v}, \mathbf{m})
        D(\mathbf{m})
        \frac{(\mathbf{m}\cdot\mathbf{l})^+}{|\mathbf{n}\cdot\mathbf{l}|}
        \frac{(\mathbf{m}\cdot\mathbf{v})^+}{|\mathbf{n}\cdot\mathbf{v}|}
        d\mathbf{m}
\\<br />
\\<br />
G_2(\mathbf{l}, \mathbf{v}, \mathbf{m}) =
    G_1(\mathbf{v}, \mathbf{m})
    G_1(\mathbf{l}, \mathbf{m})
$$
上のG2の形以外に、様々な変形数式が存在します。G1を2つくっつけて掛け算する数式が一番だったりしますが、不具合が存在しますので下のも使われるそうです。（下は*Smith Height-Correlated Masking-Shadowing Function*）と言います。
$$
G_2(\mathbf{l}, \mathbf{v}, \mathbf{m}) = \frac{\chi^+(\mathbf{v}\cdot\mathbf{m})\chi^+(\mathbf{l}\cdot\mathbf{m})}{1 + \Lambda(\mathbf{v}) + \Lambda(\mathbf{l})}
$$
僕は一番簡単な分離型G2を使いました。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">Lambda</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">rad</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> 
        <span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="n">f</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span><span class="n">f</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="n">f</span> <span class="o">/</span> <span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span><span class="n">f</span><span class="p">)))</span> <span class="o">*</span> <span class="mf">.5</span><span class="n">f</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">SmithMasking</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">rad</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span>
        		<span class="mf">1.</span><span class="n">f</span>
    <span class="o">/</span> <span class="c1">//-----------------------</span>
        <span class="p">(</span><span class="mf">1.</span><span class="n">f</span> <span class="o">+</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">rad</span><span class="p">,</span> <span class="n">r</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">SeparableMaskingShadowing</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">tl</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">tv</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">SmithMasking</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">SmithMasking</span><span class="p">(</span><span class="n">tv</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h1 id="まとめ">まとめ</h1>

<p>以上、大雑把にコードを振り返りながらPBRの書き方、中身についてメモをしてみました。</p>

<h1 id="もっと詳しく調べたい方に">もっと詳しく調べたい方に</h1>

<ul>
<li><a href="https://qiita.com/mebiusbox2/items/1cd65993ffb546822213">https://qiita.com/mebiusbox2/items/1cd65993ffb546822213</a></li>

<li><p><a href="https://qiita.com/mebiusbox2/items/8db00cdcaf263992a5ce">https://qiita.com/mebiusbox2/items/8db00cdcaf263992a5ce</a></p></li>

<li><p><a href="https://qiita.com/emadurandal/items/3a8db7bc61438245654d">https://qiita.com/emadurandal/items/3a8db7bc61438245654d</a></p></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Chained-Group Allocationパターンについてメモ</title>
			<link>https://liliilli.github.io/posts/chained-group-allocation/</link>
			<pubDate>Sat, 09 Nov 2019 22:15:34 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/chained-group-allocation/</guid>
			<description>https://www.plflib.org/chained_group_allocation_pattern.htm を見て、分かったことをメモしたいと思います。 Abstract Chanined-Group Allocationパターンは、ダブルリンクリストを拡張して、書くノードは付加的な情報を持</description>
			<content type="html"><![CDATA[

<p><a href="https://www.plflib.org/chained_group_allocation_pattern.htm">https://www.plflib.org/chained_group_allocation_pattern.htm</a><br>を見て、分かったことをメモしたいと思います。</p>

<h2 id="abstract">Abstract</h2>

<p><strong>Chanined-Group Allocation</strong>パターンは、ダブルリンクリストを拡張して、書くノードは付加的な情報を持ちながらメモリを動的に確保して使わせるパターンです。書くノードは２の二乗バイトのメモリを持ち、もしいま使っているノードが全部埋まったら、次のメモリを持つノードのメモリ量は今までのメモリ量を合わせた分になります。</p>

<h2 id="description">Description</h2>

<p>このパターンは、どれぐらいのメモリが必要になるかが事前にわからないときに使えるパターンだそうです。といったら、<code>std::vector&lt;T, A&gt;</code> とはあんまり変わらないじゃないのと思うかもしれないんですが、動的にメモリを管理して、拡張または縮小するのは同じだけれども、具体的には違うそうです。</p>

<p><code>std::vector&lt;T, A&gt;</code> の場合には、メモリが必ず一列になる必要があります。たとえ、あるベクターがあるメモリを持っているとして、もしメモリを拡張しなければならない場合には全体メモリを他のより広いメモリに移す作業を行いますね。しかし、今のパターンはメモリをまた再割当てせずに、新しいインスタンスの確保のためのメモリ空間を割り当てて、リンクリストのポインターに繋げることで拡張を行います。</p>

<p>このパターンでは「メモリブロック」（または空間を指しているポインター）と「メモリブロックに関しての様々な情報」をまとめて「グループ」と言います。情報の中にはダブルリンクリストを構成するための前のメモリノードと後のメモリノードへのポインターが必ず入ります。それ以外に、今ノードが持っているメモリブロックに何個まで入れるか、何個入ったか、Skipfieldなどなどが入りそうです。</p>

<blockquote>
<p>Skipfieldは後の<code>Colony</code>コンテナーを説明するときに説明したいと思います。</p>
</blockquote>

<p>Abstractで書いたように、各ノードは２の二乗バイトのメモリを持ちます。例えば、１番目のブロックが<code>int</code>で8個を持っているとしたら（32Bytes）、次のブロックはまた8個（32Bytes）、そして次々のブロックは1番目と2番目のブロックを足した分の16個（64Bytes）のメモリを持つようにします。で、4番目のブロックは8＋8＋16＝32個が入れるメモリ領域を持つでしょう。</p>

<h2 id="advantages">Advantages</h2>

<p><code>std::vector</code>のような連続メモリとは違って、メモリ領域がリンクリストとして連結していることによって、イテレータとポインターを持っているときに、コンテナーにインスタンスを挿入することでの無効化（Invalidation）が起こらなくなります。</p>

<p>そしてメモリ確保を個別にやってからリンクリストとして連結することで、Resizeなどの関数でよく起こりうるメモリ再確保⇒存在しているインスタンスのコピーまたはムーブコストが発生しなくなります。こうすることで要素（インスタンス）を追加する時の副作用コストが顕著に減ります。（削除する時にもメモリを解除して、リンクリストから除外させれば終わりなんでこれも速いです。）</p>

<p>また、Groupを静的のリストの形として管理したら、Groupのための動的メモリ確保をすることが省きそうなので一部状況ではもっと速く動作すると思われます。</p>

<h2 id="disadvantages">Disadvantages</h2>

<p>メモリ確保がリンクリストとして管理されるので、<code>std::vector</code>のような連続メモリに対してはイテレーターが一回りする速度は遅くなるかもしれません。特に、確保したメモリの実際領域がバラバラになっていたら、キャッシュを改めないとならなくなります。</p>

<p>また、連続メモリでのイテレーターが進むときに、単純にポインターを一つ動くだけとは違って、このパターンのイテレーターは次のメモリを持っているノードに移るべきかを分岐として検証しなければならなくなります。</p>

<p>よって、各メモリの確保数が2の二乗なこともこういった性能落ちを抑制するために意図的に設定した数値だそうです。そして各ノードの持っているメモリが大きすぎないように、各ノードのメモリ確保の限界値を決めることもより速い性能をするために必要だと言ってます。</p>

<h2 id="コード">コード？</h2>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TType</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">DGroup</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">DMeta</span>
    <span class="p">{</span>
        <span class="n">DGroup</span><span class="o">*</span> <span class="n">mpPrev</span><span class="p">;</span>
        <span class="n">DGroup</span><span class="o">*</span> <span class="n">mpNext</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mCnt</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mCap</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">TType</span><span class="o">*</span> <span class="n">mpMem</span><span class="p">;</span>
    <span class="n">DMeta</span>  <span class="n">mMeta</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="p">)</span><span class="o">::</span><span class="n">calloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mpMem</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mpMem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCnt</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">{</span>   <span class="c1">// Create _2.
</span><span class="c1"></span>
        <span class="c1">// We need to calculate next capacity (2^) O(k)
</span><span class="c1"></span>        <span class="kt">unsigned</span> <span class="n">nextCap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">pCur</span> <span class="o">=</span> <span class="n">_1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">pCur</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">nextCap</span> <span class="o">+=</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span>
            <span class="n">pCur</span> <span class="o">=</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="p">)</span><span class="o">::</span><span class="n">calloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mpMem</span>           <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">nextCap</span><span class="p">);</span>
        <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span>      <span class="o">=</span> <span class="n">nextCap</span><span class="p">;</span>
        <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span>    <span class="o">=</span> <span class="n">_2</span><span class="p">;</span>
        <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpPrev</span>    <span class="o">=</span> <span class="n">_1</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mpMem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">nextCap</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">nextCap</span><span class="p">);</span>
            <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCnt</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// DO SOME COMPLEXT THING...
</span><span class="c1"></span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// _2-&gt;mpMem[i - 1].~int();
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="p">{</span>
        <span class="k">auto</span><span class="o">*</span> <span class="n">pDelete</span>       <span class="o">=</span> <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span><span class="p">;</span>
        <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span>    <span class="o">=</span> <span class="n">pDelete</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span><span class="p">;</span>
        <span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">pDelete</span><span class="p">);</span> 
        <span class="n">pDelete</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// _1-&gt;mpMem[i - 1].~int();
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="p">{</span>
        <span class="k">auto</span><span class="o">*</span> <span class="n">pDelete</span>       <span class="o">=</span> <span class="n">_1</span><span class="p">;</span>
        <span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">pDelete</span><span class="p">);</span>
        <span class="n">pDelete</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="最後に">最後に</h2>
]]></content>
		</item>
		
	</channel>
</rss>
