<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on neuromantic</title>
		<link>https://liliilli.github.io/posts/</link>
		<description>Recent content in Posts on neuromantic</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Tue, 03 Mar 2020 23:59:05 +0900</lastBuildDate>
		<atom:link href="https://liliilli.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>CMakeのメモまとめ</title>
			<link>https://liliilli.github.io/posts/cmake_memo/</link>
			<pubDate>Tue, 03 Mar 2020 23:59:05 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/cmake_memo/</guid>
			<description>https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1 Do&amp;rsquo;s and Don&amp;rsquo;ts CMakeで避けるべきのパターン https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1 link_directories、include_librariesなどのグローバル関数を使わ</description>
			<content type="html"><![CDATA[

<p><a href="https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html">https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html</a></p>

<p><a href="https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1">https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1</a></p>

<h1 id="do-s-and-don-ts">Do&rsquo;s and Don&rsquo;ts</h1>

<h2 id="cmakeで避けるべきのパターン">CMakeで避けるべきのパターン</h2>

<blockquote>
<p><a href="https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html">https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html</a><br><a href="https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1">https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1</a></p>
</blockquote>

<ul>
<li><code>link_directories</code>、<code>include_libraries</code>などのグローバル関数を使わないこと。</li>
<li><code>PUBLIC</code>はあんまり使わずにできる限り<code>PRIVATE</code>にすべき。</li>
<li>ファイルを取得するために<code>GLOB</code>を使わないこと。もしかして使わざるをえない場合には<code>CONFIGURE_DEPENDS</code>フラグを使えば使わないままに<code>GLOB</code>を使うようはうまく動作するらしい。</li>
</ul>

<p><a href="https://cmake.org/cmake/help/latest/command/file.html">公式マニュアル</a>によれば、<code>GLOB</code>は<code>&lt;globbing-expressions&gt;</code>に当てはまるファイルのリストを取得し、それを変数に入れ込むらしい。この表現式は正規表現パターンみたいな文法を持ってる。<code>GLOB</code>の詳しいことはマニュアルを見ること。</p>

<ul>
<li>リンキングする時には<code>PUBLIC/PRIVATE</code>の指定を忘れないこと。</li>
</ul>

<h2 id="cmakeでやればイイかもパターン">CMakeでやればイイかもパターン</h2>

<ul>
<li>Make <code>ALIAS</code> targets to keep usage consistent.</li>
<li>関数の名前は小文字を推薦。変数は大文字でやる方が良いらしい。</li>
<li><code>cmake_policy</code>を使うこと。<a href="https://cmake.org/cmake/help/latest/command/cmake_policy.html">「リンク」</a></li>
<li>ビルトインコマンドなどはだいたい文字の大小を区別してないが、出来れば少文字でやる方が良いらしい。</li>
</ul>

<h1 id="basics">Basics</h1>

<h2 id="最低限バージョンを指定">最低限バージョンを指定</h2>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.1</span><span class="p">)</span></code></pre></div>
<p><code>VERSION &lt;version&gt;</code>によってCMakeのコードをビルドする時の規定が決まる。一番最新のCMakeを持っているとしても上の<code>VERSION</code>の後について来る数値によってビルドが通るか否かが決まる。バージョンによるポリシー（規定・規則）の違いは<a href="https://cmake.org/cmake/help/latest/manual/cmake-policies.7.html">リンク</a>を見ること。</p>

<p>特にCMakeのバージョンが3.12にアップグレードするに連れて</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.1...3.15</span><span class="p">)</span></code></pre></div>
<p>のように<strong>範囲</strong>を決めることが出来るようになった。<br>なので厳密には上記の構文は以下のように書かなかればならないらしい。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.1...3.15</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># CMakeのバージョンが3.12より下なら、CMakeのバージョンに合うポリシーを入れてビルドを行う。
</span><span class="c"></span><span class="nb">if</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_VERSION</span><span class="o">}</span> <span class="s">VERSION_LESS</span> <span class="s">3.12</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nb">cmake_policy</span><span class="p">(</span><span class="s">VERSION</span> <span class="o">${</span><span class="nv">CMAKE_MAJOR_VERSION</span><span class="o">}</span><span class="s">.</span><span class="o">${</span><span class="nv">CMAKE_MINOR_VERSION</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<p>または<code>cmake_minimum_required</code>を使うことも出来る。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.1</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_VERSION</span><span class="o">}</span> <span class="s">VERSION_LESS</span> <span class="s">3.15</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nb">cmake_policy</span><span class="p">(</span><span class="s">VERSION</span> <span class="o">${</span><span class="nv">CMAKE_MAJOR_VERSION</span><span class="o">}</span><span class="s">.</span><span class="o">${</span><span class="nv">CMAKE_MINOR_VERSION</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>    <span class="nb">cmake_policy</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.15</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<h2 id="プロジェクトセッティング">プロジェクトセッティング</h2>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">project</span><span class="p">(</span><span class="s">MyProject</span> 
	<span class="s">VERSION</span> <span class="s">1.0</span> <span class="c"># `MyProject_Version`とか`PROJECT_VERSION`変数などに数値が更新される
</span><span class="c"></span>    <span class="s">DESCRIPTION</span> <span class="s2">&#34;Very nice project&#34;</span> <span class="c"># 3.8以降から付けられる
</span><span class="c"></span>    <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span> <span class="err">#</span> <span class="err">基本</span> <span class="err">`C</span> <span class="err">CXX`で指定されている</span></code></pre></div>
<h2 id="ターゲット-targets-をよく使うべき">ターゲット（Targets）をよく使うべき</h2>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">target_include_directories</span><span class="p">(</span><span class="s">&lt;target&gt;</span> <span class="s">PUBLIC</span> <span class="s">&lt;rel/abs_directory_path&gt;</span><span class="p">)</span></code></pre></div>
<p><a href="https://cmake.org/cmake/help/latest/command/target_include_directories.html">target_include_directories</a>コマンドは<code>target</code>にディレクトリーのパスを関連付ける。</p>

<p><code>PUBLIC</code>でできたパスの場合は、他のターゲットがこのターゲットを参照するときに、このターゲットに関連付けられたディレクトリーパスも一緒に参照するということである。<code>PRIVATE</code>にした場合には自分だけ参照して他のターゲットなどには干渉しないらしい。<code>INTERFACE</code>はヘッダー専用ライブラリーに使うものである。</p>

<p>ターゲットを別のターゲットの関連付ける時にはこう使う。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">add_library</span><span class="p">(</span><span class="s">&lt;another_target&gt;</span> <span class="s">STATIC</span> <span class="s">another.cpp</span> <span class="s">another.h</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">&lt;another_target&gt;</span> <span class="s">PUBLIC</span> <span class="s">&lt;target&gt;</span><span class="p">)</span></code></pre></div>
<p><a href="https://cmake.org/cmake/help/latest/command/target_link_libraries.html">target_link_libraries</a>は<code>&lt;another_target&gt;</code>に他のライブラリまたはターゲットを依存させる時に使う。もしターゲットがCMakeのターゲットリストで見えなかったら、ライブラリーで探してくれる。<code>&lt;target&gt;</code>ではなく、パスでも指定することが出来る。</p>

<p>ターゲットはそれぞれ<code>include_directories</code>とか<code>linked_libraries</code>などを持っているので、ターゲットの依存するスコープなどを制限したい場合に<code>PUBLIC</code>または<code>PRIVATE/INTERFACE</code>などを使うらしい。</p>

<h1 id="変数とキャッシュ">変数とキャッシュ</h1>

<h2 id="ローカル変数">ローカル変数</h2>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">set</span><span class="p">(</span><span class="s">MY_VARIABLE</span> <span class="s2">&#34;value&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">MY_LIST</span> <span class="s2">&#34;one&#34;</span> <span class="s2">&#34;two&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">MY_LIST_THAT_SAME_ABOVE</span> <span class="s2">&#34;one;two&#34;</span><span class="p">)</span></code></pre></div>
<p><code>set</code>コマンドで変数を設定し、設定した変数に接近する時には<code>${}</code>を使って値を取得出来る。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="err">${MY_LIST}</span></code></pre></div>
<p>変数のスコープは、<code>set</code>などで変数を決めてから下のディレクトリーのCMakeLists.txtファイルまで及ぶ。現在ファイルだけスコープを決めたければ、<code>set</code>コマンドで変数を設定する時に最後に<code>PARENT_SCOPE</code>を入れれば現在ファイルだけでスコープが決まるらしい。</p>

<p>またCMakeの変数はスペース（空白）文字に寄って区切られているため、空白文字が入ってそうなパスが入った変数に接近する時には、<code>&quot;&quot;</code>を付けて接近するほうが良さそうかも。</p>

<h2 id="キャッシュ変数">キャッシュ変数</h2>

<p>CMakeでビルドする時に変数の値などを決めたいなら、<strong>キャッシュ変数</strong>を使う。BOOLならば普通の<strong>OPTION</strong>でも良いが、</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">option</span><span class="p">(</span><span class="s">MY_OPTION</span> <span class="s2">&#34;This is settable from the command line&#34;</span> <span class="s">OFF</span><span class="p">)</span></code></pre></div>
<p>それじゃなく複雑な値を入れたい場合には以下のように中に<code>CACHE</code>を入れる。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">set</span><span class="p">(</span><span class="s">MY_CACHE_VARIABLE</span> <span class="s2">&#34;VALUE&#34;</span> <span class="s">CACHE</span> <span class="s">STRING</span> <span class="s2">&#34;Description&#34;</span><span class="p">)</span></code></pre></div>
<p>ただしこれじゃGUIまたは外部からCMakeをビルドする時に変数の値を変更することは出来ない。なので（１）のようにするか、それとも<code>INTERNAL</code>を使って（２）のように書いて外部から値が設定するようにするしかない。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">set</span><span class="p">(</span><span class="s">MY_CACHE_VARIABLE</span> <span class="s2">&#34;VALUE&#34;</span> <span class="s">CACHE</span> <span class="s">STRING</span> <span class="s2">&#34;&#34;</span> <span class="s">FORCE</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">mark_as_advanced</span><span class="p">(</span><span class="s">MY_CACHE_VARIABLE</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">MY_CACHE_VARIABLE</span> <span class="s2">&#34;VALUE&#34;</span> <span class="s">CACHE</span> <span class="s">INTERNAL</span> <span class="s2">&#34;&#34;</span><span class="p">)</span></code></pre></div>
<p>このキャッシュ変数を使って実装されたビルトイン変数は<a href="https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html">リンク</a>で見れる。</p>

<h2 id="properties">Properties</h2>

<p>属性（Properties）は変数と使い方は同じだが、ターゲットまたはディレクトリーにくっ付いたものである。Propertiesもグローバル属性があるんだけど、ターゲットの大体の属性は<code>CMAKE_</code>として始まる変数を見て、属性を値を埋めるように設計されているらしい。</p>

<p>例えば、<code>CMAKE_CXX_STANDARD</code>の場合にはすべてのターゲットの<code>CXX_STANDARD</code>造成の値を更新するようになっている。もしかして一つ一つ属性を付けようとしたら、以下のようにすれば良い。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">set_property</span><span class="p">(</span><span class="s">TARGET</span> <span class="s">TargetName</span>
             <span class="s">PROPERTY</span> <span class="s">CXX_STANDARD</span> <span class="s">11</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="c"># または複数で
</span><span class="c"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">TargetName</span> <span class="s">PROPERTIES</span> <span class="s">CXX_STANDARD</span> <span class="s">11</span><span class="p">)</span></code></pre></div>
<p>ターゲットから属性の値を持ってくる時には<code>get_property</code>を使う。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">get_property</span><span class="p">(</span><span class="s">ResultVariable</span> <span class="s">TARGET</span> <span class="s">TargetName</span> <span class="s">PROPERTY</span> <span class="s">CXX_STANDARD</span><span class="p">)</span></code></pre></div>
<p>属性のリストは<a href="https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html">リンク</a>で見れるらしい。</p>

<h1 id="programming-in-cmake">Programming in CMake</h1>

<h2 id="if-構文"><code>if</code>構文</h2>

<p><code>if</code>構文は変数と表現式をどう使うかによって<code>THEN</code>に入ることと<code>ELSE</code>に入ることが変わる。例えば、ある変数<code>variable</code>がある時、普通に<code>variable</code>に入れたら、</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">if</span> <span class="p">(</span><span class="s">variable</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="c"># &#39;ON&#39;, &#39;YES&#39;, &#39;Y&#39;, または０じゃない数字
</span><span class="c"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="c"># &#39;0&#39;, &#39;OFF&#39;, &#39;NO&#39;, &#39;N&#39;, &#39;IGNORE&#39;, &#39;NOTFOUND&#39;, &#39;&#34;&#34;&#39; または最後に&#39;-NOTFOUND&#39;で終わる時
</span><span class="c"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<p>ただし、検証しようとする変数がどちらに当てはまらないと、自動に<code>${variable}</code>としてまた検証を行う。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">if</span> <span class="p">(</span><span class="o">${</span><span class="nv">variable</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="c"># false-like 表現式じゃなければすべてtrueになる
</span><span class="c"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="c"># &#39;&#34;&#34;&#39; または true になれない表現式はすべてこっちへ
</span><span class="c"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<h2 id="generator-expressions">Generator-Expressions</h2>

<h2 id="マクロと関数">マクロと関数</h2>

<blockquote>
<p><a href="https://cmake.org/cmake/help/latest/command/macro.html">macro</a><br><a href="https://cmake.org/cmake/help/latest/command/function.html">function</a></p>
</blockquote>

<p><code>function</code>と<code>macro</code>はほとんど同じだが、関数は引数として入れる変数が外部から見えないようになっている。もしかし入れられた引数を結果値または関数の内部で更新したい場合には<code>PARENT_SCOPE</code>を使う。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">function</span><span class="p">(</span><span class="s">SIMPLE</span> <span class="s">REQUIRED_ARG</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">message</span><span class="p">(</span><span class="s">STATUE</span> <span class="s2">&#34;Simple arguments: ${REQUIRED_ARG}, followed by ${ARGV}&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">REQUIRED_ARG</span><span class="o">}</span> <span class="s2">&#34;From SIMPLE&#34;</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endfunction</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">simple</span><span class="p">(</span><span class="s">This</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s2">&#34;Output: ${This}&#34;</span><span class="p">)</span> <span class="err">#</span> <span class="err">Output:</span> <span class="err">From</span> <span class="err">SIMPLE</span></code></pre></div>
<p>ここで<code>${ARGV}</code>と<code>${ARGN}</code>という関数で呼べるビルトイン変数があってこれを使い渡した引数を出力することができるだろう。そして、CMakeの関数では他の言語とは違いリターン値がない。なので関数から何かを返したい場合には出力専用の引数を作ってそこに<code>PARENT_SCOPE</code>でセットすること。</p>

<h1 id="デバッグ">デバッグ</h1>

<h2 id="変数などを出力">変数などを出力</h2>

<p>普通<code>message</code>で出力することができる。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;MY_VARIABLE=${MY_VARIABLE}&#34;</span><span class="p">)</span></code></pre></div>
<p>ただし、ビルトインのモジュールを使えば<code>printf</code>でやってる感覚を無くし、よりモーダンな接近法で変数リストを出力することができる。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">include</span><span class="p">(</span><span class="s">CMakePrintHelpers</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">MY_VARIABLE</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">cmake_print_properties</span><span class="p">(</span>
    <span class="s">TARGETS</span> <span class="s">my_target</span>
    <span class="s">PROPERTIES</span> <span class="s">POSITION_INDEPENDENT_CODE</span>
<span class="p">)</span></code></pre></div>
<h2 id="デバッグモードでビルド">デバッグモードでビルド</h2>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="err">-DCMAKE_BUILD_TYPE=Debug</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Hugoブログを使いこなせるためのメモ</title>
			<link>https://liliilli.github.io/posts/hugo_memo/</link>
			<pubDate>Tue, 03 Mar 2020 23:10:28 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/hugo_memo/</guid>
			<description>すごく久しぶりにHugoのブログを使おうとしましたが、ブログに記事を書くどころかHugoの使い方すらすっかり忘れてしまいました。だもんで自分</description>
			<content type="html"><![CDATA[

<p>すごく久しぶりにHugoのブログを使おうとしましたが、ブログに記事を書くどころかHugoの使い方すらすっかり忘れてしまいました。だもんで自分用のメモみたいなことを書いていつでも覚えさせられるようにしたいと思います。</p>

<p>ちなみにブログの設定環境はWindowsです。新しくインストールするなら<code>$ brew install hugo</code>みたいなもんは当然出来ないし、Windowsのパッケージをダウンロードして設置するしかないみたいですね。</p>

<h1 id="覚えておくといい-かも-メモリスト">覚えておくといい（かも）メモリスト</h1>

<h2 id="レポジトリー登録">レポジトリー登録</h2>

<ul>
<li><p>WindowsではHugoをインストールしてから環境変数に登録する必要があります。</p></li>

<li><p>HugoはDeployで生成された本サイトページと、そのページを生成するためのリソースが一つのディレクトリの中にまとまっているので、遠隔リポジトリーなどにリソースをセーブする為には２つのリポジトリーを作ることが一番良いらしい。</p>

<ul>
<li>例えば、Hugoの本コンテンツとリソースを入れ込む用途として使う<code>&lt;YOUR-PROJECT&gt;</code>と
結果としてDeployされた<code>&lt;USERNAME&gt;.github.io</code>レポジトリ。
<br /></li>
</ul></li>

<li><p><code>&lt;YOUR-PROJECT&gt;</code>は本プロジェクトとして<br></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git remote add origin git@github.com:integerous/blog.git</code></pre></div></li>

<li><p><code>&lt;USERNAME&gt;.github.io</code>はSubmoduleとして登録する。<br></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git submodule add -b master <span class="se">\
</span><span class="se"></span>git@github.com:integerous/integerous.github.io.git public</code></pre></div></li>
</ul>

<p>上記のようにすることで<code>public</code>っていうDeployされた時に作られるウェブサイトフォルダーは本プロジェクトとは違って<code>&lt;USERNAME&gt;.github.io</code>を持つことになる。</p>

<h2 id="コンテンツ生成">コンテンツ生成</h2>

<ul>
<li>コンテンツ生成はブログのフォルダーから<code>$ hugo new posts/test1.md</code>みたいなコマンドを売ってファイルを生成する。Draftで生成したい場合には<code>-D</code>を最後につける。</li>
<li>コンテンツをローカルで見る為には<code>hugo server</code>または<code>hugo server -D</code>で確認できる。</li>
</ul>

<h2 id="コンテンツアップロード">コンテンツアップロード</h2>

<ol>
<li>まず<code>$ hugo -t テーマの名前</code>で設置されたテーマが適用されたコンテンツを<code>public</code>フォルダーに生成。</li>
<li><code>public</code>フォルダーに移動し、gitなどで<code>&lt;USERNAME&gt;.github.io</code>にコミットする。</li>

<li><p>ルートフォルダーに戻り、生リソースを<code>&lt;YOUR-PROJECT&gt;</code>にコミットする。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git push origin master</code></pre></div></li>
</ol>

<h1 id="最後に">最後に</h1>

<p>ちなみにほぼ３ヶ月ぐらい放置してたブログをまだ使おうとしたのは、個人プロジェクトの<code>CMakeLists.txt</code>を削除してしまい、また書こうとしても<code>CMake</code>なんてすっかり忘れてしまってブログにメモとりながら再実装する必要があったからです。これで一日無駄使いしてしまいWINAPIのFiberのサンプルを書く時間なんてなくなってしまいました。</p>

<p>ソースコードはちゃんとバックアップしましょうね。</p>

<h1 id="リンク">リンク</h1>

<p><a href="https://github.com/Integerous/Integerous.github.io">Hugo로 Github.io 블로그 만들기</a></p>
]]></content>
		</item>
		
		<item>
			<title>C&#43;&#43;2aのconceptsを使ってみた。</title>
			<link>https://liliilli.github.io/posts/cpp_concept/</link>
			<pubDate>Thu, 21 Nov 2019 20:33:04 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/cpp_concept/</guid>
			<description>C++のConceptを簡略説明 C++2a（20）から追加する文法の一つであるconceptは、あるタイプの制約条件を記すことができる識別子</description>
			<content type="html"><![CDATA[

<h1 id="c-のconceptを簡略説明">C++のConceptを簡略説明</h1>

<p>C++2a（20）から追加する文法の一つである<code>concept</code>は、あるタイプの制約条件を記すことができる識別子です。制約条件というのは<code>Constraints</code>と呼びますが、あくまでも付与された<code>concept</code>を満足するための一連の条件組だと言えます。以下はある<code>concept</code>を宣言するコードです。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">is_floating_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<p>注意することは、宣言したconceptは、他のconceptを宣言する時に型引数で<code>typename</code>または<code>class</code>の代わりに使うことはできません。また、<code>requires</code>を使うこともできません。ただし、定義する構文で使うことはできます。</p>

<p>constraintsはconceptだけじゃなくて、<code>requires</code>文法を使ってタイプの条件を設定することができます。C#に例えたら、多分<code>where</code>が一番近いんじゃないかな？と思いますね。下はconceptを使わずにconstraintsだけを使っているコードです。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// First syntax of `requires` and `constraints`
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go3</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">v2</span><span class="p">)</span> <span class="k">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>宣言したconceptは次のように使えます。conceptじゃない構文であれば、<code>typename</code>と<code>class</code>の代わりに使えることがわかります。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="n">is_floating_point</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go4</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>ただし、上のコードではあくまでも<code>v1</code>と<code>v2</code>が<code>Float</code>という型に縛られているので、<code>v1</code>に<code>double</code>を入れたり<code>v2</code>に<code>float</code>を入れてコンパイルすることはできません。下のコードでは、上記の問題点を解決するため<code>template</code>を使わず、conceptを型として使います。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">auto</span> <span class="nf">go5</span><span class="p">(</span><span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>[const/volatile] concept auto [&amp;, &amp;&amp;]</code>を使うことで<code>v1</code>と<code>v2</code>のタイプは別々のタイプが持てるようになります。実はリターン型<code>auto</code>の前にもconceptをくっつけることが出来ます。</p>

<p>最後に、変数にもconceptが使えます。<code>auto</code>を一緒に使いますが、前にconceptを書けることでタイプ自体じゃなくてできる行動・特性をもつタイプの一連として考えるようになり、もっと柔軟なロジックを組むことが出来ます。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//floating_point auto val2 = go6(1.2f, 3.4f); 
</span><span class="c1">// go6は`int`を返しますが、`int`はfloating_pointコンセプトの条件が満たしていないので
</span><span class="c1">// コンパイルエラーが出ます。
</span><span class="c1"></span><span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">val3</span> <span class="o">=</span> <span class="n">go5</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>
</code></pre></div>
<h1 id="もっと詳しく知りたい方へ">もっと詳しく知りたい方へ</h1>

<p>上の説明は、<code>concept</code>と<code>requires</code>、そして条件構文でできることの一部しか紹介していません。詳しく知りたい型には以下の文書をお読みいただけましたら嬉しいです。</p>

<p><a href="https://en.cppreference.com/w/cpp/language/constraints">https://en.cppreference.com/w/cpp/language/constraints</a></p>

<p>また、C++のコードがウェブで作成できるCompiler Explorerというサイトで、gcc (trunk)またはclang (concepts)を選択しましたら<code>concept</code>が実装されたバージョンでコードが組めることが出来ます。</p>

<h1 id="full-code">Full code</h1>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go1</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">value1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">value2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">Float</span><span class="p">,</span>
    <span class="k">typename</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;&gt;</span>
<span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go2</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">value1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">value2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// First syntax of `requires`.
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go3</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">v2</span><span class="p">)</span> 
    <span class="k">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Using concept instead of typename or class in template.
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">is_floating_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">is_floating_point</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go4</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">floating_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// We can write `floating_point` explicitly before `auto` return.
</span><span class="c1">// When `floating_point` is written before auto, return value should
</span><span class="c1">// satisfy `floating_point` constraint.
</span><span class="c1"></span><span class="k">auto</span> <span class="nf">go5</span><span class="p">(</span><span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="nf">go6</span><span class="p">(</span><span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="kt">int</span><span class="p">{</span><span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">};</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//go1(1, 2.3);
</span><span class="c1"></span>    <span class="c1">//go1(1.2f, 2.3);
</span><span class="c1"></span>    <span class="n">go1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>          <span class="c1">// Float is int.
</span><span class="c1"></span>    <span class="n">go1</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">2.3f</span><span class="p">);</span>    <span class="c1">// Float is float.
</span><span class="c1"></span>    <span class="n">go1</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">);</span>      <span class="c1">// Float is double.
</span><span class="c1"></span>
    <span class="c1">//go2(1, 2);        // Substitution is failed, and output message is bizzare.
</span><span class="c1"></span>    <span class="n">go2</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">);</span>      <span class="c1">// Float is double.
</span><span class="c1"></span>
    <span class="c1">// Substitution is failed 
</span><span class="c1"></span>    <span class="c1">// but output message is humble and more readable.
</span><span class="c1"></span>    <span class="c1">//go3(1, 2);
</span><span class="c1"></span>    <span class="c1">//go3(1, 2.3);
</span><span class="c1"></span>    <span class="n">go3</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>        

    <span class="c1">// constraints not satisfied
</span><span class="c1"></span>    <span class="c1">//go4(1, 10);
</span><span class="c1"></span>    <span class="c1">// Also need one uniformed type.
</span><span class="c1"></span>    <span class="c1">// template argument deduction/substitution failed:
</span><span class="c1"></span>    <span class="c1">//go4(1.2f, 3.4);     
</span><span class="c1"></span>    <span class="n">go4</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>
    <span class="n">go4</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>

    <span class="c1">// error: use of function &#39;auto go5(auto:1, auto:2) 
</span><span class="c1"></span>    <span class="c1">// [with auto:1 = int; auto:2 = int]&#39; with unsatisfied constraints
</span><span class="c1"></span>    <span class="c1">//go5(1, 10);
</span><span class="c1"></span>    <span class="n">go5</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>
    <span class="n">go5</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>
    <span class="n">go5</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>
    <span class="n">go5</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">val1</span> <span class="o">=</span> <span class="n">go6</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span> <span class="c1">// This outputs warning but not error,
</span><span class="c1"></span>    <span class="c1">// But below is failed to compile.
</span><span class="c1"></span>    <span class="c1">// &lt; constraints not satisfied
</span><span class="c1"></span>    <span class="c1">// &lt; the expression &#39;is_floating_point_v&lt;T&gt;&#39; evaluated to &#39;false&#39;
</span><span class="c1"></span>    <span class="c1">//floating_point auto val2 = go6(1.2f, 3.4f);
</span><span class="c1"></span>    <span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">val3</span> <span class="o">=</span> <span class="n">go5</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>
    <span class="k">return</span> <span class="kt">int</span><span class="p">{</span><span class="n">val3</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>ShaderToyでPBRを書いてから、自ら解説してみた。</title>
			<link>https://liliilli.github.io/posts/shadertoy_pbr/</link>
			<pubDate>Sat, 16 Nov 2019 19:51:58 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/shadertoy_pbr/</guid>
			<description>実は2週前に、ShaderToyというウェブでGLSLがかけて、それをレンダリングすることができるサイトで、上のシェーダーを書いてました。前</description>
			<content type="html"><![CDATA[

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/WsdSDf?gui=true&t=10&paused=true&muted=false" allowfullscreen></iframe>
実は2週前に、ShaderToyというウェブでGLSLがかけて、それをレンダリングすることができるサイトで、上のシェーダーを書いてました。前にもShaderToyで色々と書いたんですが、PBRを本格に適用して書いたのは今が初めてです。</p>

<p>なんで、このシェーダーを書きながら、どうやってPBRのDiffuseとSpecularを実装したのかを簡単と大雑把に書きたいと思います。図形の作り方、またはレイマーチングのやり方に関しては説明いたしません。</p>

<h1 id="本編">本編</h1>

<p>PBRレンダリングを勉強するときによく見られるDisneyの<code>Physical-Based Shading at Disney</code>、または色々のPBRが基づく理論文書を読みますと、光と視点のよるある地点の色は以下になります。</p>

<p>$$
f(\pmb{l}, \pmb{v}) = \text{diffuse} + \text{specular}
$$
<code>Diffuse</code>と<code>Specular</code>はそれぞれの特性を独立的に持てると言えます。なので、実施に最終色を入れるときに次のように単純に<code>Diffuse</code>と<code>Specular</code>を入れます。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="c1">// fragColorは[0,1]のvec4(R,G,B,A)です。</span>
<span class="n">fragColor</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">dif</span> <span class="o">+</span> <span class="n">spc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></code></pre></div>
<blockquote>
<p>$$ f(\pmb{l}, \pmb{v}) $$ は実際には色そのまのを表してはいません。あくまでBRDF（Bidirectional-Reflectance Distribution Funciton）のモデルを表したものであり、実際にはぶつかった入射光線と表面の法線での半球で、すべての反射光線がどの角度とエナジーを持つのかを調べて、全部合わせないと正確な数値が計算できません。</p>

<p>ただし、今はもっと抽象化した数式を使ってレンダリングをしようとします。リアルタイムで完全な数式を解いて色を得ることはほぼ不可能だし、もっと抽象化したモデルでもだいたい通じます。</p>
</blockquote>

<h2 id="diffuse">Diffuse</h2>

<p>普通よく使うのは<code>Lambertian</code>ですが<code>Oren-Nayar</code>っていう、もっと正確なPBRモデルもあります。僕は最初は<code>Lambertian</code>を使いましたが、最終は<code>Oren-Nayar</code>にしました。</p>

<h3 id="lambertian">Lambertian</h3>

<p>$$
f(\pmb{l}, \pmb{v}) = \frac{\rho_{ss}}{\pi}
$$</p>

<p><code>Diffuse</code>モデルの中で一番簡単なモデルです。色だけでモデルBRDFが決まりますし、だとしてもそれっぽく見えるようになるので普通のゲームでもよく使います。</p>

<p>ここで
$$
\rho_{ss}
$$
は、表面のアルベド（物体が光を弾いたときの反射率）を表します。これだけがLambertianのモデルの数値になります。</p>

<p>下のコードはLambertianモデルを使って、実際のピクセルのカラーを表現するコードです。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">FactorDiffLambertian</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">/</span> <span class="n">pi</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">vec3</span> <span class="n">DiffuseLambertian</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> 
                       <span class="k">in</span> <span class="k">vec3</span> <span class="n">diffuse</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">ambient</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mix</span><span class="p">(</span><span class="n">ambient</span><span class="p">,</span> <span class="n">diffuse</span><span class="p">,</span> <span class="n">FactorDiffLambertian</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>注意するとこは、<code>FactorDiffLamberitan</code>の中の<code>dot(l, n)</code>は実際はLambertianのモデルの数式に含まれていません。<code>mix(ambient, diffuse, ...)</code>の<code>diffuse</code>が上記の
$$
\rho_{ss}
$$
になります。
そして、<code>FactorDiffLambertian</code>関数は、以下の数式
$$
L_o(\mathbf{v}) = \int_{\mathbf{l}\in\Omega}{f(\mathbf{l}, \mathbf{v})L_i(\mathbf{l})(\mathbf{n}\cdot\mathbf{l})d\mathbf{l}}
$$
の<code>dot(l, n)</code>項を表しています。（ただし、πは事前に入れときました。反省するとこですね。）</p>

<p>このモデルの特徴は表面が平坦だと見なしてレンダリングを行うところです。Roughnessが関与するとこが無く、単純にアルベドと光と表面の法線ベクトルによる明度だけをレンダリングします。ということで、ちょっと単純だけどコストが速いし、それなりにごまかせば他のモデルとあんまり違いは出ないと思います。</p>

<h3 id="oren-nayar">Oren-Nayar</h3>

<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model">https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model</a>
<a href="https://mimosa-pudica.net/improved-oren-nayar.html">https://mimosa-pudica.net/improved-oren-nayar.html</a></p>
</blockquote>

<p>このモデルは上のLambertianとは違って、表面の粗さによって明度の違いのレンダリングを調節できます。Oren-Nayarとともに表面の粗さによるDiffuseレンダリングモデルを総じて、<code>Rough-surface diffuse BRDF</code>と呼びます。</p>

<p>とりあえずOren-Nayarは論文をみますとFull-Model（完全モデル）とQuantitive-Model（ある程度省略したモデル）に分かれています。ウィキペディアに乗っているのはQuantitive-Modelだし、僕もフールモデルじゃなくてQuantitive-Modelを使ってOren-Nayarを実装してます。</p>

<p>Oren-Nayar（Quantitiveバージョン）は以下の数式となります。
$$
\begin{align}
L_{r} &amp;=
    \frac{\rho}{\pi}
    \cdot (\mathbf{l} \cdot \mathbf{n})
    \cdot (A + (B \cdot \max[0, \cos(\phi_{i} - \phi_{v})]
        \cdot \sin\alpha
        \cdot \tan\beta))
    \cdot E_0
\\<br />
A &amp;= 1 - 0.5\frac{\sigma^2}{\sigma^2 + 0.33}
\\<br />
B &amp;= 0.45 \frac{\sigma^2}{\sigma^2 + 0.09}
\\<br />
\alpha &amp;= \max(
    \theta_{\mathbf{l} \cdot \mathbf{n}},
    \theta_{\mathbf{v} \cdot \mathbf{n}})
\\<br />
\beta &amp;= \min(
    \theta_{\mathbf{l} \cdot \mathbf{n}},
    \theta_{\mathbf{v} \cdot \mathbf{n}})
\end{align}
$$
しかし僕は2番目のリンクにあるベクトルを使った数式を使いました。
$$
\begin{align}
L_o &amp;= \frac{\rho}{\pi}\cdot(\mathbf{l}\cdot\mathbf{n})(A + B\frac{\mathbf{s}}{t})
\\<br />
s &amp;= \mathbf{l}\cdot\mathbf{v} - (\mathbf{n}\cdot\mathbf{l})(\mathbf{n}\cdot\mathbf{v})
\\<br />
t &amp;=
\begin{cases}
1 &amp; \text{if $s \le 0$} \\<br />
\max(\mathbf{n}\cdot\mathbf{v}, \mathbf{n}\cdot\mathbf{l}) &amp; \text{if $s \gt 0$}
\end{cases}
\\<br />
A &amp;= (1 - 0.5\frac{\sigma^2}{\sigma^2 + 0.33} + 0.17\rho\frac{\sigma^2}{\sigma^2 + 0.13})
\\<br />
B &amp;= 0.45\frac{\sigma^2}{\sigma^2 + 0.09}
\end{align}
$$
なぜなら、上の数式を直接反映してみたらところどころでバグによる明るい曲線が見えるからです。多分<code>tan()</code>項でバグったりして不具合が描画されると思いますが、直せずに下のベクトル形態の数式を使ってOren-NayarのQuantitive-Modelを実装しました。</p>

<p>数式で見れる<code>\rho</code>（$ \rho $ ）はアルベドを表します。普通Lamberitanのアルベドのように、アルベドカラーを入れます。そして<code>\sigma</code>（$ \sigma $）は表面の粗さ（Roughness）を示します。だいたい０～１の値を持ちます。</p>

<p>上の数式を表したコードは下にあります。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">OrenNayarAlpha</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">OrenNayarBeta</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mix</span><span class="p">(</span>
        <span class="mf">1.</span><span class="n">f</span><span class="p">,</span>
        <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)),</span>
        <span class="n">step</span><span class="p">(</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">OrenNayarAlpha</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">OrenNayarA</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">-</span> <span class="mf">0.5</span><span class="n">f</span> <span class="o">*</span> <span class="p">(</span>
         		<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
    <span class="o">/</span> <span class="c1">// ----------------------</span>
        	<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.33</span><span class="n">f</span><span class="p">)</span>           
    <span class="p">)</span>
    <span class="o">+</span> <span class="mf">0.17</span><span class="n">f</span> <span class="o">*</span> <span class="p">(</span>
        		<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
    <span class="o">/</span> <span class="c1">// ----------------------</span>
        	<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.13</span><span class="n">f</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">OrenNayarB</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mf">0.45</span><span class="n">f</span> <span class="o">*</span> <span class="p">(</span>
         		<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
    <span class="o">/</span> <span class="c1">// ----------------------</span>
        	<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.09</span><span class="n">f</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">FactorDiffOrenNayar</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">float</span> <span class="n">A</span>  	<span class="o">=</span> <span class="n">OrenNayarA</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    <span class="k">float</span> <span class="n">B</span> 	<span class="o">=</span> <span class="n">OrenNayarB</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    <span class="k">float</span> <span class="n">_a</span> 	<span class="o">=</span> <span class="n">OrenNayarAlpha</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">float</span> <span class="n">_b</span> 	<span class="o">=</span> <span class="n">OrenNayarBeta</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">FactorDiffLambertian</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span> <span class="o">*</span> <span class="p">(</span><span class="n">_a</span> <span class="o">/</span> <span class="n">_b</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">vec3</span> <span class="n">DiffuseOrenNayar</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> 
                      <span class="k">in</span> <span class="k">vec3</span> <span class="n">diffuse</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">ambient</span><span class="p">,</span> 
                      <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mix</span><span class="p">(</span><span class="n">ambient</span><span class="p">,</span> <span class="n">diffuse</span><span class="p">,</span> <span class="n">FactorDiffOrenNayar</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>一気にコードの量が増えましたが、分析していただきましたら大したものはないことがわかります。</p>

<p>実は、2番目のリンク先で投稿した方の改良したOren-Nayarモデルも実装はしたんですが、光が表面全体を照らすときの描画が好きじゃなかったので断念してOren-NayarのQuantitive-Modelを最終採用しました。</p>

<h2 id="specular">Specular</h2>

<p>SpecularのBRDFも、上のDiffuseのようにMicrofacet理論に基づいたモデルを使っています。Specular（ハイライト）は、Diffuseとは違ってカメラの目線によってある位置にハイライトの陰影がつけられるかが異なります。（なんで、Lambertianみたいな単純なモデルは無いです）</p>

<p>普通に使ってるPBRのSpecularモデルは、以下の<strong>Cook-Torrance Model</strong>です。
$$
f_{spec}(\mathbf{l}, \mathbf{v}) = \frac
    {F(\mathbf{h}, \mathbf{l})G_{2}(\mathbf{l},\mathbf{v},\mathbf{h})D(\mathbf{h})}
    {4|\mathbf{n}\cdot\mathbf{l}||\mathbf{n}\cdot\mathbf{v}|}
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">cn</span> <span class="o">=</span> <span class="mf">4.</span><span class="n">f</span> <span class="o">*</span> <span class="n">max</span><span class="p">(</span><span class="mf">.25</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ld</span><span class="p">))</span> <span class="o">*</span> <span class="n">max</span><span class="p">(</span><span class="mf">.25</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="n">fwd</span><span class="p">));</span>
            
<span class="k">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">GTR</span><span class="p">(</span><span class="mi">9</span><span class="n">e</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="n">kBx1</span><span class="p">.</span><span class="n">mRough</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="mf">2.</span><span class="n">f</span><span class="p">);</span>
<span class="k">float</span> <span class="n">f</span> <span class="o">=</span> <span class="n">Schlick</span><span class="p">(</span><span class="n">kBx1</span><span class="p">.</span><span class="n">mR0</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
<span class="k">float</span> <span class="n">g</span> <span class="o">=</span> <span class="n">SeparableMaskingShadowing</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">kBx1</span><span class="p">.</span><span class="n">mRough</span><span class="p">);</span>
            
<span class="n">spc</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">f</span> <span class="o">*</span> <span class="n">g</span> <span class="o">/</span> <span class="n">cn</span><span class="p">;</span></code></pre></div>
<h3 id="fresnel-reflection">Fresnel Reflection</h3>

<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Fresnel_equations">https://en.wikipedia.org/wiki/Fresnel_equations</a>
<a href="https://en.wikipedia.org/wiki/Schlick%27s_approximation">https://en.wikipedia.org/wiki/Schlick%27s_approximation</a></p>
</blockquote>

<p>上記のCook-Torrance Modelにて、分子の
$$
F(\mathbf{h}, \mathbf{l})
$$
はフレネルの式を示します。要するに、光の入射光線がある物体の表面にぶつかるときの正反射率を表す数式です。全ての物質は自分のIOR（屈折率）と外部のIORによってそれぞれ違う反射率を持ちます。</p>

<p>ウィキペディアを見ていただきますと正確な数式がありますが、CGでシェーダープログラムにフレネルの式の全部をやらせるには負担がかかりすぎます。なので、下の単純なモデルを使いながらある程度フレネルの式を従います。
$$
F(\mathbf{h}, \mathbf{l}) \approx F_0 + (1 - F_0)(1 - (\mathbf{h}\cdot\mathbf{l})^+)^5
$$
この数式は<strong>Schlick-Approximation</strong>と言います。空気中の物質に対するフレネルの式の数値を得たいときの使います。もちろん、抽象化されたモデルなので正確ではありません。ですがフレネルの式の数値のグラフでの変動をある程度沿っています。</p>

<p>ここで、
$$
F_0
$$
は垂直入射の時のFresnel反射係数の実部です。この数値はRGBまたは普通のグレースケールの数値として入れられます。グレースケールになる場合には、物質が金属ではない場合で使えます。RGBは金属の物質のフレネルの数値を求めたい場合に使えます。（大雑把でしたけど、もっと詳しくお調べしたい方々は*Real-Time Rendering 4th*のChapter9をお読みくださいませ）
$$
\mathbf{h} = \text{normalize($\mathbf{l} + \mathbf{v}$)}
$$
<code>h</code>はハーフウェイベクトル（Halfway Vector）と言います。DiffuseとSpecularを一つに統合したレンダリングモデルである、Blinn-Phong Reflectance Modelでも使うやつです。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">Schlick</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r0</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">r0</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">r0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)),</span> <span class="mf">5.</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// または</span>

<span class="k">float</span> <span class="n">Schlick</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r0</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">td</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">r0</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">r0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="n">cos</span><span class="p">(</span><span class="n">td</span><span class="p">)),</span> <span class="mf">5.</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>上のコードはSchlick Approximationを2つのバージョンで実装したものです。下のバージョンの<code>td</code>は、<code>n</code>と<code>v</code>の角度差を表します。</p>

<h3 id="normal-distribution-function">Normal Distribution Function</h3>

<p>法線分布関数だと呼ばれる<strong>Normal Distribution Function</strong>は、微小面の法線がどうやって分布されているかを示す関数です。この関数は統計的に測定されて使っているか、それともある抽象化した数学関数を用いて使います。詳しくはmicrofacet理論の触れますので割愛します。</p>

<p>ですけどこのNDFに特徴の一つは、あるNDF関数があって、そしてある表面の法線ベクトル <code>N</code> があった時に、球面を覆う単位ベクトルを入れたNDFの値の積分は、<code>N</code> を持つ微細表面の面積になります。ということで、
$$
\int_{\mathbf{m} \in \Theta} {D(\mathbf{m})(\mathbf{n} \cdot \mathbf{m})d\mathbf{m}} = 1
$$
になります。</p>

<p>また、カメラまたは目線のベクトル<code>v</code>があるとき、ある表面の法線ベクトルが<code>n</code>で、そして微細表面の球体の単位ベクトルが<code>m</code>だとしたら、
$$
\int_{\mathbf{m} \in \Theta}{D(\mathbf{m})(\mathbf{v}\cdot\mathbf{m})d\mathbf{m}} = \mathbf{v}\cdot\mathbf{n}
$$
です。目によって実際に見える微小面の面積は微小面の凸凹の法線ベクトルたちを目線のベクトルとの内積し、結果値を全部足したのと同じです。<code>v * m</code>で目に見えない微小面はなくなりまし、見える表面は残ります。</p>

<p>一応これもリアルタイムでは計算しにくいので、上の特性から派生した様々な抽象化したモデルがあります。僕はDisney BRDFで使った<strong>GTR (Generalized-Trowbridge-Reitz）</strong>モデルを使いました。このモデルはGGX（Trowbridge-Reitz）モデルを一般化したものです。
$$
D_{GTR} = \frac{c}{(a^2\cos^2(\theta_{h})+\sin^2(\theta_{h}))^\gamma}
$$</p>

<blockquote>
<p>実はこの数式も実使用で使うために簡略化された数式です。Realtime-RenderingでGTRの完全数式を見てみますと結構ひどいです。（白目）</p>
</blockquote>

<p>上の数式で、<code>gamma</code>が2ならGGXと同じになります。以下はGTRをコードに写したものです。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">GTR</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">c</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">dh</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">gamma</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> 
        						 <span class="n">c</span>
    <span class="o">/</span> <span class="c1">//--------------------------------------------------------</span>
        <span class="n">pow</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">dh</span><span class="p">),</span> <span class="n">gamma</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h3 id="joint-masking-shadowing-function">Joint Masking Shadowing Function</h3>

<p>Joint Masking Shadowing Functionを説明する前に、簡単に一般Masking Function <code>G</code>を説明させていただきたいと思います。日本語でいうと<strong>幾何減衰項</strong>（読み方はわかりません）と言います。Masking Functionは微小面（Microfacet）によって発生するシャドウィング（自己陰影）、マスキング（自己遮蔽）を表したものです。</p>

<p>幾何減衰項は上で説明したNDFに（法線分布関数）と密接に関連されます。上の表面の法線・微小面の法線・目線の法線との関係がある数式は、以下のように変形できます。
$$
\int_{\in\Theta}{G_1(\mathbf{m}, \mathbf{v})D(\mathbf{m})(\mathbf{v}\cdot\mathbf{m})^+d\mathbf{m}} = \mathbf{v}\cdot\mathbf{n}
$$
ここで <code>G_1(m, v)</code>は<strong>Smith Function</strong>といい、<code>v</code>に対して見える<code>m</code>の比率を表します。ですけど、G1は実際には<code>m</code>が目線の反対方向を向いていなければ、G1の数値に全然影響がない特徴を持ちます。なのでSmith Function G1の数式は
$$
G_1(\mathbf{m}, \mathbf{v}) = \frac{\chi^+(\mathbf{m}\cdot\mathbf{v})}{1 + \Lambda(\mathbf{v})}
$$
となります。コードでは上の分子の項は、<code>m</code>と<code>v</code>の内積が0より大きければ1として置換できます。ですがこれをこのまま使うのではなく、BRDFを建てる時には以下のようにG1の代わりにG2を使います。
$$
f(\mathbf{l}, \mathbf{v}) =
    \int_{\mathbf{m}\in\Theta}
        f_{\mu}(\mathbf{l}, \mathbf{v}, \mathbf{m})
        G_2(\mathbf{l}, \mathbf{v}, \mathbf{m})
        D(\mathbf{m})
        \frac{(\mathbf{m}\cdot\mathbf{l})^+}{|\mathbf{n}\cdot\mathbf{l}|}
        \frac{(\mathbf{m}\cdot\mathbf{v})^+}{|\mathbf{n}\cdot\mathbf{v}|}
        d\mathbf{m}
\\<br />
\\<br />
G_2(\mathbf{l}, \mathbf{v}, \mathbf{m}) =
    G_1(\mathbf{v}, \mathbf{m})
    G_1(\mathbf{l}, \mathbf{m})
$$
上のG2の形以外に、様々な変形数式が存在します。G1を2つくっつけて掛け算する数式が一番だったりしますが、不具合が存在しますので下のも使われるそうです。（下は*Smith Height-Correlated Masking-Shadowing Function*）と言います。
$$
G_2(\mathbf{l}, \mathbf{v}, \mathbf{m}) = \frac{\chi^+(\mathbf{v}\cdot\mathbf{m})\chi^+(\mathbf{l}\cdot\mathbf{m})}{1 + \Lambda(\mathbf{v}) + \Lambda(\mathbf{l})}
$$
僕は一番簡単な分離型G2を使いました。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">Lambda</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">rad</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> 
        <span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="n">f</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span><span class="n">f</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="n">f</span> <span class="o">/</span> <span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span><span class="n">f</span><span class="p">)))</span> <span class="o">*</span> <span class="mf">.5</span><span class="n">f</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">SmithMasking</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">rad</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span>
        		<span class="mf">1.</span><span class="n">f</span>
    <span class="o">/</span> <span class="c1">//-----------------------</span>
        <span class="p">(</span><span class="mf">1.</span><span class="n">f</span> <span class="o">+</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">rad</span><span class="p">,</span> <span class="n">r</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">SeparableMaskingShadowing</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">tl</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">tv</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">SmithMasking</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">SmithMasking</span><span class="p">(</span><span class="n">tv</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h1 id="まとめ">まとめ</h1>

<p>以上、大雑把にコードを振り返りながらPBRの書き方、中身についてメモをしてみました。</p>

<h1 id="もっと詳しく調べたい方に">もっと詳しく調べたい方に</h1>

<ul>
<li><a href="https://qiita.com/mebiusbox2/items/1cd65993ffb546822213">https://qiita.com/mebiusbox2/items/1cd65993ffb546822213</a></li>

<li><p><a href="https://qiita.com/mebiusbox2/items/8db00cdcaf263992a5ce">https://qiita.com/mebiusbox2/items/8db00cdcaf263992a5ce</a></p></li>

<li><p><a href="https://qiita.com/emadurandal/items/3a8db7bc61438245654d">https://qiita.com/emadurandal/items/3a8db7bc61438245654d</a></p></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Chained-Group Allocationパターンについてメモ</title>
			<link>https://liliilli.github.io/posts/chained-group-allocation/</link>
			<pubDate>Sat, 09 Nov 2019 22:15:34 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/chained-group-allocation/</guid>
			<description>https://www.plflib.org/chained_group_allocation_pattern.htm を見て、分かったことをメモしたいと思います。 Abstract Chanined-Group Allocationパターンは、ダブルリンクリストを拡張して、書くノードは付加的な情報を持</description>
			<content type="html"><![CDATA[

<p><a href="https://www.plflib.org/chained_group_allocation_pattern.htm">https://www.plflib.org/chained_group_allocation_pattern.htm</a><br>を見て、分かったことをメモしたいと思います。</p>

<h2 id="abstract">Abstract</h2>

<p><strong>Chanined-Group Allocation</strong>パターンは、ダブルリンクリストを拡張して、書くノードは付加的な情報を持ちながらメモリを動的に確保して使わせるパターンです。書くノードは２の二乗バイトのメモリを持ち、もしいま使っているノードが全部埋まったら、次のメモリを持つノードのメモリ量は今までのメモリ量を合わせた分になります。</p>

<h2 id="description">Description</h2>

<p>このパターンは、どれぐらいのメモリが必要になるかが事前にわからないときに使えるパターンだそうです。といったら、<code>std::vector&lt;T, A&gt;</code> とはあんまり変わらないじゃないのと思うかもしれないんですが、動的にメモリを管理して、拡張または縮小するのは同じだけれども、具体的には違うそうです。</p>

<p><code>std::vector&lt;T, A&gt;</code> の場合には、メモリが必ず一列になる必要があります。たとえ、あるベクターがあるメモリを持っているとして、もしメモリを拡張しなければならない場合には全体メモリを他のより広いメモリに移す作業を行いますね。しかし、今のパターンはメモリをまた再割当てせずに、新しいインスタンスの確保のためのメモリ空間を割り当てて、リンクリストのポインターに繋げることで拡張を行います。</p>

<p>このパターンでは「メモリブロック」（または空間を指しているポインター）と「メモリブロックに関しての様々な情報」をまとめて「グループ」と言います。情報の中にはダブルリンクリストを構成するための前のメモリノードと後のメモリノードへのポインターが必ず入ります。それ以外に、今ノードが持っているメモリブロックに何個まで入れるか、何個入ったか、Skipfieldなどなどが入りそうです。</p>

<blockquote>
<p>Skipfieldは後の<code>Colony</code>コンテナーを説明するときに説明したいと思います。</p>
</blockquote>

<p>Abstractで書いたように、各ノードは２の二乗バイトのメモリを持ちます。例えば、１番目のブロックが<code>int</code>で8個を持っているとしたら（32Bytes）、次のブロックはまた8個（32Bytes）、そして次々のブロックは1番目と2番目のブロックを足した分の16個（64Bytes）のメモリを持つようにします。で、4番目のブロックは8＋8＋16＝32個が入れるメモリ領域を持つでしょう。</p>

<h2 id="advantages">Advantages</h2>

<p><code>std::vector</code>のような連続メモリとは違って、メモリ領域がリンクリストとして連結していることによって、イテレータとポインターを持っているときに、コンテナーにインスタンスを挿入することでの無効化（Invalidation）が起こらなくなります。</p>

<p>そしてメモリ確保を個別にやってからリンクリストとして連結することで、Resizeなどの関数でよく起こりうるメモリ再確保⇒存在しているインスタンスのコピーまたはムーブコストが発生しなくなります。こうすることで要素（インスタンス）を追加する時の副作用コストが顕著に減ります。（削除する時にもメモリを解除して、リンクリストから除外させれば終わりなんでこれも速いです。）</p>

<p>また、Groupを静的のリストの形として管理したら、Groupのための動的メモリ確保をすることが省きそうなので一部状況ではもっと速く動作すると思われます。</p>

<h2 id="disadvantages">Disadvantages</h2>

<p>メモリ確保がリンクリストとして管理されるので、<code>std::vector</code>のような連続メモリに対してはイテレーターが一回りする速度は遅くなるかもしれません。特に、確保したメモリの実際領域がバラバラになっていたら、キャッシュを改めないとならなくなります。</p>

<p>また、連続メモリでのイテレーターが進むときに、単純にポインターを一つ動くだけとは違って、このパターンのイテレーターは次のメモリを持っているノードに移るべきかを分岐として検証しなければならなくなります。</p>

<p>よって、各メモリの確保数が2の二乗なこともこういった性能落ちを抑制するために意図的に設定した数値だそうです。そして各ノードの持っているメモリが大きすぎないように、各ノードのメモリ確保の限界値を決めることもより速い性能をするために必要だと言ってます。</p>

<h2 id="コード">コード？</h2>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TType</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">DGroup</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">DMeta</span>
    <span class="p">{</span>
        <span class="n">DGroup</span><span class="o">*</span> <span class="n">mpPrev</span><span class="p">;</span>
        <span class="n">DGroup</span><span class="o">*</span> <span class="n">mpNext</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mCnt</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mCap</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">TType</span><span class="o">*</span> <span class="n">mpMem</span><span class="p">;</span>
    <span class="n">DMeta</span>  <span class="n">mMeta</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="p">)</span><span class="o">::</span><span class="n">calloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mpMem</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mpMem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCnt</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">{</span>   <span class="c1">// Create _2.
</span><span class="c1"></span>
        <span class="c1">// We need to calculate next capacity (2^) O(k)
</span><span class="c1"></span>        <span class="kt">unsigned</span> <span class="n">nextCap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">pCur</span> <span class="o">=</span> <span class="n">_1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">pCur</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">nextCap</span> <span class="o">+=</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span>
            <span class="n">pCur</span> <span class="o">=</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="p">)</span><span class="o">::</span><span class="n">calloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mpMem</span>           <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">nextCap</span><span class="p">);</span>
        <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span>      <span class="o">=</span> <span class="n">nextCap</span><span class="p">;</span>
        <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span>    <span class="o">=</span> <span class="n">_2</span><span class="p">;</span>
        <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpPrev</span>    <span class="o">=</span> <span class="n">_1</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mpMem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">nextCap</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">nextCap</span><span class="p">);</span>
            <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCnt</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// DO SOME COMPLEXT THING...
</span><span class="c1"></span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// _2-&gt;mpMem[i - 1].~int();
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="p">{</span>
        <span class="k">auto</span><span class="o">*</span> <span class="n">pDelete</span>       <span class="o">=</span> <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span><span class="p">;</span>
        <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span>    <span class="o">=</span> <span class="n">pDelete</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span><span class="p">;</span>
        <span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">pDelete</span><span class="p">);</span> 
        <span class="n">pDelete</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// _1-&gt;mpMem[i - 1].~int();
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="p">{</span>
        <span class="k">auto</span><span class="o">*</span> <span class="n">pDelete</span>       <span class="o">=</span> <span class="n">_1</span><span class="p">;</span>
        <span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">pDelete</span><span class="p">);</span>
        <span class="n">pDelete</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="最後に">最後に</h2>
]]></content>
		</item>
		
	</channel>
</rss>
