<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on neuromantic</title>
		<link>https://liliilli.github.io/posts/</link>
		<description>Recent content in Posts on neuromantic</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Sat, 05 Sep 2020 16:21:55 +0900</lastBuildDate>
		<atom:link href="https://liliilli.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>C&#43;&#43;でのDoxygenの書き方のメモ</title>
			<link>https://liliilli.github.io/posts/doxygen_memo/</link>
			<pubDate>Sat, 05 Sep 2020 16:21:55 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/doxygen_memo/</guid>
			<description>以前にもコードの説明を書く時にDoxygenみたいな構文で書いてきたんですが、本格的にAPIのマニュアルを成立しようとしたらどう書けばいいか</description>
			<content type="html"><![CDATA[

<p>以前にもコードの説明を書く時にDoxygenみたいな構文で書いてきたんですが、本格的にAPIのマニュアルを成立しようとしたらどう書けばいいかが迷ったので、ここでもう一度公式文書を読みながら自分的にメモを書かせてもらいたいと思います。</p>

<h1 id="documenting-the-code">Documenting the code</h1>

<blockquote>
<p><a href="https://www.doxygen.nl/manual/docblocks.html">https://www.doxygen.nl/manual/docblocks.html</a></p>
</blockquote>

<h2 id="special-comment-blocks">Special comment blocks</h2>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">/// 
</span><span class="c1">/// ... text ...
</span><span class="c1">///
</span></code></pre></div>
<p>で書くのが経験上VS2019～でコメント作成しやすいし、Intellisenseでもちゃんと把握してTipとして見せるようだ。</p>

<p>上の形式以外にもDoxygenで検知してくれるコメントの形式は色々とあるみたいだが、一つのプロジェクトの中ではちゃんと形式を決めて使いましょうっていうこと。</p>

<h2 id="brief-を書く為には"><code>\brief</code>を書く為には？</h2>

<ol>
<li><p><code>\brief</code>（または<code>@brief</code>）でヘッダーを明示的に書く方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">///
</span><span class="c1">/// @brief Brief description
</span><span class="c1">///     Breif description continued.
</span><span class="c1">///
</span><span class="c1">/// Detailed description starts here.
</span></code></pre></div>
<p><code>\brief</code>ヘッダーは簡単な説明を書く時に使うべき。もっと詳しい説明は一行開けてから書けばいいらしい。（これ知らなかった）</p></li>

<li><p><code>JAVADOC_AUTOBRIEF</code>を有効化すれば、１のような方法でなくてもBriefが書けるらしい。ただ明示的ではないため、個人的にはちょっと好きじゃないかも。</p></li>
</ol>

<h2 id="メンバ変数の後に説明を付けたい場合">メンバ変数の後に説明を付けたい場合</h2>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="n">var</span><span class="p">;</span> <span class="c1">///&lt; Brief description after the member.
</span><span class="c1"></span>         <span class="c1">//!&lt; Or Details description after the member as comments are continued.
</span></code></pre></div>
<p>通常コメントをつけるのと同じだが、Prefixの最後に<code>&lt;</code>をつけることでDoxygenの文書化をすることができるそうだ。</p>

<p>また、関数の引数の中でも<code>/**&lt; ... */</code>のような構造でDoxygenに検知させることもできる。個人的には見た目が余計に複雑になるからあんまり使いたくはないが…</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="cm">/**&lt; [in] docs for input parameter v. */</span><span class="p">);</span>
</code></pre></div>
<p>注意点としては、こういった文書化はメンバ変数とパラメータにしかできないことだ。クラスとか列挙型などには普通のブロックコメントで文書化をするしかないらしい。そしてヘッダーコマンド（<code>\brief</code>や<code>\class</code>のような）も使えない。</p>

<h2 id="例-1">例 1</h2>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">/// A Test class
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Afterdoc_Test</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">/// An enum type.
</span><span class="c1"></span>    <span class="c1">/// The documentation block cannot be put after the enum.
</span><span class="c1"></span>    <span class="k">enum</span> <span class="nc">EnumType</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">Eval1</span><span class="p">,</span> <span class="c1">///&lt; Enum value 1
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">Eval2</span><span class="p">,</span> <span class="c1">///&lt; Enum value 2
</span><span class="c1"></span>    <span class="p">};</span>
    <span class="kt">void</span> <span class="nf">member</span><span class="p">();</span> <span class="c1">///&lt; A member function.
</span><span class="c1"></span>    
<span class="k">protected</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span> <span class="c1">///&lt; An integer value.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>
<h2 id="例-2-doxygenマニュアルのexamples">例 2 (doxygenマニュアルのExamples)</h2>

<ul>
<li><code>\brief</code>で生成される簡単な説明文はDoxygen生成設定ファイルの<code>BRIEF_MEMBER_DESC</code>をNOにすることで隠せるそうだ。</li>
<li>基本<code>\brief</code>で生成される説明はディテールな説明文項目でも繰り返して出てくる。ディテールで<code>\brief</code>説明文を消すためにはやっぱり設定ファイルで<code>REPEAT_BRIEF</code>をNOにすればなくなるらしい。</li>
<li>Qtスタイル（基本？）では説明を書かなくても良いらしい。</li>
</ul>

<h2 id="他のとこでコメント文書を作成する為には">他のとこでコメント文書を作成する為には</h2>

<p>普通はクラスの前、列挙型の前、それともメンバ変数の後に<code>&lt;</code>をつけてコメントを書いてDoxygenがそれを生成させるのが一般的だ。しかしやむをえず他のとこで文書化したい要素を書かなければならない場合には、<strong>Structural Command</strong>を最初に使ってどの要素を文書化したいかを指定しなければならない。</p>

<p>*Structural Command*は最初に<code>\</code>か<code>@</code>をつける。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">/// @class Test
</span><span class="c1">/// @brief A test class.
</span><span class="c1">///
</span><span class="c1">/// A more detailed class description.
</span></code></pre></div>
<p>*Structural Command*の種類は以下のリストで見れる。</p>

<table>
<thead>
<tr>
<th>Command</th>
<th>説明</th>
</tr>
</thead>

<tbody>
<tr>
<td>class</td>
<td>クラス</td>
</tr>

<tr>
<td>struct</td>
<td>Cスタイルの構造体</td>
</tr>

<tr>
<td>union</td>
<td>共用体</td>
</tr>

<tr>
<td>enum</td>
<td>列挙型</td>
</tr>

<tr>
<td>fn</td>
<td>関数</td>
</tr>

<tr>
<td>var</td>
<td>変数、<code>typedef</code>、または列挙型の値</td>
</tr>

<tr>
<td>def</td>
<td>前処理機の<code>#define</code></td>
</tr>

<tr>
<td>file</td>
<td>ファイル</td>
</tr>

<tr>
<td>namespace</td>
<td>ネームスペース</td>
</tr>
</tbody>
</table>

<p>他に<code>@package</code>または<code>@interface</code>などがあるが、C++だけ適用できる要素だけ触れていくのでメモしない。</p>

<p>注意点としては、<strong>C++</strong>でクラスのメンバ変数を文書化したければ、ネームスペースから初めてクラスまで文書化されなければならないらしい。また、Cスタイルの関数などを文書化したければ、C関数の宣言が入っているファイルもDoxygenスタイルでコメントを書かなければならないそうだ。</p>

<p>ファイルさえもコメントしなければならないのが一気に面倒くさくてちょっとアレだが、公式マニュアルでは普通に</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">/// @file file_name.h
</span></code></pre></div>
<p>でもファイルの文書が定義されてキャッチできるようになっているので、ぜひ書いてほしいと書いてある…</p>

<h1 id="markdown-support">Markdown Support</h1>

<blockquote>
<p><a href="https://www.doxygen.nl/manual/markdown.html">https://www.doxygen.nl/manual/markdown.html</a></p>
</blockquote>

<p>Doxygenは標準Markdownと独自仕様のMarkdownをサポートする。既存のMarkdownと共通している部分もあるが、共通してない、注意すべきの要素のついてメモを取りたい。</p>

<h2 id="code-blocks">Code Blocks</h2>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">/// This a normal paragraph
</span><span class="c1">///
</span><span class="c1">///     // THIS IS CODE BLOCK
</span><span class="c1">///     int main() { return 0; }
</span><span class="c1">///
</span><span class="c1">/// Continue with a normal paragraph again.
</span></code></pre></div>
<p>コードブロックを生成するにはスペースを４つ開くことでコードブロックが生成できる。コードブロックが生成される時に余白は自動削除される。</p>

<p>リストを使う時にはリストの項目から更に４文字空白を開けることがコードブロックができる。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">/// 1.  Item
</span><span class="c1">///     
</span><span class="c1">///     More text for item1.
</span><span class="c1">///
</span><span class="c1">/// 2.  Item2
</span><span class="c1">///     More text for item2.
</span><span class="c1">///     
</span><span class="c1">///         Code block for item2.
</span></code></pre></div>
<h2 id="強調構文">強調構文</h2>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">/// *single asterisks*
</span><span class="c1">/// _single underscores_
</span><span class="c1">/// **double asterisks**
</span><span class="c1">/// __double_asterisks__
</span><span class="c1">/// ~~double~_tilde~~
</span></code></pre></div>
<p>標準Markdownとは違って、途中で<code>_</code>（アンダーバー）があっても強調構文が終わらない仕様になっている。ただし、強調構文が成立するには必ず構文の左右に空白が来なければならない。</p>

<h2 id="を使ったcode-blocks"><code>~~~</code>を使ったCode Blocks</h2>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">/// This a normal paragraph.
</span><span class="c1">///
</span><span class="c1">/// ~~~{.cpp}
</span><span class="c1">/// // THIS IS ALSO CODE BLOCK.
</span><span class="c1">/// int main() { return 0; }
</span><span class="c1">/// ~~~
</span></code></pre></div>
<p>普通の段落から一行開けて<code>~~~</code>を使うことでコードブロックを生成することができる。上の既存の方式ではすべてのコードに４つ以上のスペースを入れなければならなかったが、これを使うことでもっと便利にコードが作成できる。</p>
]]></content>
		</item>
		
		<item>
			<title>Rust＋Winapiで窓を生成してみた</title>
			<link>https://liliilli.github.io/posts/rust_winapi_memo/</link>
			<pubDate>Thu, 13 Aug 2020 10:04:36 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/rust_winapi_memo/</guid>
			<description>暇つぶしでRustとwinapi crateを使って、窓を生成してイベントメッセージを処理するルーチンを作ってみました。実はdinput8とx</description>
			<content type="html"><![CDATA[

<p><img src="/image/2008/rust_memo_execute.jpg" alt="Rust execution" /></p>

<p>暇つぶしでRustとwinapi crateを使って、窓を生成してイベントメッセージを処理するルーチンを作ってみました。実は<code>dinput8</code>と<code>xinput</code>まで実装したかったのですが、ここで使ってるcrateのwinapiではまだ実装されていないみたいで（<code>dinput8</code>自体も結構古くて実装も難しいと思いますが）適当なところで辞めました。</p>

<p>上の画像は窓を作って、メッセージを処理して<code>println!()</code>で情報を出力するのをスクショしたものです。</p>

<h1 id="環境">環境</h1>

<ul>
<li>Clion 2020.2</li>
<li>cargo 1.42.0 (86334295e 2020-01-31)</li>
<li>rustc 1.42.0 (b8cedc004 2020-03-09)</li>
<li>rustup 1.22.1 (b01adbbc3 2020-07-08)</li>
<li>stable-x86_64-pc-windows-msvc</li>
<li>CMake 3.17.3 (Clion Bundled)</li>
<li>LLDB 9.0 (Clion Bundled)</li>
</ul>

<p>ビルド環境はClionでVisual Studio 2019＋amd64でやっております。MinGWでもwinapi crateは一旦ビルド出来ますが、特定関数を使おうとするとEntry pointが探せないというエラーと一緒に起動が出来ないようになってしまいます。</p>

<p>また使っているcrateは以下のリストとなります。</p>

<ul>
<li>widestring 0.4.2</li>

<li><p>winapi</p>
<div class="highlight"><pre class="chroma"><code class="language-cargo" data-lang="cargo">[dependencies]
widestring = &#34;0.4.2&#34;

[target.&#39;cfg(windows)&#39;.dependencies.winapi]
version = &#34;0.3.9&#34;
features = [
&#34;basetsd&#34;, &#34;commctrl&#34;, &#34;dbt&#34;, &#34;mmsystem&#34;,
&#34;winuser&#34;, &#34;winbase&#34;, &#34;winnls&#34;, &#34;winnt&#34;, &#34;dinput&#34;,
&#34;shellapi&#34;, &#34;errhandlingapi&#34;, &#34;profileapi&#34;, &#34;timeapi&#34;,
&#34;hidclass&#34;, &#34;minwindef&#34;, &#34;windef&#34;, &#34;ntdef&#34;, &#34;windowsx&#34; ]

[profile.dev]
opt-level = 0
overflow-checks = false
debug = 2</code></pre></div></li>
</ul>

<h1 id="実装">実装</h1>

<h2 id="wndclassの登録">WNDCLASSの登録</h2>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerclassexw">RegisterClassExW</a></p>
</blockquote>

<p>winapi crateではC/C++で使ってる関数、変数などがそのまま使えるように実装されています。実装されていない関数もいくつかありますが、大体古すぎるか、代わりに使える機能があったりして実装されてないみたいです。</p>

<p>窓を作る前に<code>WNDCLASSEXW</code>と<code>RegisterClassExW</code>関数を使ってクラスを登録します。やり方はC/C++のとほぼ同じです。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WNDCLASSEXW</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">cbSize</span>: <span class="nc">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">WNDCLASSEXW</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">UINT</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">style</span>: <span class="nc">CS_HREDRAW</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">CS_VREDRAW</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">lpfnWndProc</span>: <span class="nc">proc</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">cbClsExtra</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">cbWndExtra</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">hInstance</span>: <span class="nc">hmodule</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">hIcon</span>: <span class="nc">LoadIconW</span><span class="p">(</span><span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">(),</span><span class="w"> </span><span class="n">IDI_APPLICATION</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">hCursor</span>: <span class="nc">LoadCursorW</span><span class="p">(</span><span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">(),</span><span class="w"> </span><span class="n">IDC_ARROW</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">hbrBackground</span>: <span class="nc">GetStockObject</span><span class="p">(</span><span class="n">WHITE_BRUSH</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">c_int</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">HBRUSH</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">lpszMenuName</span>: <span class="nc">ptr</span>::<span class="n">null_mut</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">lpszClassName</span>: <span class="nc">class_name</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">hIconSm</span>: <span class="nc">ptr</span>::<span class="n">null_mut</span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="n">RegisterClassExW</span><span class="p">(</span><span class="o">&amp;</span><span class="n">class</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>ただここで使ってる関数はWindows専用のUnicode（UCS-2）文字列しか受け取らないため、rustで基本提供している<code>OSCString</code>を使うか、それともwidestring crateの<code>U16CString</code>を使って、文字列を変換して渡す必要があります。自分はU16CStringを使いました。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">class_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">U16CString</span>::<span class="n">from_str</span><span class="p">(</span><span class="n">class_name</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></code></pre></div>
<p>また注意する点はwinapi crateから提供する関数はほぼ<code>unsafe</code>であるため、上のようにunsafeブロックで囲んで使うようになっています。出来ればsafeな関数を作ってその中にunsafeブロックでwinapiの関数を使うのをおすすめします。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">register_wndclass</span><span class="p">(</span><span class="n">hmodule</span>: <span class="nc">HMODULE</span><span class="p">,</span><span class="w"> </span><span class="n">class_name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="kr">proc</span>: <span class="nc">WNDPROC</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
<span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">//... unsafe blocks
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
<h2 id="ウィンドウ-窓-の生成">ウィンドウ（窓）の生成</h2>

<h3 id="一般ウィンドウの生成">一般ウィンドウの生成</h3>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowexw">CreateWindowExW</a></p>
</blockquote>

<p>C/C++でやったのと同じくコードを作成します。ただCreateWindowExWはunsafeであるため、ブロックで囲みます。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">class_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">U16CString</span>::<span class="n">from_str</span><span class="p">(</span><span class="n">class_name</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;Error message&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">window_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">U16CString</span>::<span class="n">from_str</span><span class="p">(</span><span class="n">window_name</span><span class="p">.</span><span class="n">unwrap_or</span><span class="p">(</span><span class="s">&#34;new window&#34;</span><span class="p">)).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;Error message&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">styles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">styles</span><span class="p">.</span><span class="n">unwrap_or</span><span class="p">(</span><span class="n">WS_OVERLAPPEDWINDOW</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">WS_CLIPCHILDREN</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">ex_styles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ex_styles</span><span class="p">.</span><span class="n">unwrap_or</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_adjusted_window_size</span><span class="p">(</span><span class="n">styles</span><span class="p">,</span><span class="w"> </span><span class="n">ex_styles</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">.</span><span class="n">unwrap_or</span><span class="p">((</span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">)));</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pos</span><span class="p">.</span><span class="n">unwrap_or</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">hmodule</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hmodule</span><span class="p">.</span><span class="n">unwrap_or</span><span class="p">(</span><span class="n">get_default_process_module</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">hwnd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">CreateWindowExW</span><span class="p">(</span><span class="n">ex_styles</span><span class="p">,</span><span class="w"> </span><span class="n">class_name</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w"> </span><span class="n">window_name</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w"> </span><span class="n">styles</span><span class="p">,</span><span class="w">
</span><span class="w">                    </span><span class="n">pos</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w">                    </span><span class="n">parent</span><span class="p">.</span><span class="n">unwrap_or</span><span class="p">(</span><span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">()),</span><span class="w">
</span><span class="w">                    </span><span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">(),</span><span class="w">
</span><span class="w">                    </span><span class="n">hmodule</span><span class="p">,</span><span class="w">
</span><span class="w">                    </span><span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">())</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span></code></pre></div>
<p>C/C++で窓を作ってる時と同じ注意点ですが、styleとex-styleによって窓全体の大きさがそれぞれ違いますので、<code>AdjustWindowRectEx</code>という関数で全体窓のサイズを取得する必要があります。僕は<code>get_adjusted_window_size()</code>という関数を作ってその中でサイズを取得するようにしました。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-adjustwindowrectex">AdjustWindowRectEx</a></p>
</blockquote>

<p>以下は上の関数をラッピングした関数の全文です。ちなみに<code>#[cfg(windows)]</code>とは、ビルドしようとするプラットフォームがWindowsである時だけ、この関数をビルドするという意味をしてます。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[cfg(windows)]</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">get_adjusted_window_size</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">styles</span>: <span class="nc">DWORD</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ex_styles</span>: <span class="nc">DWORD</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">has_menu</span>: <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ideal_size</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">winapi</span>::<span class="n">shared</span>::<span class="n">windef</span>::<span class="n">RECT</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">winapi</span>::<span class="n">shared</span>::<span class="n">minwindef</span>::<span class="n">BOOL</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">winapi</span>::<span class="n">um</span>::<span class="n">winuser</span>::<span class="p">{</span><span class="n">AdjustWindowRectEx</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RECT</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">left</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">top</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">right</span>: <span class="nc">ideal_size</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">bottom</span>: <span class="nc">ideal_size</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">AdjustWindowRectEx</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">RECT</span><span class="p">,</span><span class="w"> </span><span class="n">styles</span><span class="p">,</span><span class="w"> </span><span class="n">has_menu</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">BOOL</span><span class="p">,</span><span class="w"> </span><span class="n">ex_styles</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">right</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">bottom</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">top</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>とにかくCreateWindowExWで正しいハンドルを取得したらラッピングして返します。じゃなければエラーメッセージを入れて返します。そうするためにrustで基本提供している<code>Result&lt;,&gt;</code>を使います。ちなみにC++ではC++17から<code>std::variant</code>で真似して使えます。（それともboost::outcomeを使うこともアリだし、自分で直接つくるのもOKかもです…。）</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">create_window</span><span class="p">(...,</span><span class="w"> </span><span class="n">parent</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">HWND</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">WindowHandle</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">DyError</span><span class="o">&gt;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">if</span><span class="w"> </span><span class="n">hwnd</span><span class="p">.</span><span class="n">is_null</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">DyError</span>::<span class="n">gui</span><span class="p">(</span><span class="n">get_last_error</span><span class="p">().</span><span class="mi">1</span><span class="p">))</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">else</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">WindowHandle</span><span class="p">{</span><span class="w"> </span><span class="n">hwnd</span><span class="p">,</span><span class="w"> </span><span class="n">notify_icon</span>: <span class="nc">NotifyIcon</span>::<span class="nb">None</span><span class="w"> </span><span class="p">}))</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>返されたHWNDはあくまでもポインターなため、<code>is_null()</code>でC++の<code>HWND == nullptr</code>のような挙動が書けます。</p>

<h3 id="メッセージ処理専用のウィンドウ生成">メッセージ処理専用のウィンドウ生成</h3>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/window-features#message-only-windows">Message-Only Windows</a></p>

<p>&hellip;To create a message-only window, specify the HWND_MESSAGE constant or a handle to an existing message-only window in the hWndParent parameter of the CreateWindowEx function. You can also change an existing window to a message-only window by specifying HWND_MESSAGE in the hWndNewParent parameter of the SetParent function&hellip;</p>
</blockquote>

<p>ここではHIDデバイスを探知するためのバックグラウンドウィンドウを作ります。ただ今まで書いたコードではHIDデバイスをリアルタイムで判断して登録するコードがないため、あくまでご参考だけにしてください。</p>

<p>ウィンドウ生成自体は上記と同じですが、parentの引数として<code>HWND_MESSAGE</code>を入れるのが違いです。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">hwnd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_window</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span><span class="w"> </span><span class="n">window_name</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">                         </span><span class="nb">Some</span><span class="p">(</span><span class="n">WS_CLIPSIBLINGS</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">WS_CLIPCHILDREN</span><span class="p">),</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">                         </span><span class="nb">Some</span><span class="p">(</span><span class="n">hmodule</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">HWND_MESSAGE</span><span class="p">))</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></div>
<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerdevicenotificationw">RegisterDeviceNotificationW</a></p>

<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/dbt/ns-dbt-dev_broadcast_deviceinterface_w">DEV_BROADCAST_DEVICEINTERFACE_W</a></p>
</blockquote>

<p>HWNDが正常に生成されたらHIDデバイスの探知を起動させるため、DEV_BROADCAST_DEVICEINTERFACE_WとRegisterDeviceNotificationWを使ってHNOTIFYハンドルを生成します。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">db_hid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DEV_BROADCAST_DEVICEINTERFACE_W</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">dbcc_size</span>: <span class="nc">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">DEV_BROADCAST_DEVICEINTERFACE_W</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">DWORD</span><span class="w">
</span><span class="w">    </span><span class="n">dbcc_devicetype</span>: <span class="nc">DBT_DEVTYP_DEVICEINTERFACE</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">dbcc_reserved</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">dbcc_classguid</span>: <span class="nc">GUID_DEVINTERFACE_HID</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">dbcc_name</span>: <span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">hnotify</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">RegisterDeviceNotificationW</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="n">hwnd</span><span class="p">.</span><span class="n">hwnd</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">HANDLE</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="n">db_hid</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">DEV_BROADCAST_DEVICEINTERFACE_W</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">LPVOID</span><span class="p">,</span><span class="w"> 
</span><span class="w">        </span><span class="n">DEVICE_NOTIFY_WINDOW_HANDLE</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span></code></pre></div>
<p>正常に生成されたら、ランタイムでHIDデバイスが探知されたら<code>WM_DEVICECHANGE</code>というメッセージでデバイスの情報が取得できるそうです。（Rustでやったことはないですのでどう探知して情報を入れるかは存じないこと、申し訳ありません。）</p>

<p>また取得したHNOTIFYは必ず<code>UnregisterDeviceNotification</code>で登録解除をしなければなりません。上記のHWNDも同じです。</p>

<h2 id="プロパティの入れ方">プロパティの入れ方</h2>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setpropw">SetPropW</a></p>
</blockquote>

<p>C/C++と同様にSetPropWでプロパティが入れられます。ただ、入れたデータはrustのborrow checkerで検査されてないままになるのでプロパティが解除されるまでは手動で別途で管理する必要があります。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">WindowHandle</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">hwnd</span>: <span class="nc">HWND</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">notify_icon</span>: <span class="nc">NotifyIcon</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">WindowHandle</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">hwnd</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">HWND</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">hwnd</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">create_property_u16</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">prop_name</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u16</span><span class="p">],</span><span class="w"> </span><span class="n">p_data</span>: <span class="nc">HANDLE</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">use</span><span class="w"> </span><span class="n">winapi</span>::<span class="n">um</span>::<span class="n">winuser</span>::<span class="n">SetPropW</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">SetPropW</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">hwnd</span><span class="p">(),</span><span class="w"> </span><span class="n">prop_name</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w"> </span><span class="n">p_data</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">remove_property_u16</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">prop_name</span>:<span class="kp">&amp;</span><span class="p">[</span><span class="kt">u16</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">use</span><span class="w"> </span><span class="n">winapi</span>::<span class="n">um</span>::<span class="n">winuser</span>::<span class="n">RemovePropW</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">!</span><span class="n">RemovePropW</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">hwnd</span><span class="p">(),</span><span class="w"> </span><span class="n">prop_name</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()).</span><span class="n">is_null</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>僕の場合には生成されたHWNDがラッピングされた構造体をプロパティとして入れました。内部のメッセージ処理コールバック関数の中でこれを使って処理をする必要があるからです。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">data_hwnd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="n">hwnd</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">WindowHandle</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">HANDLE</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">hwnd</span><span class="p">.</span><span class="n">create_property_u16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">windows</span>::<span class="n">HWND_PROPSTR</span><span class="p">,</span><span class="w"> </span><span class="n">data_hwnd</span><span class="p">);</span><span class="w">
</span></code></pre></div>
<p>プロパティを解除する関数は<code>RemovePropW</code>です。</p>

<h2 id="サブクラス化してメッセージ処理コールバック登録">サブクラス化してメッセージ処理コールバック登録</h2>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/about-window-procedures#window-procedure-subclassing">Window Procedure Subclassing</a></p>
</blockquote>

<p>Subclassingで特定ウィンドウから送ったり送られたメッセージを親のクラスで指定されているコールバックで処理される前に別途の処理をさせることが出来ます。上の文書を見るとわかりますが、Subclass Procedureという、別途のコールバックを指定することによって、既存のコールバックへの関数ポインターが切り替わりメッセージ処理が走るようになります。もし処理する必要がないなら、親クラスのコールバックへ渡すのも出来ます。</p>

<p>ここではIntance Subclassingだけを使って、バックグラウンドのウィンドウとユーザーに見えるウィンドウの処理を分離させます。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/commctrl/nf-commctrl-setwindowsubclass">SetWindowSubclass</a></p>
</blockquote>

<p>ただここで注意する点は、今サブクラス化しようとしているHWNDが子供（チルドレン）HWNDを持つ可能性があり、出来ればそのチルドレンも一緒にサブクラス化したいところです。そして最終的にはサブクラスのコールバックからメッセージと引数をまとめて外からのクロージャー（C++でいわばLambdaを<code>Function&lt;&gt;</code>化したもの）に安全に渡したいと思います。</p>

<p>ということで、ターゲットしているHWNDを含めてHWNDを親として参照しているチルドレンまでサブクラス化するのは以下の手順を踏みます。</p>

<ol>
<li>EnumChildWindowsでチルドレンのHWNDを全部取る</li>
<li>チルドレンのHWNDに対しSetWindowSubclassでサブクラス化する</li>

<li><p>最後に自分のHWNDもサブクラス化する</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">LocalSetSubclassLParam</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="n">callback_ptr</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">SubclassCallback</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="n">subclass_id</span>: <span class="nc">UINT_PTR</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="c1">// Create local temporary input parameters for binding subclass procedure and specification id.
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">local_params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LocalSetSubclassLParam</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">callback_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">subclass_id</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="n">EnumChildWindows</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">add_children_hwnd</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">handler</span><span class="p">.</span><span class="n">handles</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">HWND</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">LPARAM</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">EnumChildWindows</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">bind_proc_to_children</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">local_params</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">LocalSetSubclassLParam</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">LPARAM</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="c1">// Bind subclass procedure to top target window hwnd.
</span><span class="c1"></span><span class="n">SetWindowSubclass</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">win32_subproc</span><span class="p">),</span><span class="w"> </span><span class="n">subclass_id</span><span class="p">,</span><span class="w"> </span><span class="n">callback_ptr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">UINT_PTR</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">EVENT_HANDLER_ID</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div></li>
</ol>

<p>ちなみにsubclass_idはサブクラスのIDを示します。ここでは普通にSTATICで変数を定義してサブクラスする関数を呼ぶたびに1ずつ増加させてIDを生成しています。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-enumchildwindows">EnumChildWindows</a></p>
</blockquote>

<p>EnumChildWindows関数は、C/C++言語ABIの関数をコールバック引数として受け取って子HWNDを巡回して何らかの処理をする関数です。これを使って、上記の「１」をやります。ここで注意することはコールバック引数の関数は<code>unsafe extern &quot;system&quot;</code>でC ABIの関数になることを明示しないといけないことです。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">unsafe</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;system&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">add_children_hwnd</span><span class="p">(</span><span class="n">h</span>: <span class="nc">HWND</span><span class="p">,</span><span class="w"> </span><span class="n">l</span>: <span class="nc">LPARAM</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span>
<span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">handles</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">HWND</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">HWND</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">handles</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">h</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="mi">1</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EventHandler</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">handles</span>: <span class="nc">vec</span><span class="o">!</span><span class="p">[</span><span class="n">hwnd</span><span class="p">],</span><span class="w">
</span><span class="w">    </span><span class="n">id</span>: <span class="nb">Some</span><span class="p">(</span><span class="n">win32_subproc</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">subclass_id</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...
</span><span class="c1"></span><span class="n">EnumChildWindows</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">add_children_hwnd</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">handler</span><span class="p">.</span><span class="n">handles</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">HWND</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">LPARAM</span><span class="p">);</span><span class="w">
</span></code></pre></div>
<p>win32_subprocは次のコードとなります。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[cfg(windows)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;system&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">win32_subproc</span><span class="p">(</span><span class="n">hwnd</span>: <span class="nc">HWND</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span>: <span class="nc">UINT</span><span class="p">,</span><span class="w"> </span><span class="n">w</span>: <span class="nc">WPARAM</span><span class="p">,</span><span class="w"> </span><span class="n">l</span>: <span class="nc">LPARAM</span><span class="p">,</span><span class="w">
</span><span class="w">                                            </span><span class="n">_id</span>: <span class="nc">UINT_PTR</span><span class="p">,</span><span class="w"> </span><span class="n">p_callback</span>: <span class="nc">DWORD_PTR</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">LRESULT</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">//...
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p_callback</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">SubclassCallback</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">callback</span>: <span class="kp">&amp;</span><span class="nc">SubclassCallback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;**</span><span class="n">callback</span><span class="p">;</span><span class="w"> </span><span class="c1">// Shadowing
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">refhwnd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EventRefHwnd</span>::<span class="n">from</span><span class="p">(</span><span class="n">GetPropW</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span><span class="w"> </span><span class="n">HWND_PROPSTR</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">())</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">WindowHandle</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">msg</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">WM_SYSKEYDOWN</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">WM_SYSKEYUP</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">WM_KEYDOWN</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">WM_KEYUP</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">msg</span><span class="w">
</span><span class="w">            </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">WM_SYSKEYDOWN</span><span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="n">WM_KEYDOWN</span><span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">EventType</span>::<span class="n">OnKeyPressed</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="n">WM_SYSKEYUP</span><span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">WM_KEYUP</span><span class="w">      </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">EventType</span>::<span class="n">OnKeyReleased</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">EventType</span>::<span class="n">Unknown</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">};</span><span class="w">
</span><span class="w">            </span><span class="n">assert_ne</span><span class="o">!</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">EventType</span>::<span class="n">Unknown</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">is_repeated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">msg</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EventType</span>::<span class="n">OnKeyPressed</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">((</span><span class="n">HIWORD</span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x4000</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">keycode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KeyCode</span>::<span class="n">from_scancode</span><span class="p">(</span><span class="n">get_scancode</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">));</span><span class="w">
</span><span class="w">            </span><span class="n">callback</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">EventData</span>::<span class="n">OnKeyInput</span><span class="p">(</span><span class="n">DataOnKeyInput</span><span class="p">{</span><span class="w"> </span><span class="n">keycode</span><span class="p">,</span><span class="w"> </span><span class="n">is_repeated</span><span class="w"> </span><span class="p">}),</span><span class="w"> </span><span class="n">refhwnd</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">        </span><span class="c1">//...
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">	
</span><span class="w">    
</span><span class="w">    </span><span class="c1">//...
</span><span class="c1"></span><span class="w">    </span><span class="n">DefSubclassProc</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div>
<p>子HWNDを全部取得したら、次は子HWNDをサブクラス化します。ここでクロージャーの参照回数を子供＋自分分保持させるために悪さをしていきます。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">type</span> <span class="nc">SubclassCallback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="n">EventType</span><span class="p">,</span><span class="w"> </span><span class="n">EventData</span><span class="p">,</span><span class="w"> </span><span class="n">EventRefHwnd</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">LocalSetSubclassLParam</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">callback_ptr</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">SubclassCallback</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">subclass_id</span>: <span class="nc">UINT_PTR</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;system&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">bind_proc_to_children</span><span class="p">(</span><span class="n">h</span>: <span class="nc">HWND</span><span class="p">,</span><span class="w"> </span><span class="n">l</span>: <span class="nc">LPARAM</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span>
<span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">params</span>: <span class="kp">&amp;</span><span class="nc">LocalSetSubclassLParam</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;*</span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">LocalSetSubclassLParam</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">cb_rc</span>: <span class="nc">Rc</span><span class="o">&lt;</span><span class="n">SubclassCallback</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">from_raw</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">.</span><span class="n">callback_ptr</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Increase ref-count and Do not let it decrease ref-count.
</span><span class="c1"></span><span class="w">    </span><span class="c1">// Increased ref-count should be reset to 0 calling unbind_event_handler fn.
</span><span class="c1"></span><span class="w">    </span><span class="n">mem</span>::<span class="n">forget</span><span class="p">(</span><span class="n">cb_rc</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">SetWindowSubclass</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">win32_subproc</span><span class="p">),</span><span class="w"> </span><span class="n">params</span><span class="p">.</span><span class="n">subclass_id</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="p">.</span><span class="n">callback_ptr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">UINT_PTR</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">mem</span>::<span class="n">forget</span><span class="p">(</span><span class="n">cb_rc</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="mi">1</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">callback_rc</span>: <span class="nc">Rc</span><span class="o">&lt;</span><span class="n">SubclassCallback</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">event_f</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">callback_box</span>: <span class="nb">Box</span><span class="o">&lt;*</span><span class="k">const</span><span class="w"> </span><span class="n">SubclassCallback</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Rc</span>::<span class="n">into_raw</span><span class="p">(</span><span class="n">callback_rc</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">callback_ptr</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">SubclassCallback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">into_raw</span><span class="p">(</span><span class="n">callback_box</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">local_params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LocalSetSubclassLParam</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">callback_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">subclass_id</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...
</span><span class="c1"></span><span class="n">EnumChildWindows</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">bind_proc_to_children</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">local_params</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">LocalSetSubclassLParam</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">LPARAM</span><span class="p">);</span><span class="w">
</span></code></pre></div>
<ol>
<li>まずクロージャーをdyn Fn（Fn traitを実装している何らか）を引数traitとして持っているRc（C++11からの<code>std::shared_ptr&lt;&gt;</code>のようなもの）に入れます。</li>
<li>生成されたRcはすべてのチルドレンと自分HWNDがサブクラス解除されるまで消えなかればならないため、into_raw関数でわざと解除してRcのポインターをBoxでもう一度包んでBoxを作る（Boxとは<code>std::unique_ptr&lt;&gt;</code>のようなもんです）</li>
<li>作られたBoxさえも任意解除して、チルドレン巡回に使うデータに入れます。</li>
<li>bind_proc_to_childrenでは３で入れられたデータを逆参照してサブクラス化します。逆参照されたRcは手動でカウントを一つ増やします。ただし、コールバックがリターンされて参照カウントが基に戻ることを防ぐため、<code>mem::forget</code>でDropを呼ばないようにします。</li>
</ol>

<p>これでRcの参照カウントをチルドレン分上げつつ、各子HWNDにサブクラス化をすることが出来ました。最後にルートとなるHWNDもサブクラス化します。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Bind subclass procedure to top target window hwnd.
</span><span class="c1"></span><span class="n">SetWindowSubclass</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">win32_subproc</span><span class="p">),</span><span class="w"> </span><span class="n">subclass_id</span><span class="p">,</span><span class="w"> </span><span class="n">callback_ptr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">UINT_PTR</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">EVENT_HANDLER_ID</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></code></pre></div>
<p>外側では以下のようなコードでサブクラスに必要な引数と、サブクラスで指定されたコールバック関数でまとまったデータを処理するためのクロージャーを書きます。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">hwnd_hevent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">windows</span>::<span class="n">bind_event_handler</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="o">&amp;</span><span class="n">hwnd</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="o">|</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">_ref_hwnd</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">msg</span><span class="w">
</span><span class="w">        </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">EventType</span>::<span class="n">OnKeyPressed</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">matches</span><span class="o">!</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">EventData</span>::<span class="n">OnKeyInput</span><span class="p">{..}));</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">as_value_on_key_input</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;OnKeyPressed {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">},</span><span class="w">
</span><span class="w">            </span><span class="n">EventType</span>::<span class="n">OnKeyReleased</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">matches</span><span class="o">!</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">EventData</span>::<span class="n">OnKeyInput</span><span class="p">{..}));</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">as_value_on_key_input</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;OnKeyReleased {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">},</span><span class="w">
</span><span class="w">            </span><span class="n">EventType</span>::<span class="n">OnMouseWheel</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">matches</span><span class="o">!</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">EventData</span>::<span class="n">OnMouseWheel</span><span class="p">{..}));</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">as_value_on_mouse_wheel</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;OnMouseWheel {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">},</span><span class="w">
</span><span class="w">            </span><span class="n">EventType</span>::<span class="n">OnMouseButtonPressed</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">matches</span><span class="o">!</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">EventData</span>::<span class="n">OnMouseButtonInput</span><span class="p">{..}));</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">as_value_on_mouse_button_input</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;OnMouseButtonPressed {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">},</span><span class="w">
</span><span class="w">            </span><span class="n">EventType</span>::<span class="n">OnMouseButtonReleased</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">matches</span><span class="o">!</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">EventData</span>::<span class="n">OnMouseButtonInput</span><span class="p">{..}));</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">as_value_on_mouse_button_input</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;OnMouseButtonReleased {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">},</span><span class="w">
</span><span class="w">            </span><span class="n">EventType</span>::<span class="n">OnMouseMove</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">matches</span><span class="o">!</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">EventData</span>::<span class="n">OnMouseMove</span><span class="p">{..}));</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">as_value_on_mouse_move</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;OnMouseMove {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">},</span><span class="w">
</span><span class="w">            </span><span class="n">EventType</span>::<span class="n">OnWindowResize</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">matches</span><span class="o">!</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">EventData</span>::<span class="n">OnWindowResize</span><span class="p">{..}));</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">as_value_on_window_resize</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;OnWindowResize {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">},</span><span class="w">
</span><span class="w">            </span><span class="n">EventType</span>::<span class="n">OnWindowClose</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">windows</span>::<span class="n">stop_thread_dispatch</span><span class="p">();</span><span class="w"> </span><span class="p">},</span><span class="w">
</span><span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{},</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">});</span><span class="w">
</span></code></pre></div>
<p>逆にサブクラス解除する時には、渡された<code>EventHandler</code>タイプのインスタンスの各HWNDと、subclass_idでサブクラスIDに該当するサブクラスがあるかを確認し、RemoveWindowSubclassで解除すればOKです。また、コールバック関数のポインター変数もBox→Rcに逆参照して参照カウンターをへらします。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handle</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">handler</span><span class="p">.</span><span class="n">handles</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ptr</span>: <span class="nc">DWORD_PTR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetWindowSubclass</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="p">.</span><span class="n">proc_id</span><span class="p">(),</span><span class="w"> </span><span class="n">subclass_id</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="w">        </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">panic</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Parent of handler was either freed or is already unbound.&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">callback_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">SubclassCallback</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">callback</span>: <span class="nc">Rc</span><span class="o">&lt;</span><span class="n">SubclassCallback</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">from_raw</span><span class="p">(</span><span class="o">*</span><span class="n">callback_ptr</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">mem</span>::<span class="n">drop</span><span class="p">(</span><span class="n">callback</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">RemoveWindowSubclass</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="p">.</span><span class="n">proc_id</span><span class="p">(),</span><span class="w"> </span><span class="n">subclass_id</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Finally free the pointer of the pointer of callback.
</span><span class="c1"></span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">from_raw</span><span class="p">(</span><span class="n">callback_ptr</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></code></pre></div>
<h2 id="windowを見せる">Windowを見せる</h2>

<p>C/C++と同じ方法でいけます。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ShowWindow</span><span class="p">(</span><span class="n">hwnd</span><span class="p">.</span><span class="n">hwnd</span><span class="p">(),</span><span class="w"> </span><span class="n">SW_NORMAL</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></code></pre></div>
<h1 id="最後に">最後に</h1>

<p>結局またC/C++へ戻ってしまうのですが（残念…）Rustで最大限に安全なコードを実装しながらC/C++のAPI設計で適用できるいくつかが見つかってかなり勉強になったと思います。</p>
]]></content>
		</item>
		
		<item>
			<title>AMD GCNアーキテクチャ文書を読んでメモ</title>
			<link>https://liliilli.github.io/posts/gcn_architecture_crash/</link>
			<pubDate>Fri, 19 Jun 2020 12:16:09 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/gcn_architecture_crash/</guid>
			<description>用語 略語 説明 VS Vertex Shader PS Pixel Shader (Fragment Shader) VLIW Very Long Instruction Word FLOPS FLoating point Operations Per Second GCN Graphics Core Next CU Compute Unit EU Export Unit ISA Instruction Set Architecture SIMD Single Instruction Multiple Data ALU Arithmetic Logic Unit AGU Address Generation Unit SALU Scalar Arithmetic Logic Unit VALU Vector Arithmetic Logic Unit APU Accelated Processing Unit PC Program Counter IB</description>
			<content type="html"><![CDATA[

<h2 id="用語">用語</h2>

<table>
<thead>
<tr>
<th>略語</th>
<th>説明</th>
</tr>
</thead>

<tbody>
<tr>
<td>VS</td>
<td>Vertex Shader</td>
</tr>

<tr>
<td>PS</td>
<td>Pixel Shader (Fragment Shader)</td>
</tr>

<tr>
<td>VLIW</td>
<td>Very Long Instruction Word</td>
</tr>

<tr>
<td>FLOPS</td>
<td>FLoating point Operations Per Second</td>
</tr>

<tr>
<td>GCN</td>
<td>Graphics Core Next</td>
</tr>

<tr>
<td>CU</td>
<td>Compute Unit</td>
</tr>

<tr>
<td>EU</td>
<td>Export Unit</td>
</tr>

<tr>
<td>ISA</td>
<td>Instruction Set Architecture</td>
</tr>

<tr>
<td>SIMD</td>
<td>Single Instruction Multiple Data</td>
</tr>

<tr>
<td>ALU</td>
<td>Arithmetic Logic Unit</td>
</tr>

<tr>
<td>AGU</td>
<td>Address Generation Unit</td>
</tr>

<tr>
<td>SALU</td>
<td>Scalar Arithmetic Logic Unit</td>
</tr>

<tr>
<td>VALU</td>
<td>Vector Arithmetic Logic Unit</td>
</tr>

<tr>
<td>APU</td>
<td>Accelated Processing Unit</td>
</tr>

<tr>
<td>PC</td>
<td>Program Counter</td>
</tr>

<tr>
<td>IB</td>
<td>Instruction Buffer</td>
</tr>

<tr>
<td>LRU</td>
<td>Least Recently Used</td>
</tr>

<tr>
<td>VGRP</td>
<td>Vector General Purpose Register</td>
</tr>

<tr>
<td>LDS</td>
<td>Local Data Share</td>
</tr>

<tr>
<td>GDS</td>
<td>Global Data Share</td>
</tr>

<tr>
<td>TMU</td>
<td>Texture Mapping Unit</td>
</tr>

<tr>
<td>TLB</td>
<td>Translation Lookaside Buffer</td>
</tr>

<tr>
<td>HSA</td>
<td>Heterogeneous System Architecture</td>
</tr>

<tr>
<td>DMA</td>
<td>Direct Memory Access</td>
</tr>

<tr>
<td>IOMMU</td>
<td>I/O MMU (I/O Memory Management Unit)</td>
</tr>

<tr>
<td>ACE</td>
<td>Asynchronous Compute Engines</td>
</tr>
</tbody>
</table>

<h2 id="本文-amd-graphics-cores-next-white-paper">本文 (AMD GRAPHICS CORES NEXT White Paper)</h2>

<p>p2）最初は完全な固定関数として使うようにデザインされたが、時間が経ってVSとPSの登場、そしてAMDでは並列処理を効率化させるためVLIW5とVLIW4構造のデザインを開発し性能を上げてきた。</p>

<p>これで2013年まで出た最高級グラボのTFLOPSは4TFLOPS（テラFLOPS）を超えて、モバイルも1TFLOPSを超えるようになる。</p>

<p>VLIW4デザインから一新されたGCNはCUのデザインを変えて性能を向上をした。</p>

<h3 id="compute-unit-overview">Compute Unit Overview</h3>

<p>p3）CUはGCNアーキテクチャでの基本的な演算ブロックだ。以前に使っていたISAも新しくされて、コンパイラそして開発者にもわかりやすい形となり、性能の安定性を確保している。</p>

<p>GCN以前のVLIWシリーズのシェーダー配列は複数のSIMDエンジンとして構成され、また各SIMDエンジンは16個のALUで構成されていた。各ALUは4、5個の独立した命令をVLIWに入れてまとめた形で処理することが出来た。（前はVLIW-4、後はVLIW-5）各SIMDエンジンはWavefrontという、64個の命令処理ができるもの（作業スレッド）を持ち、同時に1個のWavefrontを実行することが出来る。このデザインは特定したパイプラインでは高効率で動くが、ピクセルのフォーマットが多様化されて、またパイプラインが複雑になるにつれそれぞれ独立されて並列に実行できる命令をVLIWに組むことが難しくなって効率を上げにくくなった。</p>

<p>GCNでは各CUが4個の分離された頂点処理のためのSIMDを持って、各SIMDは同一な命令を処理する16個の作業スレッドを持っている。ただ、前のデザインみたいにまとまって1個のWavefrontになるのではなく、それぞれ別のWavefrontになれる。なのでもっと並列化が出来る。</p>

<p>効率化のためにGCNの各SIMDたちは<code>private</code>と<code>shared</code>のリソースを持ったり、共有している。命令バッファリング（Instruction Buffering）、VALUとレジスタなどはPrivateとして各SIMDに内蔵されている。Front-End、分岐ユニット、データキャッシュはSIMDの間で共有されている。</p>

<p>p4）GCNのCUの画像があるのでよく見ること。</p>

<p>またGCNで改善されたものは、メモリのCoherent Cachingがサポートされたことだ。GCNが登場づするまでGPUはメモリのCoherent（一貫性）を管理しない（すなわち外部メモリ変更による更新をしない）読み取り専用のキャッシュに依存しなければならなかった。なのでGPU中で複数のコアがやり取りをするためには、プログラマまたはコンパイラが明示的に同期化をしなければならなかった。デザイン的には簡単になるが、共有しているデータの同期化による性能低下があったのである。GCNは最初から汎用データがコア間共有されながら処理されることを念頭に置きながらデザインされた。そのためのCache Coherency ProtocolはGPUのL2キャッシュを通してデータを更新するようにし、性能向上と電力消費量の低下をした。</p>

<p>Coherencyと同時にGCNは仮想メモリも導入した。この仮想メモリはx86アーキテクチャをサポートする。これでCPUとGPUの間でデータを共有することが簡略化され、そして一つのポインターアドレスでCPUとGPUが参照出来るようになったそうだ。これでAMDのAPUでも効率の向上をしたらしい。</p>

<h3 id="cu-front-end">CU Front-End</h3>

<p>p5）GCNの各SIMDは40-bitのPCと、10Wavefront分のIBを持つ。というとCUは4個のSIMDを持つのでIBだけで40Wavefrontsを持つことになる。そしてGCNは32個のCUを持つため、最終的には同時に81,920個の作業スレッドが働くことになる。</p>

<p>4個までのCUが一つの組になり、32KBの4-way associativeのL1命令キャッシュとL2キャッシュを共有している。<em>[3]を見ること</em> キャッシュラインはx86と同じく64Bytesで、64bitsの命令を8個収めることが出来る。キャッシュが全部埋まったら、LRUによって新しい命令が入ることになる。</p>

<p>L1の命令キャッシュは4個のBankを持ち[4]、4個のCUに対して32Bytesの命令読出し（Fetch）を維持することが出来る。ただ、命令読出しは世代（age）、スケジューリングの優先順位、WaveのIBの活用によってSIMDたちの中で無作為にされる。</p>

<p>命令がWavefrontのバッファたちの中で発行されると、CUはRound-robin方式で4個のSIMDから一つを選び、10個のWavefrontから5個までの命令をEUへ実行するようにする。ただ<code>NOP</code>のような特殊な命令は他のユニットに任せることなくWavefrontから直接命令処理をする。また、CUはバリア命令を追跡するため16個のバッファリングを維持することができ、これによってWavefrontをSynchronizeさせる。</p>

<p>CUの末端部（Front-end）は「分岐（Branch）、SALU、VALU、スカラメモリ、ベクトルメモリ、そしてローカルデータシェアー、グローバルデータシェアー」の命令を処理する。しかし命令実行パイプラインに多くのSIMDが取り付くことを防ぐため、SIMDごとに同時に各タイプの一つの命令しか発行できないようになっている。また、命令順に実行するようにするため、各命令は違うWavefrontから発行されるようになっている。</p>

<p>CUは1サイクルに5個までの命令を、2つのレジスタファイル（Register File）を使って、6個までのベクトル演算装置とスカラ演算装置へ実行できる。VALUは汎用目的のグラフィック、またはコンピューター処理のために適合していて、SALUは分岐処理に適合している。</p>

<h3 id="scalar-execution-and-control-flow">Scalar Execution and Control Flow</h3>

<p>GCNで新しく実装されたスカラ（Scalar）パイプラインは、性能と電力効率で必須的な存在となっている。特に分岐処理をすることによって、GPUで分岐しょりをすることによる遅延などを防ぎ、性能低下をある程度防止する。</p>

<p>各CUは8KBのスカラレジスタファイル（Scalar Register File）を持ち、各SIMDが使えるために512個のブロックとして分かれている。また、スカラレジスタはSIMDの10個のWavefrontで共有される。Wavefrontはシステムの状態を保持する一部分を除き、112個のレジスタが割当できる。これをユーザーレジスタ（User Register）という。</p>

<p>レジスタは普段は32-bitsの値を保持できるが、連続で使ったら64-bitsまでの値を保持できる。例えば比較分岐をする時、比較した際の結果ビットをwavefrontの64個分更新するためには64-bitsのレジスタ（2個分）に必要となる。</p>

<p>1つ目でスカラパイプラインは16-bitsのオフセットを使って分岐（Conditional Branch）をハンドルしている。また、インターラプトと特定タイプの同期化をする時にも使われている。インターラプトはブレークポイントを貼ってデバッグをする際に使える新しい機能だ。</p>

<p>p6）2つ目ではAGUの役割<code>[5]</code>も果たしている。GCNのALUは64-bitsの長さを持つが、これで分岐処理によるジャンプ、関数呼び出しとリターンがもっとしやすくなっている。AGUによって移動する命令アドレスはPCで切り替わるかそれに値する処理がされている。</p>

<p>また分岐予測もSALUによって管理される。</p>

<p>スカラのL1キャッシュは読み取り専用だ。SALUが使われている所って大体分岐処理であるため、メモリに何かを書く状況がないためだ。このL1キャッシュは命令L1メモリキャッシュとほぼ構造が同じで、16KBのキャッシュは同様に4-way associativeであって、LRUアルゴリズムと64Bytesのラインを持つ。また4個のCUによって共有されて、L2キャッシュがあることも同じだ。そして各CUで1サイクルに16BytesのThroughputを持つ。</p>

<h3 id="vector-execution">Vector Execution</h3>

<p>既存のVLIWは一つのSIMDを持ち、その中に独立で演算される命令が組み込まれて実行される仕組みになっている。しかしこの構造はコンパイラがどのぐらいコードから生み出される命令を並行にばら撒いて実行させるようにするかによって性能が大きく違うことと、コード自体が並列化されにくいとしたら絶対的に性能が落ちることになる短所がある。</p>

<p>GDNアーキテクチャはWavefrontから予測できない並列化を避けるようにし、ちょうど良いぐらいの並列化をドライバーなどがやるようにして、性能の安定性を追求する。こうすることで汎用目的の処理でも性能が劣ることがあんまりなくなった。</p>

<h3 id="vector-registers">Vector Registers</h3>

<p>ベクトル演算のためのレジスタも4つの独立されたブロックに分かれている。以前のVLIW構造では一つのSIMDにあらゆる命令がまざって入るため、どでかく効率が悪いレジスタにしなければならなかった。</p>

<p>VGRPsは32-bits長さの64個のレーンを持つ。隣接したVGRPsは64ビットまたは128ビットに相当する値を構成されるために使えることもある。各SIMDはVGRPsのために64KBのパーティションを提供しているので、CU1個のVGRPsの数は同一である。（256個のVGRPs組が存在して、一つは32-bits＊64＝256Bytes？）</p>

<h3 id="vector-alus">Vector ALUs</h3>

<p>p7）各SIMDは16個のレーンで構成され、IEEE-754単精度浮動小数点数と倍精度浮動小数点数を支援する。また、性能低下の無いdenormals（アンダーフローされる浮動小数点の数前の数）などもサポートする。SIMDの各レーンは24-bitの整数演算、また単精度の積和演算・融合積和演算<code>[6]</code>（fused multiply-add）ができる。積和演算は<code>MAD</code>のような形として、<code>a := b * c + a</code>になる。融合積和とは、<code>b * c</code>をする時浮動小数点の値を丸めずに1命令で行い誤差をへらすことだ。</p>

<p>24-bitsの整数のMAD演算は作業グループの中でアドレスを演算する時に有用に使われる。一つのSIMDの64個の作業スレッドがVALUの演算を行うには4 Cyclesがかかる。</p>

<p>GCNは<code>SAD</code>と<code>quad-SAD</code>を追加し<code>[7]</code>、映像または画像処理の性能を向上しようとした。SADは画像がどれだけ似ているかを検出する時に使われるアルゴリズムで、画像の中で異なるブロックの中の互いのピクセルの絶対差を求め最後に全部合わせて似ているかの指標として使う。またRGBA 8-Bitsの色が入った画像でもSADが出来るようにquad-SADを追加した。</p>

<p>これを使ってCUはクロックごとに256個のピクセルの処理ができた。こういったものはビデオ検索、または動作認識などに使われるそうだ。</p>

<p>倍精度と32-Bitsの整数処理は処理効率が劣る。倍精度浮動小数点の場合、単精度より1/2から1/16まで性能が落ちる可能性がある。またドライバーなどのサポートによって性能が違うかもしれない。</p>

<h3 id="local-data-share-atomics">Local Data Share &amp; Atomics</h3>

<p>LDSというメモリ領域はグラフィックレンダリングでの補完または作業グループ（Work-group）の同期化のためにほぼ第3のRegister Fileとして扱わなければならない。（重要）GCNのLDSは16または32個のBanksを持って、64KBに拡張された。各Bankは32-Bits長さのエントリーが512個並んでいる。</p>

<p>LDSの用途としてレンダリングの方ではテクスチャーデータの補完などに使われる。その時に同時データ接近による衝突は起こらない。Compute Shaderの場合にはWork-Groupsの中で共有されたデータなどを読み込んだり書き込んだりする時にLDSが使われる。これによってデータの接近によるキャッシュの汚染が避けるようになった。</p>

<h3 id="export">Export</h3>

<p>EUはCUからGDS（Global Data Share）そして固定関数のグラフィックHWへの窓口だ。CUで演算が終わった時、一般的に結果はグラフィックパイプラインのほかのユニットへ転送される。EUはプログラミング可能なステージから得た結果をテセレーションまたはRasterization、Back-endなどに書き込む役割をする。</p>

<p>GDSはLDSとは基本的には同じものだが、全体CUが共有しているのですべてのWavefrontの間の同期化を制御する。</p>

<h3 id="vertor-memory">Vertor Memory</h3>

<p>各CUの各SIMDsは1クロックに128個の単精度浮動小数点数の演算が出来る。既存のVLIW-4からGCNに移行してキャッシュの構造で一番変わったのはグラフィック描画に特化されたデザインから汎用レンダリングまたはx86のプロセッサーと互換ができるようプログラミングな構造になったことだ。代表的なものがCUで、GCN全般のシステムまで拡張している。</p>

<p>p9）Figure 5を見ること。</p>

<p>上にもあったが、L1データキャッシュは16KB、4-way associative、64Bytesライン、そしてLRUアルゴリズムを持つ。またL2データそして他のキャッシュとのデータと同じ（Coherent）データ内容を持つ。</p>

<p>データL1（L1D）はDirtyマスクがついた「Write-through」<code>[8]</code>（メモリとキャッシュへの書き込みが同時に終わる）そして「Write-allocate」（Write-missの際に下のデータブロックが上のキャッシュにOverwrite）を採択している。~（＋ということは実際にはWrite-throughではなく、Write-backなのでは…？）~<code>[9]</code>64Wavefrontに該当するキャッシュラインは命令が終わるとL2へOverwriteされる。またL1のキャッシュラインがDirtyかではないかによってL2へ放出されるかないかが分かれる。</p>

<p>AGU（Address Generation Unit）が連続したアドレス（0x0, 0x4, 0x8…）を計算したらデータL1のキャッシュタグ（Cache-Tag）をたどる。それでCache hitが発生したら64Bytesのラインを全部読み取る。もしデータがすべて連続されていて一つのキャッシュラインに収まることが出来たら（With fully coalesced requests,）実際使ってるWavefrontは1/4ぐらいになる。読まれたキャッシュラインはvGRPsかLDSに保存される。</p>

<p>L1データへの書き込みはちょっと複雑で、データ自体が適切なフォーマットに変換しなければならないし、また書き込むアドレスもL1キャッシュへのHit、L2キャッシュへまで書き込むために癒合（Coalesced）される必要があるそうだ。もしCache missが発生したらL2それともそれに準ずるメモリでブロックを探す。</p>

<p>効率を上げるためにグラフィックレンダリングではある構造を再使用（？）している。まずAGUは1サイクルに4個のテクスチャアドレスを受け取り、nearest neighborsで16個のサンプリングアドレスを返す。このサンプリングアドレスがL1データに接近し読み取ったデータをTMUから圧縮開放する。そしてフィルターによってフォーマットに合わせた4個の補完されたテクセルがベクトルのRegister Fileに保存される。</p>

<h3 id="l2-cache-coherency-and-memory">L2 Cache、Coherency and Memory</h3>

<p>p10）L2キャッシュはGCNGPUのcoherencyを維持する中核だ。L2キャッシュはCUまたはCUたちの間で共有されているL1命令とデータ、そしてスカラキャッシュのbackstop（補助？盗み取り？）役をしている。L2キャッシュはいくつかのブロックなどに分離されて、CUからCrossbarを通してメモリへアクセスされるようになっている。</p>

<blockquote>
<p>Figure 6を見ること。</p>
</blockquote>

<p>L1と同様にL2も仮想アドレスをサポートしているのでTLBは要らない。（なんかVirtualだとしたらPhysicalに変換するためにTLBが要るかもと思ったらそうでもなかった…）<code>[11]</code> そしてL2は16-way associativeでL1と同じく64Bytesキャッシュライン、LRUアルゴリズムを持つ。しかしL1とは違ってここでは「Write-Back」「Write-Allocate」ポリシーを使う。小さく小分けされたL2メモリブロックは64~128KBの空間を持つ。</p>

<p>L2キャッシュがCoherentすることにより、それぞれ違うWavefrontの間の同期化またはアトミック操作（Atomic Operation）が実行できるように適合な場になった。もちろんWavefrontの中のみならLDSだけでアトミック操作することが可能である。しかし違うWavefrontの間に同期化をすべきならL2キャッシュを使わなければならない。L2スライスは1サイクル、1キャッシュラインに16個のアトミック操作をする事ができる。</p>

<p>理論上ではL1データは作業グループの中でのメモリ一貫性を保つ。Wavefrontが開放される時、または同期化のためのバリアーが解かれた時データがL2にかかれてWavefront間のL2メモリ一貫性が維持される。</p>

<p>またこのキャッシュ構造はx86のマイクロプロセッサーと互換するようにデザインされた。GCN仮想メモリシステムはx86アドレス空間のための基本ページ単位である4KBのページをサポートしている。またキャッシュラインが64Bytesであることもx86のプロセッサーと互換するためだそうだ。</p>

<p>メモリコントローラーは64-Bits長さで2つの独立したGDDR5またはDDR3の32-Bitsメモリチャンネルで構成されている。</p>

<h3 id="programming-model">Programming Model</h3>

<p>p11）GCNの新しいISAはHSAを基にしている。HSAとはハードウェアに拘らないアーキテクチャとして（決まった仕様はあるので完全独立ではない）CPUとGPUがコミュニケーションする仕様だ。HSAはHSAIL（Intermediate Language）というバーチャルISAを使って最終的にはHWの機械語にコンパイルするようにしている。<code>[12]</code></p>

<h3 id="system-architecture">System Architecture</h3>

<p>GCNは双方向のDMAエンジンを搭載し、PCI Express™ 3.0を使ってデータを双方向に転送することが出来る。またGCNはIOMMUを搭載し、x86のアドレスをGPUへマッピングすること簡単に出来る。ということはGCNのDMAエンジンはGPUとCPUのメモリページへの接近が追加オーバーヘッドなしで行われる。</p>

<p>GCNのCommand Processorはドライバーから高級言語のAPIを読み取り、各パイプラインへマッピングする役割を持っている。GCNでは主に2つのパイプラインで構成されている。一つはACEと呼ばれるもので、Compute Shaderを管理している。Graphics Command Processorは従来のシェーダーと固定関数を管理する。ACEとGCPは一緒に各シェーダーステージのためのCommand Streamを持ち、GCN仕様のHWでマルチタスキングを行う。</p>

<p>そのマルチタスキングのためにGCNでは仮想メモリが実装された。ということでGPUのVRAMの中で複数のアプリケーションのメモリが安全に共存できる。</p>

<p>ACEsはCompute Shaderに対してスケジューリングとリソースの割当を担当する。各ACEはキャッシュまたはメモリからコマンとを持ってきて、スケジューリングのためのTask queueを形成する。各タスク（Task）は優先順位を持っており、ドライバーからそれらを制御している。</p>

<p>各サイクルでACEは作業グループと一つのWavefrontを作り依存性が無い限り無作為に動作する。</p>

<p>またACEsは普通はそれぞれ独立に動くが、64KB~128KBのGDS、メモリまたはキャッシュ接近によって同期化されることがある。それにより各ACEsはTask Graphを形成し、お互いに依存性を持つようになる。なので実際にはACEsはグラフィックスパイプラインの特定ステージ、それとも他のACEに依存されるかするようになり、途中で止まったり違うTask queueの依存性を持たないACEが動いたりする。</p>

<h3 id="graphics-architecture">Graphics Architecture</h3>

<p>Graphics Command Processorは従来のグラフィックスパイプラインを構想している。GCNのピクセルパイプラインはスクリーン空間を分割して独立したタイルとしてレンダリングする。各ラスタライザは1サイクルに一つの三角形を分析し、最大16ピクセルを生み出す。</p>

<p>またGCNでは各グラフィックパイプラインは並列に動く。これはACEsと同じであるし、すなわち依存性も生まれる。</p>

<h2 id="参照">参照</h2>

<p><a href="https://www.techpowerup.com/gpu-specs/docs/amd-gcn1-architecture.pdf">AMD GRAPHICS CORES NEXT White Paper</a></p>

<p><a href="https://www.slideshare.net/DevCentralAMD/gs4106-the-amd-gcn-architecture-a-crash-course-by-layla-mah">GS-4106 The AMD GCN Architecture - A Crash Course, by Layla Mah</a></p>

<p><a href="http://csillustrated.berkeley.edu/PDFs/handouts/cache-3-associativity-handout.pdf">[3] Cache Associativity</a></p>

<p><a href="https://en.wikipedia.org/wiki/Memory_bank">[4] Memory Bank</a></p>

<p><a href="https://en.wikipedia.org/wiki/Address_generation_unit">[5] Address Generation Unit</a></p>

<p><a href="[https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation#Fused_multiply%E2%80%93add](https://en.wikipedia.org/wiki/Multiply–accumulate_operation#Fused_multiply–add)">[6] Multiply-accumulate operation</a></p>

<p><a href="https://www.google.com/search?q=sum+of+absolute+difference&amp;oq=sum+of+absol&amp;aqs=chrome.0.0j69i57j0l6.2572j0j4&amp;sourceid=chrome&amp;ie=UTF-8">[7] Sum of absolute difference</a></p>

<p><a href="https://en.wikipedia.org/wiki/Cache_(computing)">[8] Cache_(Computing) Writing policies</a></p>

<p><a href="http://web.cs.iastate.edu/~prabhu/Tutorial/CACHE/interac.html">[9] Interaction Policies with Main Memory</a></p>

<p><a href="https://stackoverflow.com/questions/5041328/in-cuda-what-is-memory-coalescing-and-how-is-it-achieved">[10] In CUDA, what is memory coalescing, and how is it achieved?</a></p>

<p><a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer">[11] Translation Lookaside Buffer</a></p>

<p><a href="https://pc.watch.impress.co.jp/docs/column/kaigai/547768.html">[12] AMD GPUとモバイルGPUにで同じプログラムを走らせるHSA構想</a></p>
]]></content>
		</item>
		
		<item>
			<title>最近簡単に読んだポスト</title>
			<link>https://liliilli.github.io/posts/week25_2020/</link>
			<pubDate>Fri, 19 Jun 2020 11:39:40 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/week25_2020/</guid>
			<description>Avoid double negation, unless&amp;hellip; !!x == xのような構文を使わないこと。代わりにenabledに終わる（何かが有効化されたか？）ように関数またはフラグなどを作って渡すこと</description>
			<content type="html"><![CDATA[

<h2 id="avoid-double-negation-unless-https-asawicki-info-news-1729-avoid-double-negation-unless"><a href="https://asawicki.info/news_1729_avoid_double_negation_unless">Avoid double negation, unless&hellip;</a></h2>

<ul>
<li><code>!!x == x</code>のような構文を使わないこと。代わりに<code>enabled</code>に終わる（何かが有効化されたか？）ように関数またはフラグなどを作って渡すこと。

<ul>
<li><code>disabled</code>になっちゃうと二重で解釈しなかればならないんで混同してしまう。</li>
</ul></li>
<li>よって、<code>enabled</code>がデフォルトにする。フラグの値も<code>0</code>または有効化されたフラグ組をデフォルト値として、ユーザーがフラグで<code>disabled</code>していくようにロジックを組む方が良いらしい。原文では<code>D3D12_HEAP_FLAG_DENY_BUFFERS</code>を例としてあげてる。</li>
<li>互換性をしやすくサポートし、維持するため。全てを<code>enabled</code>にして、追加していく機能だけの<code>disabled</code>フラグで無効化させる方が逆よりコードを維持しやすいそうだ。グラフィックAPIのVulkan（<code>VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT</code>）もそんな感じでバージョンアップをしている。</li>
</ul>

<h2 id="rules-of-optimization-https-twitter-com-humus-status-1011964081069330432"><a href="https://twitter.com/_Humus_/status/1011964081069330432">Rules of optimization</a></h2>

<p>リプを見たら僕はこうしないと言ってる人もいるが…</p>

<ol>
<li>最初から性能低下をしないようなコーディング設計をすること</li>
<li>プロファイルをすること</li>
<li>性能分析による相関関係に気をつけること</li>
<li>どんなデータが入って処理されるかをわかること</li>
<li>使っているハードウェアについてわかること</li>
<li>コンパイラは万能ではないから、コンパイラが最適化をしやすくするようにすること</li>
<li>仮定をしたら検証すること</li>
<li>性能低下はみんなの責任</li>
</ol>

<h2 id="tips-on-english-http-kwangkeunyi-snu-ac-kr-paper-english-tip-html"><a href="http://kwangkeunyi.snu.ac.kr/paper/english-tip.html">Tips on English</a></h2>

<ul>
<li>「一般名詞＋固有名詞」なら<code>the</code>などは付けない。逆ならつける。ということは略語が固有名詞なら<code>the</code>を付けないで、一般名詞ならつけるのと同じ。ただ略語を後で使い回す時には<code>the</code>を付けてもいいか…</li>
<li>「single X」なんとかの前にはいつも<code>a</code>をつける。</li>
<li>「require」は「誰」と「何か」を指す目的語をつける。</li>
<li>「due to」はBE動詞の後に付いてくる</li>
<li>「consider」は「regard」とは違って<code>as</code>をつけない</li>
<li>「such as」≒「for example」、「like」≒「similar to」</li>
<li>「various」はいつも複数型が付いてくる。<code>various balances</code></li>
<li>「usage」よりは「use」<code>the use</code>などを使うこと。似ているようで実は違う言葉</li>
<li>「the previous one」は前に言及されていなかった時。「the former」はそうでない場合</li>
<li>「present」「show」は後にhowなどから始めずに名詞を入れると良い。</li>
<li>「as follows」「in the following&hellip;」などなど</li>
<li>「much」は肯定文ではあんまり使わないイメージ</li>
<li>「enough」は形＋enough toとして。そうでない場合には「sufficient to」…として。</li>
<li>「a number of」≒「many」だが、どちらかに傾いていないものを指す。</li>
<li>「as」も「because」のような用途として使えるが、意味は若干弱い感じになる。また文章の前に出た時には「for」でも使える。<code>for a similar example, consider...</code></li>
<li>「, which&hellip;」は「that&hellip;」より弱いし、必要ない説明が補足で付いてくるようなニュアンスを受ける。</li>
<li>「whether or not」構文は「or not」を前に置換してそれっぽくする</li>
</ul>

<h2 id="rust入門-http-www-tohoho-web-com-ex-rust-html"><a href="http://www.tohoho-web.com/ex/rust.html">Rust入門</a></h2>

<p>Rust言語の基本的な文法などをちゃんとまとめたサイト。忘れているうちに見ると良いかも。</p>
]]></content>
		</item>
		
		<item>
			<title>Low-level shader optimization for next-gen and D3D11のメモ</title>
			<link>https://liliilli.github.io/posts/shader_opti_memo_2/</link>
			<pubDate>Thu, 18 Jun 2020 10:27:48 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/shader_opti_memo_2/</guid>
			<description>メモの基になる原文は2014年GDCで発表されたもので、翻訳ミスによる間違いがある可能性があります。また、GCN（AMD）アーキテクチャの重</description>
			<content type="html"><![CDATA[

<p>メモの基になる<a href="https://www.gdcvault.com/browse/gdc-14/play/1020352">原文</a>は2014年GDCで発表されたもので、翻訳ミスによる間違いがある可能性があります。また、GCN（AMD）アーキテクチャの重点的に扱っているので、NVIDIAなどのハードウェアについては挙動が違うかもしれません。</p>

<hr />

<h1 id="本文">本文</h1>

<p><a href="https://liliilli.github.io/posts/shader_opti_memo/">Low Level Thinking in High Shader Languages</a>の原文が出てから１年後、2014年に現世代（Xbox One、PS4）で搭載されたGCNアーキテクチャの登場、DirectX11の本格的な使用（当時SteamでのD3D11使用割合が70%）によって以前までの最適化も新しく考えなかればならなくなったそうだ。</p>

<h2 id="introduction-more-lessons">Introduction ~ More Lessons</h2>

<ul>
<li>Xbox One（Durango）、PS4（Orbis）はAMDのスーパーSIMDのGCNを使っている。（GCNの前まではVLIWを使い回していた）＋次世代もAMDのNAVI（GCN1.5として分類されるらしい）を使ってるので基本的な骨子は変わらないのでは…と</li>
<li>コンパイラが高級言語で書いたコードをなんでも最適化してくれると思わないでほしい。コンパイラは文法的な部分を破壊せず出来るだけの最適化だけ行う。</li>
<li>以前まではできれば<code>MAD</code>命令になるようにコードを書くべきであった。</li>
<li>スカラとベクトルの演算を分離すべき。ビルトイン関数の中ではベクトルとスカラを混じって使ってる実装があるので、注意すべき。</li>

<li><p>VLIWを採用したアーキテクチャの場合には演算の依存性が強いので、できれば分類して「（）」を取ること。</p></li>

<li><p><code>abs()</code>と<code>-</code>符号（Negation）を使う際には既存の変数に、<code>saturate()</code>は演算したものを入れて使わなければ命令の最適化がされない。</p></li>

<li><p><code>rcp()</code>、<code>rsqrt()</code>、<code>sqrt()</code>、<code>exp2()</code>、<code>log2()</code>、そして一般三角関数はHWにマッピングされている。ただ、逆三角関数は慎重に使うこと。</p></li>

<li><p>高級言語での最適化はローレベルの最適化に影響をする。</p></li>
</ul>

<h2 id="a-look-at-modern-hardware-sampling-a-cubemap">A look at modern hardware ~ Sampling a cubemap</h2>

<p>キューブマップから３次元UVWでサンプリングをするコードがあるとして、</p>
<div class="highlight"><pre class="chroma"><code class="language-hlsl" data-lang="hlsl">TextureCube Cube;
SamplerState Samp;

float4 main(float3 tex_coord: TEXCOORD) : SV_Target
{
	return Cube.Sample(Samp, tex_coord);
}</code></pre></div>
<p>D3D9までは射影マッピング（<code>tex2Dproj</code>）と同じく、一つの命令としてテクセルをサンプリングすることが出来た。しかしD3D10からは射影マッピングをさせる関数がなくなり、実装するためには直接<code>w</code>で割り算しなければならなかった。</p>

<p>ハードウェアが発展するにつれて射影マッピングなどをするための特殊なトランジスターなどを植え込む必要がなくなり、その代わりにいくつかの演算で同じことを出来るようALUをもっと植え付けるようになったそうだ。</p>

<p>これはキューブマップも同じで、キューブマップで使うUVWを平準化（ノーマライズ）するに特殊なトランジスターなどを使わず以前より沢山になったALUの一部を使って演算させるようになったらしい。もちろん原文（p5）の右画像のバイトコードは、命令が一つしか生成されなくてこれでOKのようだが、実際に生成されるコードは結構グロいようだ。（もちろんハードウェアによって生成されるインストラクションはそれぞれ違う）</p>

<p>画像ではベクトル演算が15個、スカラ演算が6個、テクスチャに接近して色をとり、またそれを返す命令がそれぞれ1個で色々と膨らんでいることがわかる。</p>

<h2 id="hardware-evolution">Hardware evolution</h2>

<p>固定関数（Fixed Function）のためのユニットがALUに編入されつつある傾向が持続しているそうだ。<code>D3D11_FILTER</code>（ミップマップのフィルタリング）で線形補間などをすることもD3D11からはALUに任せているらしい。（またハードウェアによって挙動は違うかもしれない）</p>

<p>Vertex Fetchも見た目は固定関数で、実はシェーダーの中でFetchingを行っているそうだ。（前世代のXbox 360は既にやっていたと…）</p>

<blockquote>
<p><a href="https://stackoverflow.com/questions/56581141/direct3d11-gradient-instruction-used-in-a-loop-with-varying-iteration-forcing">https://stackoverflow.com/questions/56581141/direct3d11-gradient-instruction-used-in-a-loop-with-varying-iteration-forcing</a></p>
</blockquote>

<p>射影とキューブマップのための演算もALUに移り、テクスチャのサンプリングをする時に内部で使う<code>ddx/ddy</code>などのグラディエント（Gradient）もGCNでは最終的にはALUの方で演算されるようになったそうだ。</p>

<p>こういった固定関数のような要素たちがALUの演算に全部依存することになって、比較的コストが増えてしまってるので、それに関する注意もやらざるを得なくなった。</p>

<p>また以前までのGPUハードウェアは内部でいくつかの全域状態を保持するためのレジスターなどを持って、そこからハードウェアが必要となる時に読んだりして演算を処理したらしい。（多分SM3までの話だと思う）最新（当時）のハードウェアはそれがなくなり、ほぼすべてのリソースをVRAMメモリまたはL1、L2キャッシュから読み込んで演算しなければならない。（Constant Bufferなどが生まれた理由かな…と思ってる）</p>

<p>またSM6（D3D12）になってもリソースを割り当てる時にはスロット（Slot）を書かなければならないが、実際のHWではスロットというのはもうなくなり、その代わりにメモリにスロットの代わりに使えるリストを作って、そこにシェーダーのリソースまたは何らかのポインターを入れて使うようにしているそうだ。</p>

<p>ということは、数の制約がなければシェーダーから接近できるリソースの数の制約っていうのはもうなくなっていたということである。また、リソースのアクセスには関連したサンプラーの状態（Sampler state）とリソーステクスチャへのディスクリプタ（Descriptor）への明示的に参照をするための追加コストが要るようになったことでもある。しかしGCNアーキテクチャではVALUが動いてる途中で独立的にSALUでやってくれるのでコストはないらしい。</p>

<p>またGCNのCompute Unitは完全な無状態（Stateless）である。ということで一つのCompute Shaderで使うリソースなどはほかのCompute Shaderに干渉されてなく、データレースなどをうまくコントロールすればほぼ並列でシェーダーを動作させることが出来るという。</p>

<p>しかしGraphics pipelineはCompute Shaderとは違ってパイプライン制御のための状態を保持しなければならないため、並列に演算させることは出来ないらしい。（RDNA2とかAmpereではどうなのかな）</p>

<h2 id="null-shader-not-so-null-shader-anymore">NULL shader ~ Not so NULL shader anymore</h2>
<div class="highlight"><pre class="chroma"><code class="language-hlsl" data-lang="hlsl">float4 main(float4 tex_coord: TEXCOORD0) : SV_Target
{
	return tex_coord;
}</code></pre></div>
<p>NULL shaderはハードウェア上でAPIの基本的な基本的な特性を把握するに適切だ。原文によれば、AMDのD3D10ではR0レジスタをピクセルに書き込むだけの一つ命令で終わるが、AMDのD3D11からは補完（interpolation）自体がシェーダーの方で行っているため、p10の画像のようにインストラクションが増えたことがわかる。（またGCNの最後でf32→f16のexport conversionをしていることもわかる）</p>

<p>ということで、AMDのD3D11でD3D10のようなNULL Shaderを作るには以下のようにしなければならないらしい。</p>
<div class="highlight"><pre class="chroma"><code class="language-hlsl" data-lang="hlsl">float4 main(float4 scr_pos: SV_Position) : SV_Target
{
	return scr_pos;
}

// in GCN...
// exp mrt0, v2, v3, v4, v5 vm done (v0 and v1 are for barycentric coords for interpolation)
// s_endpgm</code></pre></div>
<blockquote>
<p><a href="https://www.dictionary.com/browse/freebees">https://www.dictionary.com/browse/freebees</a></p>
</blockquote>

<h2 id="shader-inputs">Shader inputs</h2>

<p>シェーダーを実行するスケジューラでは書くシェーダーステージごとにコストがないリソースを用意している。上のPSコードで使った<code>SV_Position</code>もその一部である。</p>

<ul>
<li>VS - Vertex Index（SV_VertexID）</li>
<li>PS - Barycentric coordinates、SV_Position</li>
<li>CS - SV_DispatchThreadID、SV_GroupID</li>
</ul>

<p>しかし使っているハードウェアまたはAPIによって上のリストとはサポートするものが違うかもしれない。兎に角、コストがないリソース以外のリソースはメモリに載っており、接近しようとしたらコストが発生する。</p>

<p>また前述の通りAPIはVertex Fetchを固定関数の扱いしているが、GCN以降のHWでは固定関数ではなくなり、シェーダーから直接命令を叩いて実行するようになった。実はこれはXbox 360でも同じでシェーダーから頂点をFetchしているそうだ。ただ、Xbox 360の場合にはそれを実現するための大量のインストラクションを入れておかないといけないらしく、相当コストがあったそうだ。</p>

<p>GCNでは普通に<code>s_swappc_b64</code>というSubroutineにジャンプする命令を使って頂点を取得している。しかしVertex組を使わないとこのジャンプはいらないためなくなっている。</p>

<p>またドライバーソフトはリソースの数が少なく、16個のユーザーSGPR（Scalar General Purpose Register）に収めることが出来たら、ポインターでリソースを探させるのではなくリソースのディスクリプタを直接シェーダーの中に入れて参照させる。しかしテクスチャのディスクリプタは８SGRPを消耗するため、１個だけ入れられるっていう結構厳しい感じはある。</p>

<p>p17）昔にはUV座標の補完の命令を減らすためにUV２個を<code>float4</code>のようなベクトルに全部入れとく最適化があったが、GCNでは通用しないらしい。すなわち最適化してないコードとコストが同じになってしまう。解決策は低数値に補完をしないようにフラグをかけることである。</p>

<p>また<code>SV_Position</code>のことだが、短いコードなどで使おうとするとシステムから<code>SV_Position</code>を生成する時間によってボトルネックになることがあるそうだ。勿論<code>SV_</code>系は予めシェーダーのレジスタにロードされるようになるため、シェーダーから見るとコスト無しに見えるけれど実際にはそうではないらしい。長いコードで使うのは、どこかでの要素によってボトルネックが掛かることがある可能性が高いため、気にしなくて良いらしい。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-struct">https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-struct</a></p>

<p>Do not perform perspective-correction during interpolation. The <strong>noperspective</strong> modifier can be combined with the <strong>centroid</strong> modifier.</p>
</blockquote>

<p>そして属性として付けられる<code>[noperspective]</code>はGCNではあんまり影響がないそうだ。ただ、Rasterizer以前の段階で<code>w</code>をPSまで持っていって、そこで割り算などを使う時にはこれを入れると<code>xyz(w)</code>へのPerspective-Correctionをしないため、ALUの軽減が低下するらしい。</p>
<div class="highlight"><pre class="chroma"><code class="language-hlsl" data-lang="hlsl">float4 main(nointerpolation float4 tc: TC) : SV_Target
{
	return tc * rcp(tc.w);
}</code></pre></div>
<p>GCNアーキテクチャではboolが実装されていないらしく、そして全てのレジスタは32bitであるため<code>SV_IsFrontFace</code>のような<code>bool</code>は<code>0xFFFFFFFF</code>か<code>0x0</code>になる。これを使って<code>back-face lighting</code>が最適化できる。</p>
<div class="highlight"><pre class="chroma"><code class="language-hlsl" data-lang="hlsl">return face ? normal : -normal;
// or...
return asfloat(BitFieldInsert(face, asuint(normal), asuint(-normal)));</code></pre></div>
<h2 id="gcn-instructions">GCN instructions</h2>

<p>GCNアーキテクチャは以前のVLIWのようなものすごく長い命令を持たなく、32bitまたは64bitの命令だけを持つようになっている。そして命令一つに一つのスカラレジスタだけ読み込みできるようになったため、<code>MAD</code>が効率が悪くなる可能性ができてしまう。</p>

<p>ただ、ハードウェア的にコスト無しの定数をいくつ内蔵している。</p>

<ul>
<li>0.5, 1.0, 2.0, 4.0, -0.5, -1.0, -2.0, -4.0（Single-point floating）</li>
<li>[-64, 64]（Integer）</li>
</ul>

<p>最初にも技術したあったがGCNは以前までのAMDのVLIW-4から完全に変わったScalarベースのSIMDアーキテクチャである。ということはシェーダーで演算の単位をスカラ数値一つとして扱うことになる。（ベクトル命令がなくなるということではない）</p>

<p>しかしハードウェアではWavefrontという64個のスレッド組があって、スレッド一つ一つがスカラ値を演算するように構成されている。そしてこれをSIMD化されたベクトルという。ここでベクトル命令が働き出すそうだ。</p>

<p>ベクトル命令で構成されないスカラは、スカラ演算を行うユニットで演算される。そしてスカラ演算のためのユニットはベクトルとは独立的に動くので、もしシェーダーでベクトル演算またはテクスチャのサンプリングが多かったら負荷はあんまりない。</p>

<p>p22）ハードウェア命令とはどの命令かによって実行速度が違う。2014年以降のGPUでは単精度浮動小数点数の演算は割り算を除き最大限の速度で演算される。しかしGCNでは整数に限って32bitsの<code>MUL</code>と<code>MAD</code>はフールではない。</p>

<p>それと、タイプの変換は以前までのAMDでは1/4の速度だったが、GCNからは最大限の速度になる。また<code>floor()</code>、<code>ceil()</code>、<code>round()</code>も速度低下がない。</p>

<ul>
<li>Full Rate

<ul>
<li>Float add/sub/mul/mad/fma</li>
<li>Integer add/sub/mul24/mad24/logic</li>
<li>Type conversion, floor, ceil, round</li>
</ul></li>
<li><sup>1</sup>&frasl;<sub>2</sub> Rate

<ul>
<li>Double add</li>
</ul></li>
<li><sup>1</sup>&frasl;<sub>4</sub> Rate

<ul>
<li>rcp, rsqrt, sqrt</li>
<li>Double mul/fma</li>
<li>Integer 32-bit mul</li>
</ul></li>
<li>Super Expensive

<ul>
<li>Integer div</li>
<li>asin, acos, atan&hellip;</li>
</ul></li>
</ul>

<p>スカラ値の場合にはベクトル演算とは違うユニットで独立で演算されるため、シェーダーがどのような演算が主な演算になっているかによってコストなしまたはコストありに分かれる。</p>

<p>また以前までのAMDハードウェアではVLIWスロットの個数などで処理速度を測ることが出来たが、GCNからは命令の速度がそれぞれ違うし、命令の個数が表示されなくなったため（普通のx86のようになった）処理速度を測るには一つ一つ判別するしかなくなった。</p>

<p>p25）そして<code>MAD</code>の対してGCNではVLIWのように長い命令を持てなくなったため、MADが下手すると一つの64bit命令に収まらなくむしろ<code>ADD + MUL</code>より速度が落ちてしまう。</p>

<blockquote>
<p>画像での<code>v_mac_f32 v1, s0, v0</code>はv1 = s0 * v0 + v1を実装している。つまい本来のMADのように命令になる。</p>
</blockquote>

<p>ただアーキテクチャが変わったといって<code>MAD</code>はまだ使えるし、注意して書けば効率はよくなるそうだ。ただ注意するところがあって、</p>

<ul>
<li>inline constantを使う時</li>
<li>インプットがベクトルである時</li>
<li>適合した命令に被演算子が入れられる時</li>
</ul>

<p>といった条件下で<code>MAD</code>は効率を保障する。</p>
<div class="highlight"><pre class="chroma"><code class="language-gcn" data-lang="gcn">return x * 3.0f + y; // x and y is scalar =&gt; v_madmk_f32 v0, v2, 0x40400000, v0
return x * 0.5f + 1.5f // x is scalar =&gt; v_madak_f32 v0, 0.5(l), v0, 0x3fc00000</code></pre></div>
<p>下の<code>0.5</code>はliteral constantであるため、<code>MAD</code>になれた。上は<code>3.0f</code>だけ定数であるため、ギリギリで<code>MAD</code>することが出来た。</p>

<p>しかしベクトルを使ってる時には若干最適化が劣るけど、<code>v_mad_f32</code>と<code>v_mac_f32</code>を使ってある程度の速度向上となっている。</p>
<div class="highlight"><pre class="chroma"><code class="language-gcn" data-lang="gcn">return v4 * c.x + c.y;
// v_mov_b32 v1, s1
// 3 of v_mad_f32
// and v_mac_f32 end...</code></pre></div>
<h2 id="vectorization">Vectorization</h2>

<p>昔GPUのアーキテクチャ自体がSuper-ScalarまたはVLIWベースではなかった時には、ベクトル演算の力を借りて<code>return 1.0f - dot(v.xy, v.xy)</code>みたいにむりやり最適化を催そうとしたが、今のGPUはだいたいSuper-ScalarまたはモバイルさえもVLIWベースであるため、やらない方がむしろ最適化されやすい。</p>

<h2 id="rops">ROPs</h2>

<h3 id="ropとは">ROPとは？</h3>

<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Render_output_unit">https://en.wikipedia.org/wiki/Render_output_unit</a></p>
</blockquote>

<p>レンダリングパイプラインのRasterization、そしてフレームバッファにピクセルを書き込む時に使われるもので、ブレンディング、AAなどに使われる。</p>

<p>クロックごとにどれだけのピクセルを表示することが出来るかの指標として扱える。（後はメモリBandwidth）</p>

<hr />

<p>2020年今までゲーミンググラボの中で一番高いやつの「2080ti」はROPが88個だが、PS4は32個（PROはわからない）、そしてXBOX ONEは16個であるため、短いシェーダーの場合には性能が発揮しにくい。また性能のボトルネックを測るにはVRAMメモリへの帯域幅も念頭しなければならない。</p>

<p>原文では「GPUのクロック＊ROPs＊フレームバッファの各ピクセルのBytes」で理論上の処理速度を測定している。</p>

<p>とにかくなんとかかんとか大体のフレームバッファはRGBA8であるため（HDRなどは例外）、普通の状況ではROPsボトルネックになってしまう。出来ればメモリのボトルネックにする方が良いので、演算速度を上げるにはCompute Shaderをものすごく使うのが良いらしい。</p>

<h2 id="branching-registers">Branching ~ Registers</h2>

<p>GCNでの分岐の処理は基本的に一番遅いレーンに合わせることと、ThenとElseの分岐を全部試してみるという骨子からあんまり変わっていないが、速いので速度が落ちることがあんまりないそうだ。分岐の処理はスカラ演算ユニットで処理される。</p>

<p>しかし問題は分岐によってGRP（General Purpose Register）の使用が増えてしまうことである。分岐よりはこのGRPの使用増加により性能が落ちるらしい。</p>

<p>小さい分岐にはFull branchを防ぐため<code>?:</code>を使う。ただ、あるプラットフォームまたはHWでは<code>?:</code>さえFull branchされてしまい、GRPの増加による性能落ちが発生するらしく、その時には<code>CndMask()</code>を使うと言っている。（拡張か、それともなんらかのIntrinsicみたい）</p>

<p>p34）整数で<code>mul24()</code>が使えるなら、普通の<code>MUL</code>の代わりに<code>mul24(a,b)</code>を使う方が速い。24bitだけを取り出し、32bitをの結果値を返す。またはハードウェアのサポートによって<code>mul24_hi()</code>もあるという。</p>

<p>またHWのサポートによって<code>MAD</code>を24bits、24bits、そしてADDに使う32bitsとして1サイクルを終わらせるものもあるらしい。</p>

<p>そして整数への割り算はデバイスからサポートしてない場合が多く、やるとしても最適化がかからなかったら~40サイクルまで掛かるのでやらないべきであるという。最適化されるとしても、5~8クロックはかかるそうだ。</p>

<p>p38）GCNは倍精度浮動小数点（Double）をサポートするが、使うとこがない。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/f32tof16--sm5---asm-">https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/f32tof16--sm5---asm-</a></p>
</blockquote>

<p>D3D11以上でdoubleとfloatを変換する際には<code>f32tof16()</code>または<code>f16tof32()</code>を使う。</p>

<p>R5G5B5圧縮カラー（DXT1）から各チャンネルの色を取りたい時には以下のようにする。</p>
<div class="highlight"><pre class="chroma"><code class="language-hlsl" data-lang="hlsl">int r = s &amp; 0x1F;         // 1 cycle maybe
int g = (s &gt;&gt; 5) &amp; 0x3F;  // 1 cycle maybe
int b = (s &gt;&gt; 11) &amp; 0x1F; // 1 cycle maybe</code></pre></div>
<p>p41）<code>sign()</code>と<code>step()</code>の代わりに<code>?:</code>を使うこと。（in D3D11）原文では<code>sign()</code>ビルトイン関数は遅いのでいっそ<code>(x &gt;= 0) ? 1 : -1</code>のように使うべきだと言っている。また<code>step()</code>も<code>(x &gt;= a) ? 1 : 0</code>にすべきらしい。</p>

<p>GCNはベクトルに対して実行サイクルをへらすために<code>min3()</code>、<code>max3()</code>、<code>med3()</code>らしきものを実装している。</p>

<p>p44）シェーダーの各ステージで使っているレジスタの数は処理速度に影響を与える。しかしレジスタの使用を最適化することはブラックボックス化された中身を最適化することと同じで、もっとも難しい。ただ、経験上からはシェーダーの横負荷を減らして、ある時点で使っているレジスタの数を減らせば性能は上がるらしい。（HWによって違う可能性ある）</p>
<div class="highlight"><pre class="chroma"><code class="language-hlsl" data-lang="hlsl">for (each) { WorkA(); }
for (each) { WorkB(); }
// not for (each) { WorkA(); WorkB(); }</code></pre></div>
<p>そしてこの最適化はCPUの方でも通用されるのだが、変数データの寿命を最大限に短くすること。また、<code>#ifdef</code>を積極的に活用してランタイムの分岐よりはシェーダープログラムを作る際に静的に分岐して性能の低下を防ぐようにすること。最悪<a href="https://www.gamedev.net/forums/topic/659145-what-is-a-uber-shader/">Uber-shader</a>の中にマクロ分岐を仕込んでレンダリングさせるほうが良い。</p>

<h2 id="things-shader-author-should-stop-doing">Things shader author should stop doing</h2>

<p>やるなスペシャル</p>

<ul>
<li><code>pow(color, 2.2f)</code></li>
<li><code>normal = Normal.Sample(...) * 2.0f - 1.0f</code></li>
</ul>

<h1 id="参考">参考</h1>

<p><a href="https://gpuopen.com/wp-content/uploads/2017/03/GDC2017-Advanced-Shader-Programming-On-GCN.pdf">GDC2017-Advanced-Shader-Programming-On-GCN</a></p>

<p><a href="https://www.slideshare.net/DevCentralAMD/gs4106-the-amd-gcn-architecture-a-crash-course-by-layla-mah">GS-4106 The AMD GCN Architecture - A Crash Course, by Layla Mah</a></p>

<p><a href="https://developer.amd.com/wordpress/media/2012/12/AMD_Southern_Islands_Instruction_Set_Architecture.pdf">AMD Southern Island Instruction Set Architecture</a></p>
]]></content>
		</item>
		
		<item>
			<title>SFINAEの活用、ざっくりメモ</title>
			<link>https://liliilli.github.io/posts/sfinae_afaid/</link>
			<pubDate>Wed, 17 Jun 2020 19:15:18 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/sfinae_afaid/</guid>
			<description>SFINAEとは SFINAEとはSubstitution Failure is not an error（SFINAE)の略語として、テンプレートパラメータの一致しないテ</description>
			<content type="html"><![CDATA[

<h1 id="sfinaeとは">SFINAEとは</h1>

<p>SFINAEとはSubstitution Failure is not an error（SFINAE)の略語として、テンプレートパラメータの一致しないテンプレートに関して、一致してないもの自体がエラーにはならずに済むことを指す。</p>

<p>C++では関数を<code>const</code>修飾子、または引数のリストを異なるようにしてオーバーロード（Overload）することは出来るようになり、テンプレートがついた関数などにも例外ではない。テンプレートがついている関数を呼ぼうとする時、コンパイラはテンプレートのあるオーバーロードされた関数に今入れようとしている引数を調べてタイプリストとリターンタイプがちゃんと合っているかを確認する。</p>

<p>しかし、全く合ってない関数が判断されてしまうとしたら、普通の関数の場合コンパイラはエラーを吐き出さなければならない。しかし言語仕様では、テンプレートの対照であってないものはエラーの代わりにそもそも無かったことにすることにした。すなわち、切り替え（Substitution）が失敗（Failure）しても、エラーにならない（Is not an error)というのである。</p>

<p>「C++ Templates The complete guide second edition」からの簡単（？）な例で説明すると…</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">len</span> <span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span> <span class="c1">// ...1
</span><span class="c1"></span><span class="p">{</span>
  <span class="k">return</span> <span class="n">N</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="n">len</span> <span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="c1">// ...2
</span><span class="c1"></span><span class="p">{</span>
  <span class="k">return</span> <span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<ol>
<li>意図通りならCスタイルの配列（Decayされていないもの）を受け取って、要素の数を返す。</li>
<li>Cスタイルの配列ではない場合には、<code>.size()</code>メンバー関数がある任意タイプ<code>T</code>の引数を受け取り、それの<code>.size()</code>を呼び出す。（注意！）</li>
</ol>

<p>優しい世界ならこういったコードが通れる。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">len</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>         <span class="c1">// 10
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">len</span><span class="p">(</span><span class="s">&#34;temp&#34;</span><span class="p">);</span>    <span class="c1">// 5
</span><span class="c1"></span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">len</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>         <span class="c1">// .size() is called inside.
</span></code></pre></div>
<p>ただし、破綻しちゃうと</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">len</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// ERROR ...3
</span><span class="c1"></span>
<span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">len</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// ERROR ...4
</span></code></pre></div>
<p>になる。「３」の場合はCスタイル配列でもなく、そして「２」の<code>typename T::size_type</code>が満たされてないため、どっちでも適用することができず完全に失敗してビルドエラーが出ちゃう。「４」の場合には「２」の引数とリターンタイプは通ったが、中身で<code>.size()</code>が見つからなかったため、完全失敗しエラーが出てしまう。</p>

<p>これをある程度解決（泥臭い方法）するためには、テンプレート対照の最後候補として<code>...</code>をオーバーロードする方法がある。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">len</span><span class="p">(...)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>
<p>すれば<code>int* p</code>の方は通るが、<code>std::allocator&lt;int&gt; x</code>の方はまだビルドが通らない。なぜなら<a href="https://en.cppreference.com/w/cpp/language/overload_resolution">Overload Resolution</a>によって最後の可変長引数を取る関数は最後の候補となり、<code>std::allocator&lt;int&gt; x</code>は「２」のテンプレートに一番当てはまって、その関数を無理やり呼び出そうとしているからだ。</p>

<p>正常に（なんとか）ビルドを通すにはどうすればいいかとすると、C++11から追加された<code>&lt;type_trait&gt;</code>にある<code>std::enable_if&lt;expr, return_type&gt;::type</code>（または<code>std::enable_if_t&lt;&gt;</code>）を使ってOverloading Resolutionに「２」が当たってしまうことが防ぐことが出来る。</p>

<h2 id="解決法">解決法</h2>

<p>コードを書く前に、<code>std::thread</code>のコンストラクタを検討してみる。<code>std::thread</code>のコンストラクタも特定タイプが入る時にOverload Resolutionをされることを避けるため、SFINAEを使っている。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
  <span class="k">class</span> <span class="nc">thread</span>
  <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="k">template</span> <span class="o">&lt;</span>
      <span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">ARGS</span><span class="p">,</span> 
      <span class="k">typename</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;!</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">,</span> <span class="kr">thread</span><span class="o">&gt;&gt;&gt;</span>
    <span class="k">explicit</span> <span class="kr">thread</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">ARGS</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div>
<p>最後の型引数で<code>std::enable_if</code>を使って<code>F</code>のDecayされた型が<code>std::thread</code>である時このコンストラクタへの引数置換と失敗とし、Overload Resolutionをしないようにしていることがわかる。</p>

<p>コンストラクタの場合にはリターンタイプが無いため、普通は上のように最後の型引数でSFINAE構文を書く。普通の関数の場合にはリターンタイプに<code>decltype()</code>を一緒に使って条件付きのSFINAEをさせることが出来る。</p>

<p><code>std::enable_if</code>を使って上のビルドが通らなかったコードを修正すれば、</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">has_function_size</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;&gt;</span>
<span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="n">len</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="c1">// ...2
</span><span class="c1"></span><span class="p">{</span>
  <span class="k">return</span> <span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Or
</span><span class="c1">// template &lt;typename T, std::enable_if_t&lt;has_function_size&lt;T&gt;::value, int&gt; = 0&gt;
</span></code></pre></div>
<p>になる。ただ<code>has_function_size&lt;T&gt;</code>は<code>&lt;type_trait&gt;</code>には無いもので、SFINAE（＋黒魔術）を使って実装しなければならない。</p>

<blockquote>
<p>ちなみにSFINAE自体はC++11から使えるものではない。C++03の場合にはboostの使用または直接<code>&lt;type_trait&gt;</code>の要素を実装することである程度使いこなせる。</p>
</blockquote>

<p><code>std::enable_if&lt;&gt;</code>は下のコードのように実装できる。(from <a href="https://en.cppreference.com/w/cpp/types/enable_if">en.cppreference</a>)</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">EXPR</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">enable_if</span> <span class="p">{};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">enable_if</span><span class="o">&lt;</span><span class="nb">true</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div>
<h2 id="注意すべき点">注意すべき点</h2>

<blockquote>
<p><a href="https://en.cppreference.com/w/cpp/types/enable_if">https://en.cppreference.com/w/cpp/types/enable_if</a></p>
</blockquote>

<p>関数テンプレート（コンストラクタ含め）のデフォルト引数はオーバーロードされたテンプレートたちの引数リストに含まれないため、同じ定義だと解釈されてビルドエラーが出る場合がある。その時には<code>typename = std::enable_if...</code>の代わりに、<code>std::enable_if_t&lt;...&gt; = type()</code>として使ってビルドが通るらしい。</p>

<p>（未だにちょっと分かりづらい部分ではある…）</p>

<p>＋ちなみにSFINAE活用は関数、メンバー関数だけではなく普通の構造体にも適用できる。（個人的には構造体を使ってSFINAEを使うことが少し多かった気がする…）</p>

<h1 id="活用">活用</h1>

<blockquote>
<p>ここからはC++17以上の内容も含まれる可能性があります。</p>
</blockquote>

<h2 id="typelist">Typelist</h2>

<p>タイプのリストをコンパイルタイムで生成し、様々なSFINAE黒魔術＋メタプログラミングをしやすくする。みんな大好きの「Modern C++ Design : Generic Programing and Design Patterns Applied」本（略してMCD）にも最初に出てきたものでもある。</p>

<p>ただ変わったところはMCDはC++11以前に書いた本で、可変長型引数（Parameter PackまたはVariadic Template）文法がサポートしてないため、数の制限があった。しかしC++11以降ではコンパイラが許容するかぎりの個数でリストが作れる。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">ITEM</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TYPELIST_TYPE</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">typelist_t</span> <span class="k">final</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">item_type</span> <span class="o">=</span> <span class="n">ITEM</span><span class="p">;</span>            <span class="c1">/// Stored actual type.
</span><span class="c1"></span>    <span class="k">using</span> <span class="n">list_type</span> <span class="o">=</span> <span class="n">TYPELIST_TYPE</span><span class="p">;</span>   <span class="c1">/// Another typelist type.
</span><span class="c1"></span><span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">ITEM</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">typelist_tail_t</span> <span class="k">final</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">item_type</span> <span class="o">=</span> <span class="n">ITEM</span><span class="p">;</span>            <span class="c1">/// Stored actual type.
</span><span class="c1"></span><span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">ARGS</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">make_list</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">details</span><span class="o">::</span><span class="n">factory_entry</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">ARGS</span><span class="p">),</span> <span class="n">ARGS</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
</code></pre></div>
<p><code>typelist_t</code>と<code>typelist_tail_t</code>はタイプを保存するためのタイプである。厳密にはSpecialization（特殊化）を行って、タイプが入ったコンパイルタイムだけ使えるタイプを一つ作るためのテンプレートである。（ランタイムにどう使えるかは検証してない）</p>

<p><code>make_list</code>でタイプを入れると、渡したタイプの長さによって<code>typelist&lt;....&gt;</code>が生成されるか、失敗タイプ（<code>sizeof...(ARGS) == 0</code>の時）が返される。例えば、</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">static_assert</span><span class="p">(</span>
  <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span>
    <span class="n">make_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="c1">// &lt;= input 
</span><span class="c1"></span>    <span class="n">typelist_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">typelist_t</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">const</span><span class="o">*</span><span class="p">,</span> <span class="n">typelist_tail_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="c1">// &lt;= same
</span><span class="c1"></span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">make_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">typelist_tail_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">make_list</span><span class="o">&lt;&gt;</span><span class="p">,</span> <span class="cm">/* FAILURE TYPE */</span><span class="o">&gt;</span><span class="p">);</span>
</code></pre></div>
<p>になる。</p>

<p><code>factory_entry</code>の中では次のコードでSFINAEを使いこなしたリストを生成する。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">ARG</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">ARGS</span><span class="o">&gt;</span> 
<span class="k">struct</span> <span class="nc">factory</span> <span class="k">final</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">typelist_t</span><span class="o">&lt;</span><span class="n">ARG</span><span class="p">,</span> <span class="k">typename</span> <span class="n">factory</span><span class="o">&lt;</span><span class="n">ARGS</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">ARG</span><span class="o">&gt;</span> 
<span class="k">struct</span> <span class="nc">factory</span><span class="o">&lt;</span><span class="n">ARG</span><span class="o">&gt;</span> <span class="k">final</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">typelist_tail_t</span><span class="o">&lt;</span><span class="n">ARG</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">usize</span> <span class="n">sz</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">ARGS</span><span class="o">&gt;</span> 
<span class="k">struct</span> <span class="nc">factory_entry</span> <span class="k">final</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">conditonal</span><span class="o">&lt;</span><span class="p">(</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="k">typename</span> <span class="n">factory</span><span class="o">&lt;</span><span class="n">ARGS</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">,</span> <span class="n">null_t</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span> 
<span class="k">struct</span> <span class="nc">factory_entry</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span> <span class="k">final</span> <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">null_t</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div>
<h2 id="enum-class-bitmask">enum class bitmask</h2>

<blockquote>
<p><a href="http://blog.bitwigglers.org/using-enum-classes-as-type-safe-bitmasks/">http://blog.bitwigglers.org/using-enum-classes-as-type-safe-bitmasks/</a></p>

<p><a href="https://stackoverflow.com/questions/26936640/how-to-implement-is-enum-class-type-trait">https://stackoverflow.com/questions/26936640/how-to-implement-is-enum-class-type-trait</a></p>
</blockquote>

<p>C++03までの<code>enum</code>はunderlying typeと同一視されるところがあって<code>|</code>または<code>&amp;</code>のようなマスキング演算子が普通に使えた。しかしC++11からの<code>enum class</code>は普通の方法ではそれが出来ず、やるとしたらオペレーターの関数をオーバーロードしていちいちつくらなければならなかったりする。</p>

<p>しかしこれもテンプレートの特殊化と<code>std::enable_if_t&lt;&gt;</code>を使ったSFINAEで、マスキング出来るように指定した<code>enum class</code>のタイプに対してビットマスクすることが出来る。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">is_enum_class</span> <span class="k">final</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">__test</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="p">{};</span> <span class="c1">// enum classは足し算が出来ないのでココへ落ちる
</span><span class="c1"></span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">__test</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="k">decltype</span><span class="p">((</span><span class="kt">void</span><span class="p">)</span> <span class="o">+</span> <span class="n">T</span><span class="p">{}))</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{};</span>
  
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span>
        <span class="kt">bool</span><span class="p">,</span> 
        <span class="o">!</span><span class="n">__test</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_enum_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">E</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">enable_bitmask_ops_t</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">sk_is_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">E</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">gk_enable_bitmask_ops</span> <span class="o">=</span> <span class="n">enable_bitmask_ops_t</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;::</span><span class="n">sk_is_enabled</span><span class="p">;</span>

<span class="cp">#define DY_ENABLE_ENUM_BITMASK_OP(E) \
</span><span class="cp">  template &lt;&gt; \
</span><span class="cp">  struct ::enable_bitmask_ops_t&lt;E, std::enable_if_t&lt;is_enum_class&lt;E&gt;::value&gt;&gt; \
</span><span class="cp">  { static constexpr bool sk_is_enabled = true; };
</span></code></pre></div>
<p><code>enable_bitmask_ops_t</code>は<code>enum class</code>がビットマスクをするためのフラグを持った構造体である。<code>DY_ENABLE_ENUM_BITMASK_OP</code>で該当タイプを入れて特殊化してビットマスクが使えるようにする。</p>

<p>一番上の<code>is_enum_class</code>は特殊化された<code>T</code>が<code>enum class</code>なのかを判断する構造体で、中の<code>__test</code>構造体は<code>T</code>が入るときに同時に特殊化されないように別途の<code>U</code>などの識別子を使っている。</p>

<p>そしてビットマスクのためのオペレーター関数をオーバーロードして使えば終わり。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">E</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">gk_enable_bitmask_ops</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span>
<span class="k">operator</span><span class="o">|</span><span class="p">(</span><span class="n">E</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">E</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">underlying</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">underlying_type_t</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">underlying</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">|</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">underlying</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rhs</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">E</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">gk_enable_bitmask_ops</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span>
<span class="k">operator</span><span class="o">&amp;</span><span class="p">(</span><span class="n">E</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">E</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">underlying</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">underlying_type_t</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">underlying</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">&amp;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">underlying</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rhs</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// ...
</span></code></pre></div>
<h2 id="extended-type-traits">Extended type_traits</h2>

<p>SFINAEを<code>decltype()</code>と一緒に悪用してtype_traitsを拡張させることも出来る。全部乗せるとスクロールバーが爆発するので、一つだけ取り出して「クラスが<code>swap(T&amp;, T&amp;)</code>または<code>T::swap(T&amp;)</code>を持っているかを確認するtraits」のコードだけを見てみる。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">is_swappable</span> <span class="k">final</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">_F</span> <span class="o">=</span> <span class="o">::</span><span class="n">dy</span><span class="o">::</span><span class="n">_chk_compile_details</span><span class="o">::</span><span class="n">_F</span><span class="p">;</span> <span class="c1">// FAILURE TYPE
</span><span class="c1"></span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">,</span> <span class="k">typename</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">out_fn</span><span class="p">(...)</span> <span class="o">-&gt;</span> <span class="n">_F</span><span class="p">;</span> <span class="c1">// 4 (FAILURE CASE)
</span><span class="c1"></span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">V</span><span class="p">,</span> <span class="k">typename</span> <span class="n">W</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">out_fn</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="c1">// 3 (swap(T&amp;, T&amp;) is exist)
</span><span class="c1"></span>        <span class="o">-&gt;</span>
        <span class="k">decltype</span><span class="p">(</span>
            <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="p">)(</span><span class="mi">0</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">W</span><span class="o">*</span><span class="p">)(</span><span class="mi">0</span><span class="p">)),</span>
            <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="k">noexcept</span><span class="p">(</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="p">)(</span><span class="mi">0</span><span class="p">),</span> <span class="o">*</span><span class="p">(</span><span class="n">W</span><span class="o">*</span><span class="p">)(</span><span class="mi">0</span><span class="p">))),</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span>
        <span class="p">);</span>
    
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">V</span><span class="p">,</span> <span class="k">typename</span> <span class="n">W</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">in_fn</span><span class="p">(...)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">out_fn</span><span class="o">&lt;</span><span class="n">V</span><span class="p">,</span> <span class="n">W</span><span class="o">&gt;</span><span class="p">(</span><span class="k">nullptr</span><span class="p">));</span> <span class="c1">// 2
</span><span class="c1"></span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">V</span><span class="p">,</span> <span class="k">typename</span> <span class="n">W</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="k">auto</span> <span class="n">in_fn</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="p">)(</span><span class="mi">0</span><span class="p">)).</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">W</span><span class="o">*</span><span class="p">)(</span><span class="mi">0</span><span class="p">)));</span> <span class="c1">// 1 (T.swap(T&amp;) is exist)
</span><span class="c1"></span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">in_fn</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)),</span> <span class="n">_F</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>コメントの１から４までそりあがる感じで読めばそれこそコンパイラのOverload Resolutionの順番なんだけど、ぶっちゃけ何かなんだかわからないんで下に別途で解説をしたい。（もうざっくりではないような…）</p>

<p>まず１から４の関数は中身を持たない。持たなくても普通にコンパイルは通る。なぜならあくまでもコンパイルタイムでだけ呼ばれて、ランタイムでは要らない関数であるからでだ。１と２の関数（<code>in_fn</code>）と３，４の関数（<code>out_fn</code>）はそれぞれテンプレートSFINAE特殊化の単位組となる。</p>

<p>最初は１，２番目の関数から検証を行う。<code>in_fn</code>関数の役目は<code>T.swap(U&amp;)</code>があるかを確認することであって、リターンタイプで<code>decltype()</code>を使ってSFINAEを駆使する。もし<code>T.swap(U&amp;)</code>メンバー関数がなければ、１の関数の特殊化は失敗して２が選択される。（<code>...</code>引数はOverload Resolutionで最後に選ばれるようになっている）</p>

<p>もしswapメンバー関数の検索に失敗したら、次は<code>out_fn</code>関数テンプレート組で<code>swap(T&amp;, U&amp;)</code>を探す。３番目のテンプレートでは<code>decltype()</code>と中にコンマ演算子を使って、<code>decltype</code>の中の表現式リストを上から下へ次々へと検証する。もし途中で失敗したら、そのテンプレートの特殊化は失敗して４番目が選択され、最終的にswap関数が無かったことになる。</p>

<p>連続した表現式を持つ<code>decltype()</code>は最後の表現式で生み出されるタイプが最終タイプとなる。</p>

<h1 id="終わりに">終わりに</h1>

<p>以上、テンプレートを使って実装してみた機能などを振り返ってみた。正直まだ色々とあって、全部書きたいけど体力が持たないし、みんな読みながら眠ってしそうで…（自分も）それにC++20になるとconcepts（＋requires）があるんで、環境が完全にC++20以上に移ったらSFINAEみたいなやつはあんまり書かなくてもいいと思う。（いやそう願いたい）</p>
]]></content>
		</item>
		
		<item>
			<title>Low Level Thinking in High Shader Languages</title>
			<link>https://liliilli.github.io/posts/shader_opti_memo/</link>
			<pubDate>Wed, 17 Jun 2020 12:00:15 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/shader_opti_memo/</guid>
			<description>これは参照項目のGDCのリンクを読んで適当にメモしたものです。詳しくは参照のリンクをご覧ください。 Goal of this presentation ローレベル思考はいまだに有効である</description>
			<content type="html"><![CDATA[

<p>これは参照項目のGDCのリンクを読んで適当にメモしたものです。詳しくは参照のリンクをご覧ください。</p>

<h2 id="goal-of-this-presentation">Goal of this presentation</h2>

<blockquote>
<p>ローレベル思考はいまだに有効であることを見せる。</p>
</blockquote>

<h2 id="background">Background</h2>

<p>今から（2020年）ほぼ20年前にはシェーダーに制限が多く、今のようにノードベースまたはHLSLなどの高級言語ではなく独自のアセンブリでコードを書かなければならなかった。</p>

<p>そしてアセンブリが実際のHWにほぼ一対一対応しているため、最適化などは手動でやらざるを得なかったらしい。</p>
<div class="highlight"><pre class="chroma"><code class="language-8086" data-lang="8086">def 	c0, 0.3f, 2.5f, 0, 0
texld 	r0, t0
sub 	r0, r0, c0.x
mul		r0, r0, c0.y // こんな感じで…</code></pre></div>
<p>ただし、こういったコードの書き方はHLSLまたはGLSLなどのシェーダー専用の高級言語の登場により、またある程度コンパイラーが自動で最適化をしてくれるようになったため、いらなくなった。</p>

<p>最後にはノードベースも登場し、プログラマがコードを書くのではなく、アーティストがノードを組んでシェーダーを作るようになった。（めでたしめでたし）</p>

<p>しかし、これはノードまたはHLSL言語が実際のHWに一対一対応していなくなった事になり、シェーダーの最適化などを正にコンパイラー様にお祈りするしかならなくなったのである。</p>

<h2 id="why-bother">Why bother?</h2>

<p>例をあげて説明してみる。</p>
<div class="highlight"><pre class="chroma"><code class="language-hlsl" data-lang="hlsl">       // float3 float     float   float3       float    float
return Diffuse * n_dot_l * atten * LightColor * shadow * ao;</code></pre></div>
<p>と</p>
<div class="highlight"><pre class="chroma"><code class="language-hlsl" data-lang="hlsl">return (n_dot_l * atten) * (shadow * ao) * (Diffuse * LightColor);</code></pre></div>
<p>で生成されるバイトコードは結構違う。（ただし、これはコンパイラーのバージョンなどによって違うかもしれないが）</p>

<p>順番変えと、同じタイプごとの掛け算をするように括弧を書いてあげただけだが、下のコードが明らかに速くなっていることが見られる。（画像は原文で）</p>

<p>このようにローレベル思考でコードを書くことで、ALU（演算装置）の負荷が軽減される。そして新しいシェーダーレンダリング機能も考えさせられることになる。もしALUの負荷が50%から25%に軽減されたことに過ぎないとしても、クロック回転数の向上などの可能性がみられるので、最適化はやっておく方がいいのではかと。</p>

<h2 id="but-the-compiler-will-optimized-it">But, the compiler will optimized it!</h2>

<p>今時にはシェーダーのコンパイラーも結構鋭くなったけど、書いたコードの成された構造自体を破ってまで最適化を強行することはあんまりない。（上にように<code>Float3 * Float * Float3 * Float * Float3 * Float</code>を<code>Float * 3... * Float3 * 3...</code>することはなかなかないだろうと）</p>

<p>もし破壊的な最適化をやるとしても、どの結果が起こってしまうかはわからないのである。</p>

<p>たとえば…</p>
<div class="highlight"><pre class="chroma"><code class="language-hlsl" data-lang="hlsl">float main(float x: TEXCOORD) : SV_TARGET
{
    return (x + 1.f) * 0.5f;
}</code></pre></div>
<p>上のコードはちゃんと最適化されてないらしい。（最適化されるとしたら、<code>MAD</code>命令になるが、単純に<code>ADD</code>と<code>MUL</code>に置換される）原文によると、PS3では特定状況の以外には上のようなコードが最適化されてないらしく、XBOX360ではなんとか最適化を行うが意図したものになってない可能性があるらしい。</p>

<h2 id="why-not">Why not?</h2>

<p>もし最適化を行うとしても、意図した結果とは違う画面レンダリングになる可能性もある。最悪<code>INF</code>とか<code>NaN</code>になってしまう可能性もあり、それで順番を変えたりする構造破壊の最適化はあんまりしないらしい。</p>

<p>例えば、<code>sqrt(0.1f * (0.2f - x))</code>と<code>sqrt(0.02f - 0.1f * x)</code>のコードは違って、もし<code>x = 0.2f</code>だとしたら左は破綻せず0を返すが、右は破綻して<code>NaN</code>を返してしまう可能性がある。（IEEE-754のこと）</p>

<p>コンパイラはランタイムで参照してないコードを消すこと、使用しないリソース、レジスター番号の割当などに向いて、依存性またはコード自体に成立されているルールなどを破るまで最適化することはしてない。</p>

<h2 id="rules">Rules</h2>

<p>原文ではD3D10+のシェーダーモデルと、そのシェーダーモデルが使っているIEEE-754-2008を基準としてルールを定めている。しかし、浮動小数点の<code>ULP</code>は0.5範囲以内ではなく、1.0ULP以内として切り上げるようになっている。また、浮動小数点の0周りの少数を表現する<code>denormalized number</code>も演算をするたびにフラッシュされる。（<code>MOV</code>はしないそうだ）</p>

<p>また、HLSLコンパイラは<code>NaN</code>と<code>INF</code>になる恐れを考慮せず最適化を行う。なので、<code>isnan()</code>とか<code>isfinite()</code>をコード上で使うのはあんまり良くないそうだ。</p>

<h2 id="universal-大体のhw-facts-about-hw">Universal（大体のHW）facts about HW</h2>

<ul>
<li>Multiply-Addは１個の命令で最適化できる。逆は<code>ADD =&gt; MUL</code>をするため、２個要る。</li>
<li><code>abs</code>、<code>negate</code>、そして<code>saturate</code>は自由に使っていい。（ただし<code>MOV</code>命令が入ってしまうとＸ）</li>
<li>当然だけど、ベクトルよりはスカラーがリソース負荷が軽い。</li>
</ul>

<h2 id="mad"><code>MAD</code></h2>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/hh447183(v=vs.85">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/hh447183(v=vs.85</a>)</p>
</blockquote>

<p>ある領域の数値をとある領域の数値へマッピングすることは理想的には<code>MAD</code>命令語一個で済ませるべき。もしかして<code>MAD</code>をやった後、クランプするとしたら<code>MAD_SAT</code>になるべきである。最悪クランプする領域が<code>[0, 1]</code>じゃないとしたら<code>MAD_SAT + MAD</code>にすべきである。</p>

<p>例えば</p>

<ol>
<li><code>(x - start) * slope</code>は<code>x * slope + (-start * slope)</code>にすべき。</li>
<li><code>(x - start) / (end - start)</code>は<code>x * (1.f / (end - start)) + (-start / (end - start))</code></li>

<li><p>clampは出来る限りに<code>saturate</code>に…（原文を読むこと）</p></li>

<li><p><code>x += a * b + c * d</code>は本来<code>MUL-MAD-ADD</code>になるが、最適化すると<code>x += a * b; x += c * d;</code>で<code>MAD-MAD</code>になれる。（ちょっと以外？）なぜなら、前の構文って<code>+=</code>がされる前に右辺の数式が先に演算されてしまうからだ。</p></li>
</ol>

<h2 id="division-with-rcp">Division with <code>RCP</code></h2>

<p><code>a / b</code>のような割り算コードは<code>rcp()</code>関数またはアセンブリ命令を使って実装するほうが速いコードになる可能性が高い。中身では<code>DIV</code>割り算命令を使うことがあるが、明示的に使うと最適化されるかもしれない。</p>

<ol>
<li><code>a / (x + b)</code>→<code>rcp((x + b) / a)</code>→<code>rcp(x * (1 / a) + (b / a))</code></li>
<li><code>(x + a) / x</code>→<code>1.0f + a * rcp(x)</code></li>
</ol>

<h2 id="madness">MADness</h2>

<p>原文を読むこと。明示的に最適化されてないコードをMADを使って最適化している。アセンブリで６行のコードが１行になることがわかる。</p>

<h2 id="modifiers">Modifiers</h2>

<p><code>MOV</code>を使うコードを書かない異常、コストはほぼ０である。<code>abs/neg</code>は既に実際している変数からのインプットだけを持ち、<code>saturate</code>は演算によって生成されたテンポラリの数値をインプットとして持たなければ最適化は失敗する。</p>
<div class="highlight"><pre class="chroma"><code class="language-hlsl" data-lang="hlsl">float main(float2 a : TEXCOORD) : SV_TARGET
{
	return abs(a.x) * abs(a.y);
}</code></pre></div>
<p>と</p>
<div class="highlight"><pre class="chroma"><code class="language-hlsl" data-lang="hlsl">float main(float2 a : TEXCOORD) : SV_TARGET
{
	return abs(a.x * a.y);
}</code></pre></div>
<p>は違うし、上のコードはMOVを使わないため、一つの命令で最適化出来る。そして負の符号（NEG）を使うときにも同じく扱わなければ最適化されない。</p>

<p><code>saturate()</code>の場合には、明示的に最適化が出来るコードだったら演算した数値をそのまま関数に入れるべきである。また注意する点は<code>min()</code>と<code>max()</code>はコストが掛かるため、<code>min(x, 0)</code>または<code>max(x, 1)</code>でOKなときにも<code>saturate()</code>を使うべきであるところらしい。</p>

<h2 id="hlsl-compiler-workaround">HLSL compiler workaround</h2>
<div class="highlight"><pre class="chroma"><code class="language-hlsl" data-lang="hlsl">saturate(dot(a, a))</code></pre></div>
<p>HLSLコンパイラは上のコードを<code>min(dot(a, a), 1.0f)</code>に変えてしまうところがある。これを防ぐためのいくつかの対策があるが、原文で説明するのは<code>precise</code>キーワードを使うものだ。</p>
<div class="highlight"><pre class="chroma"><code class="language-hlsl" data-lang="hlsl">float main(float3 a : TEXCOORD0) : SV_TARGET
{
	return (precise float) saturate(dot(a, a));
}</code></pre></div>
<p><code>precise</code>キーワードはIEEE754の仕様を強制するようにして、<code>saturate()</code>は必ず0を返すようになる。ただし、<code>precise</code>を使って性能が向上されるのはここだけであって、普通に使うと性能が劣るそうだ。</p>

<h2 id="built-in-functions">Built-in Functions</h2>

<ul>
<li><p><code>rcp()</code>、<code>rsqrt()</code>、<code>sqrt()</code>はDX10以上のハードウェアからはHW命令として組み込まれている。ただし、現状（2013年当時）のハードウェアでは<code>sqrt()</code>命令がないため、場合によっては<code>rcp(rsqrt())</code>と<code>x * rsqrt(x)</code>として使わなければならないらしい。</p></li>

<li><p>各関数と同じ演算をするハードコードは場合によって最適化されてない可能性がありうる。</p></li>

<li><p><code>exp2()</code>と<code>log2()</code>はだいたいのハードウェアに組み込まれているが、普通の<code>exp()</code>とか<code>log()</code>はそうじゃない場合が多かった。なので入れる数値が小さいと、普通の関数の代わりに<code>exp2(x * 1.442695f)</code>と<code>log2(x * 0.693147f)</code>を使う方が速い？らしい。</p></li>

<li><p><code>pow(x, y)</code>関数は<code>exp2(log2(x) * y)</code>として実装されている。</p></li>

<li><p><code>sign()</code>はHLSLとGLSLでの扱いが違うようだ。HLSLでは<code>sign()</code>を使わずにternary operator(?:)を使っても良いそうだが、GLSLではternary operator自体が分岐処理されてしまうため、<code>sign()</code>と同等な関数を適切に使いながらコードを書く必要があるらしい。</p></li>
</ul>

<blockquote>
<p><a href="https://stackoverflow.com/a/41871876">https://stackoverflow.com/a/41871876</a></p>
</blockquote>

<ul>
<li><code>sin()</code>、<code>cos()</code>、<code>sincos()</code>、<code>tan()</code>はある程度コストはあるが、よく使える。しかし、<code>asin()</code>などの逆三角関数を使うのは良くないらしい。さらにhyperbolic関数か<code>log10()</code>を使うのは厳禁。</li>
</ul>

<h3 id="mul-v-m-に最適化"><code>mul(v, m)</code>に最適化</h3>

<p>普通の<code>mul(v, m)</code>ならば、インストラクションは<code>MUL-MAD-MAD-MAD</code>になる。ただし、掛け算しているインプット<code>m</code>行列がhomogeneous transformであれば、<code>m[3]</code>の掛け算をなくして<code>MAD-MAD-MAD</code>の形に変換することが出来る。</p>
<div class="highlight"><pre class="chroma"><code class="language-hlsl" data-lang="hlsl">mul(v, m) when m[3] = float4(0, 0, 0, 1),
mul(v, m) = v.x * m[0] + (v.y * m[1] + (v.z * m[2] + m[3]))</code></pre></div>
<p>最適化した画像ではインストラクションのスロット（0,1,2,3）はハードウェアの制限のため減らなかったが、命令処理のためのレーンは相当空くことになり他の作業が同時に処理できることになる。</p>

<h2 id="matrix-math">Matrix Math</h2>

<p>マトリックス演算を使って、ベクトルのトランスフォームなどを集約して演算することが出来る。</p>

<h2 id="scalar-math">Scalar Math</h2>

<p>昔のハードウェアはほとんどベクトルベースだったため、ベクトルじゃない数値に関しての演算は内部でスカラーを処理するためのコストがあったらしい。（PS3・XBOX 360・D3D9）</p>

<p>しかし最近のGPUに移行しつつ、Scalar（スカラ）の数値を処理するためのプロセッサーが搭載され、またVLIW（Very long instruction word）のような構造が採択されて単一数値の演算は普通のベクトル演算より速くなるようになった。</p>

<p>ちなみにNVidiaはDX10+から、AMDGCNはDX11のHD7000代からスカラベースである。</p>

<blockquote>
<p>VLIWとはVery Long Instruction Wordの略語で、opcodeが複数あり同時実行可能ばインストラクションを入れて一つの命令にまとめて静的に実行させる仕組みである。（スーパスカラは動的）</p>
</blockquote>

<h2 id="scalar-vectorが混ざった演算">Scalar/Vectorが混ざった演算</h2>

<ul>
<li>ベクトルパートとスカラパートを出来る限り分離して演算させること。</li>
<li><code>dot()</code>、<code>normalize()</code>、<code>reflect()</code>、<code>length()</code>、<code>distance()</code>などのベクトルからスカラ値に変換するコードを使う際にはコンパイラが前の演算で算出した値を再使用するように引数の順番などに気をつけて書くこと。</li>
</ul>

<h2 id="hidden-scalar-math">Hidden Scalar Math</h2>

<p>スカラ演算を使わないように見える関数が実は関数の中でスカラ演算を使うことがある。</p>

<ul>
<li><code>normalize() = vec * rsqrt(dot(vec, vec))</code>であるため、スカラ演算が<code>dot()</code>からなってしまう。ベクトルとスカラ演算が混ざってしまうと性能低下の恐れがあるので、PS3みたいに<code>normalize()</code>がビルトインしていなければ、手作りもOKかも…</li>
<li><code>reflect() = i - 2.0f * dot(i, n) * n</code>、<code>lerp()</code>もスカラ演算を行っている。</li>
</ul>

<p>実装されているスカラ演算をどうやって使いこなすかとすると…</p>
<div class="highlight"><pre class="chroma"><code class="language-hlsl" data-lang="hlsl">float3 main(float3 vec : TEXCOORD0) : SV_TARGET
{
	//return 50.f * normalize(vec);
	return vec * (50.f * rsqrt(dot(vec, vec)));
}</code></pre></div>
<p>のように書けば、ある程度負荷が軽減できるらしい。（本文の画像ではインストラクションのスロットが変わってないが、2番スロットの<code>x</code>と<code>y</code>が使わなくなっている）</p>

<h2 id="hidden-common-sub-expressions">Hidden common sub-expressions</h2>

<p>別の関数の中身で同じ表現式を使うとしても、表現式に関与される別の表現式が違うとしたら、最適化されない可能性が高い。例えば、<code>normalize(vec)</code>と<code>length(vec)</code>は<code>dot(vec, vec)</code>を使っても、<code>rsqrt()</code>を使うか、それとも<code>sqrt()</code>を使うかが分かれてしまい、内積の関数での数値は再使用されない。</p>

<p>本文では<code>rsqrt(dot())</code>を使って<code>normalize()</code>を最適化している。画像では2番めの命令で使ってるベクトルの要素が増えてるが、4番目一つの命令が消えたことがわかる。（ただし、ここまでして最適化したいのか…？測定してから最適化すべき。）</p>

<p>ここで最後にさらに最適化を書くと、<code>saturate()</code>を使って<code>rsqrt(dot())</code>のnormFactorを<code>[0, 1]</code>に決めてノーマライズを書ける方法があるそうだ。これで分岐もなくなって、性能は速くなる。</p>

<h2 id="evaluation-order">Evaluation Order</h2>

<p>HLSLでの表現式の演算子の評価は左から右へとなる。なのでベクトル演算とスカラ演算を分離し、ベクトルはベクトルだけで、そしてスカラはスカラ値だけで演算させるようにすれば大体のコードは最適化される。</p>

<p>上のMADだの色々と説明されてるが、一番簡単で性能の向上が出来る最適化は演算子の評価順を変えることである。</p>

<p>またVLIWと昔のベクトルベースのハードウェアでは演算の最初と最後に演算順の依存性が高いらしく、例えば<code>a * b * c *d</code>のようなものでも<code>((a * b) * c) * d</code>として解釈されて無駄に命令が多くなることが多いらしい。解決策としては<code>(a * b) * (c * d)</code>のように依存性を破ることである。</p>

<p>こうすることで、並列に演算を行うようになるそうだ。</p>

<h2 id="real-world-testing">Real-world Testing</h2>

<p>これと言ったことを活用して、実際のClustered Deferred Renderingを最適化してみた結果、15%遅くなるか、2倍ぐらい速くなったそうだ。ただし、最初からローレベルの最適化を念頭にしてコードを作成するのではなく、高級言語でハードウェアをよく理解した上で、最後に明示的なローレベル最適化を行うべきらしい。</p>

<h2 id="補足">補足</h2>

<blockquote>
<p><a href="https://docs.microsoft.com/ja-jp/windows/win32/direct3dhlsl/dx-graphics-hlsl-if?redirectedfrom=MSDN">https://docs.microsoft.com/ja-jp/windows/win32/direct3dhlsl/dx-graphics-hlsl-if?redirectedfrom=MSDN</a></p>
</blockquote>

<ul>
<li><p>HLSLではGLSLとは違って、<code>if</code>または<code>for</code>などの前に属性（Attribute）をつけることが出来る。<code>[branch]</code>、<code>[flatten]</code>、<code>[loop]</code>、<code>[unroll]</code>などが存在する。</p></li>

<li><p>シェーダーの中じゃなくても出来る演算などはあえてシェーダーの中でやらないこと。</p></li>

<li><p>などなど…</p></li>
</ul>

<h3 id="良いローレベルコードを書くためには">良いローレベルコードを書くためには？</h3>

<ul>
<li>GPUのHWインストラクションに慣れる。（D3Dのアセンブリなどを見るとか）</li>
<li>HLSLとHWコードのマッピングに慣れる。（GPUShaderAnalyzer、NVShaderPerf、DXC、FXC）</li>
<li>実際プロダクトに載せた時のシェーダーの負荷を計測する。</li>
</ul>

<h1 id="参照">参照</h1>

<p><a href="https://www.gdcvault.com/play/1018182/Low-Level-Thinking-in-High">https://www.gdcvault.com/play/1018182/Low-Level-Thinking-in-High</a></p>

<p><a href="https://ushiostarfish.hatenablog.com/entry/2019/08/12/210023">https://ushiostarfish.hatenablog.com/entry/2019/08/12/210023</a></p>

<p><a href="https://stackoverflow.com/questions/4911400/shader-optimization-is-a-ternary-operator-equivalent-to-branching">https://stackoverflow.com/questions/4911400/shader-optimization-is-a-ternary-operator-equivalent-to-branching</a></p>

<p><a href="https://www.anandtech.com/show/4455/amds-graphics-core-next-preview-amd-architects-for-compute/2">https://www.anandtech.com/show/4455/amds-graphics-core-next-preview-amd-architects-for-compute/2</a></p>

<p><a href="https://gist.github.com/silvesthu/505cf0cbf284bb4b971f6834b8fec93d#gpu-optimization-for-gamedev">https://gist.github.com/silvesthu/505cf0cbf284bb4b971f6834b8fec93d#gpu-optimization-for-gamedev</a></p>
]]></content>
		</item>
		
		<item>
			<title>DirectInput8 導入メモ</title>
			<link>https://liliilli.github.io/posts/dinput8/</link>
			<pubDate>Sat, 25 Apr 2020 13:28:07 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/dinput8/</guid>
			<description>https://en.wikipedia.org/wiki/DirectInput https://bell0bytes.eu/directinput/ https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416842(v=vs.85)?redirectedfrom=MSDN https://docs.microsoft.com/ko-kr/windows/win32/xinput/xinput-and-directinput?redirectedfrom=MSDN DirectInputとは DirectInputは、キーボード、マウス、そして各種のコントローラーを含んでほぼ同一な挙動制御をサポー</description>
			<content type="html"><![CDATA[

<blockquote>
<p><a href="https://en.wikipedia.org/wiki/DirectInput">https://en.wikipedia.org/wiki/DirectInput</a></p>

<p><a href="https://bell0bytes.eu/directinput/">https://bell0bytes.eu/directinput/</a></p>

<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416842(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416842(v=vs.85)?redirectedfrom=MSDN</a></p>

<p><a href="https://docs.microsoft.com/ko-kr/windows/win32/xinput/xinput-and-directinput?redirectedfrom=MSDN">https://docs.microsoft.com/ko-kr/windows/win32/xinput/xinput-and-directinput?redirectedfrom=MSDN</a></p>
</blockquote>

<h1 id="directinputとは">DirectInputとは</h1>

<p><strong>DirectInput</strong>は、キーボード、マウス、そして各種のコントローラーを含んでほぼ同一な挙動制御をサポートしてくれるAPIを指す。今は<strong>xinput</strong>という新しい（今になっては結構古いAPIだが）APIと一緒に両立しているらしい。</p>

<p>*DirectInput*はもともと<strong>DirectX</strong>のコンポーネントの一つとして提供され、これを使えば以前までコントローラーごとの挙動制御を一つずつ制御しなかったことが相当省かれる。</p>

<p>*DirectInput*は認知したデバイスを3つの種類（キーボード、マウス、そしてコントローラー）として分類する。また、*DirectInput*はデバイスが必ず認識てきる、自分ひとりしか持ってない番号をもたせて認識させるようにする。それを<strong>GUID</strong>という。</p>

<p>よって、認知したデバイスをインスタンス（例えば<code>IDirectInput8Device</code>とか）として返すためには必ず*GUID*を持つ必要があるらしい。ただし、基本接続しているキーボードとマウスデバイスは以下のGUIDを通して探せる。</p>

<ul>
<li><code>GUID_SysKeyboard</code>：基本接続しているキーボードのGUID（マクロっぽい）</li>
<li><code>GUID_SysMouse</code>：基本接続しているマウスのGUID</li>
</ul>

<p>しかし、それ以外のデバイスはAPIで入れられる<strong>コールバック関数</strong>を通して検証する必要がある。また、それを行うためにはDInput8の<strong>メインオブジェクト</strong>をまず取得する必要がある。</p>

<blockquote>
<p>Getting Started with DirectInput</p>

<p>DirectInputを理解する為には、次のような用語を知っておく必要があるらしい。</p>

<ul>
<li>DirectInput Object：メインDirectInputのインタフェース</li>
<li>Device：キーボード、マウス、またコントローラーとなれるすべての入力デバイス</li>
<li>DirectInputDevice Object：Deviceの情報を持つ変数またはそれに準ずるコード</li>
<li>Device Object：DIDOから取得できるキー、ボタン、トリガーなどの構成要素</li>
</ul>
</blockquote>

<p>元記事では以下のようにDirectInput初期化手順を記述している。</p>

<ol>
<li>DirectInput Objectを生成する</li>
<li>GUIDを持つ全てのデバイスを検知し（コールバック関数を用いたクエリー）</li>
<li>適合なデバイスからDirectInput Device Objectを持ってくる。</li>
<li>DIDOのco-operation level、フォーマット、プロパティを設定する</li>
<li>Device Objectを取得する。</li>
<li>デバイスに入力をPollするかReadを行う。</li>
<li>取得したDevice Objectを先に開放し、そしてDirectInput Objectを開放して終わり。</li>
</ol>

<h1 id="大体のやり方">大体のやり方</h1>

<h2 id="1-directinput-objectを生成">1. DirectInput Objectを生成</h2>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416756(v%3dvs.85)">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416756%28v%3dvs.85%29</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">HRESULT</span> <span class="n">DirectInput8Create</span><span class="p">(</span>
         <span class="n">HINSTANCE</span> <span class="n">hinst</span><span class="p">,</span>
         <span class="n">DWORD</span> <span class="n">dwVersion</span><span class="p">,</span>
         <span class="n">REFIID</span> <span class="n">riidltf</span><span class="p">,</span>
         <span class="n">LPVOID</span> <span class="o">*</span> <span class="n">ppvOut</span><span class="p">,</span>
         <span class="n">LPUNKNOWN</span> <span class="n">punkOuter</span>
<span class="p">)</span></code></pre></div>
<p>上の関数の<code>ppvOut</code>に変数のポインターを入れて、<code>IDirectInput8</code>DirectInput Objectを取得する。取得したオブジェクトは一つしか生成しないようにしなければならないし、特別な状況じゃないとアプリケーションが終わるまで開放しないべきである。</p>

<p>また、<code>hinst</code>にはプロセス（アプリケーション）またはDLLのハンドルを入れるべき。普通は<code>GetModuleHandleW(nullptr)</code>でいいかも…</p>

<h2 id="2-guidを持つ全てのデバイスを検知">2. GUIDを持つ全てのデバイスを検知</h2>

<p>DirectInputはシステムが認知しているすべての入力デバイスを巡回し、連結されているかないか、そしてデバイスの情報を取得することが出来るようになっている。このデバイス全体を巡回して情報を要請することを<strong>Enumeration</strong>という。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417804(v%3dvs.85)">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417804%28v%3dvs.85%29</a></p>
</blockquote>

<p>Enumerationを行うためには、先程取得したDirectInput Objectの<code>EnumDevices</code>関数を使う。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">EnumDevices</span><span class="p">(</span>
         <span class="n">DWORD</span> <span class="n">dwDevType</span><span class="p">,</span>
         <span class="n">LPDIENUMDEVICESCALLBACK</span> <span class="n">lpCallback</span><span class="p">,</span>
         <span class="n">LPVOID</span> <span class="n">pvRef</span><span class="p">,</span>
         <span class="n">DWORD</span> <span class="n">dwFlags</span>
<span class="p">)</span>
</code></pre></div>
<p><code>dwDevType</code>は<code>DI8DEVCLASS_</code>列挙型の値を入れて、巡回させるデバイスの種類を縛る。コントローラーだけで縛って検証させるなら<code>DI8DEVCLASS_GAMECTRL</code>だけでいいかも。</p>

<p><code>lpCallback</code>は巡回するデバイスの情報などを取得ためのコールバック関数のポインターを指定する。関数の型は以下のようにしなければならない。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">BOOL</span> <span class="p">(</span><span class="o">*</span><span class="n">LPDIENUMDEVICESCALLBACK</span><span class="p">)(</span><span class="n">LPCDIDEVICEINSTANCE</span> <span class="n">lpddi</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">pvRef</span><span class="p">);</span>
</code></pre></div>
<p><code>pvRef</code>引数はコールバック関数に持っていくことが出来るポインター変数である。<code>lpddi</code>は<code>EnumDevices</code>関数で取得できたデバイスリストのデバイスインスタンスのポインターである。</p>

<p>普通はコールバック関数で、縛ったデバイスインスタンスの情報を検証して<code>pvRef</code>の構造体に情報を入れて使えるように準備をするようにしていればOKかもしれない…</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416610(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416610(v=vs.85)?redirectedfrom=MSDN</a></p>
</blockquote>

<p>コールバック関数で持ってこれる<code>DIDEVICEINSTANCE</code>構造体は以下のようになっている。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">DIDEVICEINSTANCE</span> <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">dwSize</span><span class="p">;</span>
    <span class="n">GUID</span> <span class="n">guidInstance</span><span class="p">;</span>
    <span class="n">GUID</span> <span class="n">guidProduct</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwDevType</span><span class="p">;</span>
    <span class="n">TCHAR</span> <span class="n">tszInstanceName</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
    <span class="n">TCHAR</span> <span class="n">tszProductName</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
    <span class="n">GUID</span> <span class="n">guidFFDriver</span><span class="p">;</span>
    <span class="n">WORD</span> <span class="n">wUsagePage</span><span class="p">;</span>
    <span class="n">WORD</span> <span class="n">wUsage</span><span class="p">;</span>
<span class="p">}</span> <span class="n">DIDEVICEINSTANCE</span><span class="p">,</span> <span class="o">*</span><span class="n">LPDIDEVICEINSTANCE</span><span class="p">;</span>
</code></pre></div>
<p>注意する点は、新しいAPIの<strong>xinput</strong>がデバイスによって同時にサポートされていることがありうるので、<code>guidProduct</code>を使ってxinputを支援しているかを確認しなければならない。</p>

<p>とにかく取得したいデバイスを探したら、<code>CreateDevice</code>関数を使ってDIDOを取得する。</p>

<h2 id="3-適合なデバイスからdirectinput-device-object取得">3. 適合なデバイスからDirectInput Device Object取得</h2>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417803(v%3Dvs.85">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417803(v%3Dvs.85</a>)</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">CreateDevice</span><span class="p">(</span>
         <span class="n">REFGUID</span> <span class="n">rguid</span><span class="p">,</span>
         <span class="n">LPDIRECTINPUTDEVICE</span> <span class="o">*</span> <span class="n">lplpDirectInputDevice</span><span class="p">,</span>
         <span class="n">LPUNKNOWN</span> <span class="n">pUnkOuter</span>
<span class="p">)</span>
</code></pre></div>
<p><code>rguid</code>にGUIDを入れるが、必ずインスタンスのGUIDである必要がある。<code>pUnkOuter</code>はCOM Aggregationのための引数であるため、今は使わない。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// 3. Get DirectInput Device Object pointer.
</span><span class="c1"></span><span class="n">IDirectInputDevice8</span><span class="o">*</span> <span class="n">p_device</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">p_dio</span><span class="o">-&gt;</span><span class="n">CreateDevice</span><span class="p">(</span><span class="n">lpddi</span><span class="o">-&gt;</span><span class="n">guidInstance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p_device</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DI_OK</span><span class="p">)</span>
<span class="p">{</span> 
    <span class="k">return</span> <span class="n">DIENUM_CONTINUE</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div>
<h2 id="4-didoのco-operation-level-format-properties設定">4. DIDOのco-operation level、format、properties設定</h2>

<h3 id="co-operation-level">co-operation level</h3>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417921(v%3Dvs.85">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417921(v%3Dvs.85</a>)</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">SetCooperativeLevel</span><span class="p">(</span>
         <span class="n">HWND</span> <span class="n">hwnd</span><span class="p">,</span>
         <span class="n">DWORD</span> <span class="n">dwFlags</span>
<span class="p">)</span>
</code></pre></div>
<p>生成した窓の状態に対し（バックかフォアか、それとも特別な状態を持っているか）、取得したDIDOからのシグナル検知の権限を設定する。</p>

<p>僕の個人プロジェクトでは、表に見える窓だけではなくてバックグラウンドで動く窓もあるため、<code>dwFlags</code>は<code>DISCL_BACKGROUND | DISCL_EXCLUSIVE</code>にする。</p>

<h3 id="data-formats">Data formats</h3>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417925(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417925(v=vs.85)?redirectedfrom=MSDN</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">SetDataFormat</span><span class="p">(</span>
         <span class="n">LPCDIDATAFORMAT</span> <span class="n">lpdf</span>
<span class="p">)</span>
</code></pre></div>
<p>取得したDIDOから、どのようにデータを解釈して取得させるようにするかを設定する。実は<code>DIDATAFORMAT</code>構造体に値を入れてポインターとして入れなければならないか、DINPUTヘッダーファイル自体ですでに決まったものを入れれば良いらしい。</p>

<ul>
<li>c_dfDIKeyboard</li>
<li>c_dfDIMouse</li>
<li>c_dfDIJoystick</li>
<li>c_dfDIJoystick2</li>
</ul>

<blockquote>
<p>&hellip;
ちなみに実はジョイスティックには2種類の入力フォーマットがあり、そのもう1つが<strong>c_dfDIJoystick2</strong>と定義されています。
実際にはボタンやアナログの数が増えただけなので、PS2などの標準コントローラを使う分には特に意味はありませんが、
入力の多いデバイスを使用する場合はこちらの方を使う必要があります。
※<strong>c_dfDIJoystick</strong>と<strong>c_dfDIJoystick2</strong>のどちらを使用しても取得出来る分は取得できます
&hellip;</p>

<p>from : <a href="http://www.charatsoft.com/develop/otogema/page/07input/joystick.html">http://www.charatsoft.com/develop/otogema/page/07input/joystick.html</a></p>
</blockquote>

<p>データフォーマットを入れたら、後でデバイスのキー状態などを取得する際には入れた値にあっている構造体を入れなければならない。例えば、<code>c_dfDIJoystick</code>を入れた時には<code>DIJOYSTATAE</code>を使う。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416627(v%3Dvs.85">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416627(v%3Dvs.85</a>)</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">DIJOYSTATE</span> <span class="p">{</span>
    <span class="n">LONG</span> <span class="n">lX</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">lY</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">lZ</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">lRx</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">lRy</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">lRz</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">rglSlider</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">DWORD</span> <span class="n">rgdwPOV</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="n">BYTE</span> <span class="n">rgbButtons</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">}</span> <span class="n">DIJOYSTATE</span><span class="p">,</span> <span class="o">*</span><span class="n">LPDIJOYSTATE</span><span class="p">;</span>
</code></pre></div>
<h3 id="properties">Properties</h3>

<p>普通のゲームコントローラーって、デジタルのボタンなどを除くと、Lスティック、Rスティックそしてタッチパネルまたは特殊トリガーのような<strong>アナログ</strong>数値を持つ要素が残る。コントローラーごとにこのスティックなどの読み取り値が違うかもしれないので、それを一つの範囲などに合わせなければならない。その設定を<code>GetCapabilities</code>と<code>SetProperty</code>で設定することが出来るらしい。</p>

<p>まず、<code>GetCapabilities</code>と<code>DIDIVCAPS</code>構造体でDIDOのDevice Object情報を取得する必要がある。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417892(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417892(v=vs.85)?redirectedfrom=MSDN</a></p>

<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416607(v%3dvs.85)">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416607%28v%3dvs.85%29</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="nf">GetCapabilities</span><span class="p">(</span><span class="n">LPDIDEVCAPS</span> <span class="n">lpDIDevCaps</span><span class="p">)</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">DIDEVCAPS</span> <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">dwSize</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwFlags</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwDevType</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwAxes</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwButtons</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwPOVs</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwFFSamplePeriod</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwFFMinTimeResolution</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwFirmwareRevision</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwHardwareRevision</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwFFDriverVersion</span><span class="p">;</span>
<span class="p">}</span> <span class="n">DIDEVCAPS</span><span class="p">,</span> <span class="o">*</span><span class="n">LPDIDEVCAPS</span><span class="p">;</span>
</code></pre></div>
<p>そしてプロパティーを設定するなら、<code>SetProperty</code>を使う。ただし、設定したいプロパティーによって記述する構造体がそれぞれ違う。例えばスティック軸の数値の範囲を決めたい場合には下のコードのようにしなければならない。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416638(v%3dvs.85)">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416638%28v%3dvs.85%29</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">DIPROPHEADER</span> <span class="n">header</span><span class="p">;</span>
<span class="n">header</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DIPROPRANGE</span><span class="p">);</span>
<span class="n">header</span><span class="p">.</span><span class="n">dwHeaderSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DIPROPHEADER</span><span class="p">);</span>
<span class="n">header</span><span class="p">.</span><span class="n">dwObj</span> <span class="o">=</span> <span class="o">???</span><span class="p">;</span>
<span class="n">header</span><span class="p">.</span><span class="n">dwHow</span> <span class="o">=</span> <span class="o">???</span><span class="p">;</span>

<span class="n">DIPROPRANGE</span> <span class="n">range</span><span class="p">;</span>
<span class="n">range</span><span class="p">.</span><span class="n">diph</span> <span class="o">=</span> <span class="n">header</span><span class="p">;</span>
<span class="n">range</span><span class="p">.</span><span class="n">lMin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span><span class="p">;</span>
<span class="n">range</span><span class="p">.</span><span class="n">lMax</span> <span class="o">=</span> <span class="o">+</span><span class="mi">100</span><span class="p">;</span>

<span class="n">gameController</span><span class="o">-&gt;</span><span class="n">SetProperty</span><span class="p">(</span><span class="n">DIPROP_RANGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">range</span><span class="p">.</span><span class="n">header</span><span class="p">);</span>
</code></pre></div>
<p>注目すべき所は、<code>DIPROPHEADER</code>構造体の<code>dwObj</code>と<code>dwHow</code>である。公式の説明ページを見ればわかるかもしれないが、<code>dwHow</code>にはデバイスではなく、DIDOの中にある軸、ボタンなどのインスタンスを指すための<code>DIPH_BYID</code>を入れなければならない。</p>

<p>ただし、<code>DIPH_BYID</code>を入れたら、<code>dwObj</code>には<code>EnumObjects</code>関数で呼び出しするコールバック関数の中で取得できるインスタンスのIDを<code>dwObj</code>に入れなければならなくなる。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417889(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417889(v=vs.85)?redirectedfrom=MSDN</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">EnumObjects</span><span class="p">(</span>
         <span class="n">LPDIENUMDEVICEOBJECTSCALLBACK</span> <span class="n">lpCallback</span><span class="p">,</span>
         <span class="n">LPVOID</span> <span class="n">pvRef</span><span class="p">,</span>
         <span class="n">DWORD</span> <span class="n">dwFlags</span>
<span class="p">)</span>
  
<span class="c1">// Callback function pointer type
</span><span class="c1"></span><span class="n">BOOL</span> <span class="p">(</span><span class="o">*</span><span class="n">LPDIENUMDEVICEOBJECTSCALLBACK</span><span class="p">)(</span><span class="n">LPCDIDEVICEOBJECTINSTANCE</span> <span class="n">lpddoi</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">pvRef</span><span class="p">)</span>
</code></pre></div>
<p>書き方は上の<code>EnumDevices</code>と同じだが、<code>dwFlags</code>のフラグ値とコールバック関数の中での<code>SetProperty</code>コールに使われる構造体がよく合っていなければならない。（かもしれない）</p>

<p>ということで手順をまとめると、</p>

<ol>
<li><code>IDirectInputDevice8</code>のDIDOを取得し、</li>
<li><code>EnumObjects</code>関数で調べたいインスタンスの縛ってイテレーションさせ、</li>
<li>その中で適切なインスタンスがあったら<code>DIPROPHEADER</code>の入っている適切な構造体を記述して</li>
<li><code>SetProperty</code>でインスタンスに設定をする。</li>
</ol>

<p>アナログスティックの場合には、<strong>デッドゾーン（Deadzone)</strong>っていうのがあって、スティックを動かさないと必ず中立（0）の数値になるのではなく0に違い数値を表す時があって、それに対する誤動作を防ぐための判定範囲を設けなければならない。</p>

<p>アナログスティックなどのデッドゾーンを決めるには<code>DIPROPWORD</code>と<code>DIPROP_DEADZONE</code>を使う。ここで中止することは、デッドゾーンの数値は固定された0~10000までの範囲から決めなかればならない。例えばスティック入力の1%以内をデッドゾーンとして決めたいなら、100を入れる。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416636(v%3dvs.85)">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416636%28v%3dvs.85%29</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">DIPROPDWORD</span> <span class="p">{</span>
    <span class="n">DIPROPHEADER</span> <span class="n">diph</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">dwData</span><span class="p">;</span>
<span class="p">}</span> <span class="n">DIPROPDWORD</span><span class="p">,</span> <span class="o">*</span><span class="n">LPDIPROPDWORD</span><span class="p">;</span>
</code></pre></div>
<p>ちなみに元記事ではRANGEとWORDを同時に設定している。</p>

<h2 id="5-device-objectを取得-acquire">5. Device Objectを取得(Acquire)</h2>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417818(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417818(v=vs.85)?redirectedfrom=MSDN</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">Acquire</span><span class="p">()</span>
</code></pre></div>
<p>設定した入力デバイスに接近する権限を得る。アプリケーションを終了したり、それとも使っているコントローラーのアクセス権限を返却する場合には</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417931(v=vs.85">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417931(v=vs.85</a>)</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">Unacquire</span><span class="p">()</span>
<span class="c1">// and
</span><span class="c1"></span><span class="n">HRESULT</span> <span class="n">Release</span><span class="p">()</span>
</code></pre></div>
<p>を使う。（Releaseを連続で呼び出すのは、CreateDeviceで参照カウントが１増加されたから）</p>

<h2 id="6-デバイスの入力をpollするかreadを行う">6. デバイスの入力をPollするかReadを行う</h2>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417913(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417913(v=vs.85)?redirectedfrom=MSDN</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">Poll</span><span class="p">()</span>
</code></pre></div>
<p>取得したデバイスによって違われるかもしれないが、大体は<code>Poll()</code>関数でデバイスか入力情報を取得しなおさなければならない。あるデバイスは自分からインターラプト（Interrupt）をかけて入力データを取得するようにするものもあるが、そのデバイスに限っては<code>Poll()</code>を呼び出す必要はない（読んだとしてもエラーにはならない）</p>

<p>もしかして<code>Poll</code>関数を呼ぶ必要があるかを確かめる為には、<code>GetCapabilities()</code>関数で<code>DIDEVCAPS</code>の<code>DIDC_POLLEDDATAFORMAT</code>を確認すれば良いらしい。</p>

<blockquote>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417897(v=vs.85)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee417897(v=vs.85)?redirectedfrom=MSDN</a></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">HRESULT</span> <span class="n">GetDeviceState</span><span class="p">(</span>
         <span class="n">DWORD</span> <span class="n">cbData</span><span class="p">,</span>
         <span class="n">LPVOID</span> <span class="n">lpvData</span>
<span class="p">)</span>
</code></pre></div>
<p>デバイスで更新された情報を持ってくるためには上の関数を使う。ただし、この関数を使うには<code>lpvData</code>は前にDIDOのデータフォーマット（DataFormat）を設定した時の値に対応している構造体を入れなければならない。</p>

<table>
<thead>
<tr>
<th>Data Format</th>
<th>State Structure</th>
</tr>
</thead>

<tbody>
<tr>
<td>c_dfDIMouse</td>
<td><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416630(v%3dvs.85)">DIMOUSESTATE</a></td>
</tr>

<tr>
<td>c_dfDIMouse2</td>
<td><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416631(v%3dvs.85)">DIMOUSESTATE2</a></td>
</tr>

<tr>
<td>c_dfDIKeyboard</td>
<td>array of 256 bytes</td>
</tr>

<tr>
<td>c_dfDIJoystick</td>
<td><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416627(v%3dvs.85)"> DIJOYSTATE</a></td>
</tr>

<tr>
<td>c_dfDIJoystick2</td>
<td><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416628(v%3dvs.85)">DIJOYSTATE2</a></td>
</tr>
</tbody>
</table>

<h2 id="7-directinput-objectを開放して終わり">7. DirectInput Objectを開放して終わり</h2>

<p>「5. Device Objectを取得(Acquire)」を見ること。</p>
]]></content>
		</item>
		
		<item>
			<title>TLSF Allocatorを作ってみた</title>
			<link>https://liliilli.github.io/posts/tlsf_basic/</link>
			<pubDate>Sun, 15 Mar 2020 19:13:14 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/tlsf_basic/</guid>
			<description>TLSFとは何なのか http://www.gii.upv.es/tlsf/ http://www.gii.upv.es/tlsf/files/ecrts04_tlsf.pdf https://www.researchgate.net/publication/234785757_A_comparison_of_memory_allocators_for_real-time_applications TLSF（Two-Level Segregate Fit）は、リアルタイムで要求される速度、安定性、決定性（Deterministic</description>
			<content type="html"><![CDATA[

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<h1 id="tlsfとは何なのか">TLSFとは何なのか</h1>

<blockquote>
<p><a href="http://www.gii.upv.es/tlsf/">http://www.gii.upv.es/tlsf/</a><br>
<a href="http://www.gii.upv.es/tlsf/files/ecrts04_tlsf.pdf">http://www.gii.upv.es/tlsf/files/ecrts04_tlsf.pdf</a><br>
<a href="https://www.researchgate.net/publication/234785757_A_comparison_of_memory_allocators_for_real-time_applications">https://www.researchgate.net/publication/234785757_A_comparison_of_memory_allocators_for_real-time_applications</a></p>
</blockquote>

<p>TLSF（Two-Level Segregate Fit）は、リアルタイムで要求される速度、安定性、決定性（Deterministic）を重視としたメモリ割当のアルゴリズム、そしてそれを実装したメモリアロケータを示します。普通のかんたんなメモリプール（Pool）とは違って、割当をしたいサイズを入れればその分のメモリを割り当ててくれる汎用性も持ちます。</p>

<p>普通に<code>malloc</code>とか<code>free</code>とかすれば良いんじゃね？と思う方もいると思いますが、メモリが十分なら普通にシステムコールをして構わないと思います。しかし、組み込み系とかビデオゲーム機の中に仕込まれた限定的なメモリを十分活用しくちゃという状況なら<code>malloc</code>とか<code>free</code>だけでは内部メモリのフラグメンテーションを抑えることは出来ません。</p>

<p>（OS自体でメモリの管理を行ってフラグメンテーションを抑えることは出来ると思いますが、厳密にはAPP側でもそれを制御したいですね）</p>

<p>なんでそのフラグメンテーションを抑えながらも速度を保つためにいろんなDMA（Dynamic Memory Allocator（動的メモリ確保））アルゴリズムが出ました。その中で一つのアルゴリズムがTLSFです。</p>

<p>TLSFは以下の特徴を持つそうです。</p>

<ul>
<li>メモリの確保、解除などに最悪<code>O(1)</code>の処理時間を持つ。</li>
<li>x86アーキテクチャで最悪168個のアセンブリコードを持つため、比較的速い。</li>
<li>平均15~25％のフラグメンテーション性能向上している。</li>
<li>リアルタイム条件のプログラムなでど使える。</li>
<li>確保したメモリの領域を拡張・縮小することが出来る。（この記事ではこれの実装は扱いません）</li>
</ul>

<h1 id="tlsfの概略な構造">TLSFの概略な構造</h1>

<blockquote>
<p><a href="http://www.gii.upv.es/tlsf/files/papers/tlsf_desc.pdf">http://www.gii.upv.es/tlsf/files/papers/tlsf_desc.pdf</a></p>
</blockquote>

<p>上の説明文をお読みください。</p>

<h1 id="なんでtlsfを実装しようとしたの">なんでTLSFを実装しようとしたの</h1>

<p>いくつかのゲームエンジンの中で、メモリを制御するために実装されているのがTLSFだったからです。それにOSでも使ってるらしいし、インターネットで一番明確ながらもソースコードも公開がされ、勉強になりそうなアルゴリズム（ライブラリー）だったので、まずTLSFから始めようとして実装することになりました。</p>

<p>また、TLSF自体はソースが公開されてはいるんですが、ライセンスがGPLまたはLPGLであるため自分の作っているプロジェクトに取り入れることが難しかったです。なので勉強兼ねて新しく実装し、それを個人プロジェクトに入れようとしたいこともあります。</p>

<h1 id="ソースコード">ソースコード</h1>

<blockquote>
<p><a href="https://gist.github.com/liliilli/01d0a8505dcc3fe4f5c951fbc179c769">https://gist.github.com/liliilli/01d0a8505dcc3fe4f5c951fbc179c769</a></p>
</blockquote>

<p>説明する前に、まずコードを見せたいと思います。</p>

<p>TSLF関数の全体を説明するのではなく、一部だけを取って説明したいですので、全体のフローはソースコードを見てください。</p>

<h1 id="基本apiリスト">基本APIリスト</h1>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//! @brief Create tlsf pool.
</span><span class="c1">//! @param pool_size Overall memory pool size.
</span><span class="c1">//! @param p_pool Memory pool pointer to start.
</span><span class="c1">//! @return If successful, return available memory size of pool.
</span><span class="c1">//!     If failed, return one of error codes below.
</span><span class="c1">//!     * ADDRESS_IS_NULL : given p_pool is nullptr.
</span><span class="c1">//!     * SIZE_IS_ZERO : pool_size is 0.
</span><span class="c1">//!     * NOT_SUFFICIENT_MEM_SIZE : pool_size is not sufficient to create tlsf allocator.
</span><span class="c1">//!     * NOT_ALIGNED_ADDRESS : p_pool is not aligned.
</span><span class="c1"></span><span class="n">u64</span> <span class="nf">tlsf_raw_create</span><span class="p">(</span><span class="n">u64</span> <span class="n">pool_size</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">p_pool</span><span class="p">)</span> <span class="n">DY_NOEXCEPT</span><span class="p">;</span>

<span class="c1">//! @brief Destroy tlsf memory pool trivially.
</span><span class="c1">//!     This function does not check tlsf has a valid object.
</span><span class="c1">//! @param p_pool Valid tlsf memory pool pointer.
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">tlsf_raw_destroy</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p_pool</span><span class="p">)</span> <span class="n">DY_NOEXCEPT</span><span class="p">;</span>

<span class="c1">//! @brief Check if tlsf memory pool can be destroyed safely.
</span><span class="c1">//!     This function checks tlsf has valid and every objects are released.
</span><span class="c1">//! @param p_pool valid tlsf memory pool pointer.
</span><span class="c1"></span><span class="kt">bool</span> <span class="nf">tlsf_can_destroy</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p_pool</span><span class="p">)</span> <span class="n">DY_NOEXCEPT</span><span class="p">;</span>

<span class="c1">//! @brief Try allocate memory with given mem_size.
</span><span class="c1">//!     Created memory block may not have same mem_size size value, but aligned memory size.
</span><span class="c1">//!     This function only should be used POD types. (trivial or standard_layout type)
</span><span class="c1">//! @param mem_size Minimum memory size to allocate.
</span><span class="c1">//! @param p_tlsf Tlsf pool pointer.
</span><span class="c1">//! @return If successful, return buffer pointer. Otherwise, return nullptr.
</span><span class="c1"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">tlsf_malloc</span><span class="p">(</span><span class="n">u64</span> <span class="n">mem_size</span><span class="p">,</span> <span class="n">tlsf_raw_t</span><span class="o">*</span> <span class="n">p_tlsf</span><span class="p">)</span> <span class="n">DY_NOEXCEPT</span><span class="p">;</span>

<span class="c1">//! @brief Try reallocate valid memory trivially.
</span><span class="c1">//!     Reallocated memory block may not have same mem_size size value, but aligned memory size.
</span><span class="c1">//!     This function only must be used POD types. (trivial or standard_layout type)
</span><span class="c1">//! @param p_data Valid data pointer. This pointer should be in given p_tlsf pool.
</span><span class="c1">//! @param mem_size Minimum memory size to reallocate.
</span><span class="c1">//! @param p_tlsf Tlsf pool pointer.
</span><span class="c1">//! @return If successful, return reallocated buffer pointer.
</span><span class="c1">//!     Otherwise, return nullptr.
</span><span class="c1"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">tlsf_realloc</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p_data</span><span class="p">,</span> <span class="n">u64</span> <span class="n">new_size</span><span class="p">,</span> <span class="n">tlsf_raw_t</span><span class="o">*</span> <span class="n">p_tlsf</span><span class="p">)</span> <span class="n">DY_NOEXCEPT</span><span class="p">;</span>

<span class="c1">//! @brief Try calloc memory trivially.
</span><span class="c1">//!     Created memory block may not have same mem_size size value, but aligned memory size.
</span><span class="c1">//!     This function only should be used POD types. (trivial or standard_layout type)
</span><span class="c1">//!     Created memory will be initialized with 0 (i32)
</span><span class="c1">//! @param mem_size Minimum memory size to allocate.
</span><span class="c1">//! @param elem_cnt The count of element list to allocate.
</span><span class="c1">//! @param p_tlsf Tlsf pool pointer.
</span><span class="c1">//!
</span><span class="c1">//! @return If successful, return buffer pointer. Otherwise, return nullptr.
</span><span class="c1"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">tlsf_calloc</span><span class="p">(</span><span class="n">u64</span> <span class="n">mem_size</span><span class="p">,</span> <span class="n">u64</span> <span class="n">elem_cnt</span><span class="p">,</span> <span class="n">tlsf_raw_t</span><span class="o">*</span> <span class="n">p_tlsf</span><span class="p">)</span> <span class="n">DY_NOEXCEPT</span><span class="p">;</span>

<span class="c1">//! @brief Free valid memory trivially.
</span><span class="c1">//!     This function only should be called when p_data is POD type. (trivial or standard_layout)
</span><span class="c1">//! @param p_data Valid data pointer.
</span><span class="c1">//! @param p_tlsf_pool Tlsf pool pointer.
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">tlsf_free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p_data</span><span class="p">,</span> <span class="n">tlsf_raw_t</span><span class="o">*</span> <span class="n">p_tlsf_pool</span><span class="p">)</span> <span class="n">DY_NOEXCEPT</span><span class="p">;</span>
</code></pre></div>
<ul>
<li><code>tlsf_raw_create</code>：確保したメモリ領域にTLSFプールを作ろうとします。<br>TLSF自体は確保されたオブジェクトのメモリ領域を管理するために、ちょっと大きいヘッダー構造体が入れるので、メモリ数値がそれの大きさ以上にならないとTLSFプールの生成は失敗になります。</li>
<li><code>tlsf_raw_destroy</code>：有効なTLSFプールを解除します。ただし、この関数はオブジェクトの確保されたメモリは解除してくれないため、この関数を呼ぶ前に<code>tlsf_can_destroy</code>でTLSFプールが解除できるかを確認することが必要です。</li>
<li><code>tlsf_can_destroy</code>：有効なTLSFプールが解除できるかを問います。TLSFプールのメモリ管理をするTLSFヘッダー構造体は、プールで確保または解除が行われるたびにいくらのメモリ数値が変動されたかを覚えます。その数値が<code>0</code>かではないかを検査してプールが最終的に解除できるかを判断します。</li>
<li><code>tlsf_malloc</code>：TLSFプールに対しmalloc（メモリ確保）をやってくれます。もし確保されたプールで入れられるメモリブロックがなければ、確保失敗で<code>nullptr</code>が返されます。また注意する点は、メモリが成功的に確保されるとき、必ずしも<code>mem_size</code>サイズだけが確保されるわけではないです。TLSF自体は出来る限り8Byteまたは16Byte桁アドレスに合わせようとするので、実際に確保されるメモリも当然8または16バイトに合わせようとします。</li>
<li><code>tlsf_realloc</code>：同一TLSFプールから確保したメモリを再確保（realloc）します。TLSFプールのフラグメンテーションによって別の領域で再確保を行うか、それともメモリを拡張するだけで収めれるか分かれることがあります。また、再確保するメモリサイズに比べてプールの現状確保出来るメモリ量が足りなかったら、再確保は失敗します。</li>
<li><code>tlsf_calloc</code>：Cライブラリーの<code>calloc</code>と一緒です。メモリ確保が成功したら、メモリ空間を0で初期化してくれます。</li>
<li><code>tlsf_free</code>：TLSFメモリプールから確保したメモリを解除します。</li>
</ul>

<h1 id="説明">説明</h1>

<h2 id="1-tlsf-raw-create">1.<code>tlsf_raw_create</code></h2>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="n">mem_pool_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tlsf_raw_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">block_header_t</span><span class="o">::</span><span class="n">sk_block_header_ovhd</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">error_info</span><span class="p">{</span> <span class="n">NOT_SUFFICIENT_MEM_SIZE</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div>
<p>確保しようとするTLSFメモリプールのサイズが一定値以上かをチェックします。<code>tlsf_raw_t</code>はTLSFメモリプールを管理する構造体です。<code>block_header_t</code>は確保されるオブジェクトのメモリ空間の前に出てくるヘッダーです。現在オブジェクトのメモリサイズがいくらか、前、次のメモリブロックはどこに位置しているかについて情報を持ちます。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">tlsf_raw_t</span> <span class="k">final</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">u64</span> <span class="n">k_fli_max</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">u64</span> <span class="n">k_fli_offset</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">u64</span> <span class="n">k_fli_real</span> <span class="o">=</span> <span class="n">k_fli_max</span> <span class="o">-</span> <span class="n">k_fli_offset</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">u64</span> <span class="n">k_sli_log2_max</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">u64</span> <span class="n">k_sli_max</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">k_sli_log2_max</span><span class="p">;</span>

    <span class="n">u32</span>             <span class="n">m_tlsf_signature</span><span class="p">;</span>
    <span class="n">area_info_t</span><span class="o">*</span>    <span class="n">m_area_head</span><span class="p">;</span>
    <span class="n">u32</span>             <span class="n">m_fl_bitmap</span><span class="p">;</span>
    <span class="n">u32</span>             <span class="n">m_sl_bitmap</span><span class="p">[</span><span class="n">k_fli_real</span><span class="p">];</span>
    <span class="n">block_header_t</span><span class="o">*</span> <span class="n">mp_matrix</span><span class="p">[</span><span class="n">k_fli_real</span><span class="p">][</span><span class="n">k_sli_max</span><span class="p">];</span>
    <span class="n">u64</span>             <span class="n">m_max_mem</span><span class="p">;</span> <span class="c1">// いらなくて良し
</span><span class="c1"></span>    <span class="n">u64</span>             <span class="n">m_used_mem</span><span class="p">;</span>

    <span class="c1">// 以下メンバー関数宣言
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>
<p><code>tlsf_raw_t</code>で注目する変数は、<code>m_fl_bitmap</code>と<code>m_sl_bitmap</code>、そして<code>mp_matrix</code>です。</p>

<p><code>fl_bitmap</code>と<code>sl_bitmap</code>はメモリ解除されて使えるブロックのハッシュ情報をビット単位で刻んで入れられるようになった変数らしいです。TLSFはメモリの要求される容量によって２階層のリストから適度な空きブロックへのポインターを持ってこれるようになってるので、この変数でFirst-IndexとSecond-Indexを取得するようになってます。この変数を用いた取得のやり方は<code>find_suitable_block</code>関数で見れます。</p>

<p><code>mp_matrix</code>はメモリ解除されたメモリブロックのポインター先を持ちます。<code>find_suitable_block</code>の中で返されたFirst-IndexとSecond-Index数値でこの配列変数から割当をするブロックのヘッダーを取得します。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">block_header_t</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">u64</span> <span class="n">sk_min_block_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">free_ptr_t</span><span class="p">);</span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">u64</span> <span class="n">sk_block_header_ovhd</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">u8</span> <span class="n">sk_free_block</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">u8</span> <span class="n">sk_prev_free</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">;</span>

    <span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_prev_header</span><span class="p">;</span>
    <span class="n">u64</span>             <span class="n">stored_size</span><span class="p">;</span>
    <span class="k">union</span>
    <span class="p">{</span>
        <span class="n">free_ptr_t</span>      <span class="n">free_ptr</span><span class="p">;</span>
        <span class="n">block_buffer_t</span>  <span class="n">buffer</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">ptr</span><span class="p">;</span>
  
    <span class="c1">// 以下メンバー関数宣言
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>
<p><code>block_header_t</code>は確保された（または解除した後の）メモリブロックについての情報を持ちます。実際のデータバッファは<code>ptr.buffer</code>から始まり、<code>stored_size &gt;&gt; 2</code>バイトまで続きます。もしブロックが解除した状態なら<code>ptr</code>は<code>free_ptr</code>に前と後のブロックヘッダー情報を入れるようになっています。</p>

<p>また、<code>stored_size</code>はデータバッファのサイズだけではなく、0番と1番のビットに自分がフリーブロックなのか、そして前のブロックがフリーかをフラグとして設定するようにしています。なので、TLSFの中で確保されたデータバッファのサイズは必ず4倍の数値になります。（こうしてキャッシュラインなどが整頓される効果も得られます。）</p>

<p><code>tlsf_raw_create</code>関数にまた戻ってTLSFシグニチャーを設定し、<code>memset</code>で0に初期化を行います。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_area_info_bhdr</span> <span class="o">=</span> <span class="n">process_area</span><span class="p">(</span>
    <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">get_first_block_header</span><span class="p">(),</span> 
    <span class="n">get_rddn_size_default</span><span class="p">(</span><span class="n">mem_pool_size</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tlsf_raw_t</span><span class="p">))</span>
<span class="p">);</span>
<span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_area_head</span> <span class="o">=</span> <span class="p">(</span><span class="n">area_info_t</span><span class="o">*</span><span class="p">)</span><span class="n">p_area_info_bhdr</span><span class="o">-&gt;</span><span class="n">get_buffer</span><span class="p">();</span>
<span class="c1">// make first block of tlsf pool.
</span><span class="c1"></span><span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_first_bhdr</span> <span class="o">=</span> <span class="n">p_area_info_bhdr</span><span class="o">-&gt;</span><span class="n">get_next_block</span><span class="p">();</span>
<span class="n">tlsf_free</span><span class="p">(</span><span class="n">p_first_bhdr</span><span class="o">-&gt;</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">p_tlsf</span><span class="p">);</span>
</code></pre></div>
<p>TLSFメモリプールは普通のメモリプールとは違って扱うメモリ空間自体を拡張することが出来ます。ただし、拡張した別途のメモリ領域のアドレスは既存のTLSFと連続してない可能性があるので、リンクリスト（連結リスト）でアドレスを保持する必要があります。</p>

<p>そのため、<code>tlsf_raw_t</code>の後には追加メモリ領域が保持するブロックのアドレス情報を持つ構造体、<code>area_info_t</code>がついて来ます。（ただし、<code>area_info_t</code>自体も特殊ブロックのバッファ部分に置かれるようになっています。）</p>

<h3 id="process-area"><code>process_area()</code></h3>

<p><code>process_area()</code>関数は、TLSFプールの初期メモリブロックを設定する関数です。初期で設定されるメモリブロックは以下となります。</p>

<ul>
<li><code>p_ib</code>：<code>area_info_t</code>のブロック：別途のメモリ領域を使えるようにする。</li>
<li><code>p_next_b</code>：任意オブジェクトメモリ確保のためのブロック</li>
<li><code>p_next_next_b</code>：メモリ領域の終わりを示すブロック（バッファのサイズは0）</li>
</ul>

<p><code>p_next_b</code>のバッファサイズを初期化するとき、または<code>p_ib</code>のバッファサイズを設定する時には必ずメモリが整列されなければならないため、<code>get_rddn_size_default()</code>と<code>get_rddn_size_default()</code>関数を使ってメモリサイズを調整します。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_next_b</span> <span class="o">=</span> <span class="n">p_ib</span><span class="o">-&gt;</span><span class="n">get_next_block</span><span class="p">();</span>
<span class="n">p_next_b</span><span class="o">-&gt;</span><span class="n">set_buffer_size</span><span class="p">(</span><span class="n">get_rddn_size_default</span><span class="p">(</span>
    <span class="n">size</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">block_header_t</span><span class="o">::</span><span class="n">sk_min_block_size</span> <span class="o">-</span> <span class="n">p_ib</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">())</span>
<span class="p">);</span>
</code></pre></div>
<p><code>size - 3 * block_header_t::sk_min_block_size - p_ib-&gt;get_block_size()</code>は、まずTLSF構造体を除外したメモリサイズに３つのブロックヘッダーサイズと、<code>area_info_t</code>分のメモリサイズを引いた、TLSFプールが生成された後で使えるメモリ量を示します。</p>

<hr />

<p>本関数に戻って、</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"> <span class="c1">// make first block of tlsf pool.
</span><span class="c1"></span> <span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_first_bhdr</span> <span class="o">=</span> <span class="n">p_area_info_bhdr</span><span class="o">-&gt;</span><span class="n">get_next_block</span><span class="p">();</span>
 <span class="n">tlsf_free</span><span class="p">(</span><span class="n">p_first_bhdr</span><span class="o">-&gt;</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">p_tlsf</span><span class="p">);</span>
</code></pre></div>
<p><code>p_next_b</code>部分のブロックがまだ使える状態ではないので、TLSFを管理する構造体の<code>bitmap</code>変数と<code>matrix</code>にアドレスをフラグを更新して使えるため<code>free</code>関数を呼びます。最後には<code>p_next_b</code>の使えるメモリ量を返して終わりです。</p>

<h2 id="2-tlsf-malloc">2.<code>tlsf_malloc</code></h2>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">mem_size</span> <span class="o">=</span> <span class="n">calc_min_memblock_size</span><span class="p">(</span><span class="n">mem_size</span><span class="p">);</span>
<span class="k">const</span> <span class="k">auto</span> <span class="n">rs_search</span>   <span class="o">=</span> <span class="n">mapping_search</span><span class="p">(</span><span class="n">mem_size</span><span class="p">);</span>
<span class="k">const</span> <span class="k">auto</span> <span class="n">rs_suitable</span> <span class="o">=</span> <span class="n">find_suitable_block</span><span class="p">(</span><span class="n">p_tlsf_pool</span><span class="p">,</span> <span class="n">rs_search</span><span class="p">.</span><span class="n">flv</span><span class="p">,</span> <span class="n">rs_search</span><span class="p">.</span><span class="n">slv</span><span class="p">);</span>

<span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_b</span> <span class="o">=</span> <span class="n">rs_suitable</span><span class="p">.</span><span class="n">p_block_hdr</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">rs_suitable</span><span class="p">.</span><span class="n">flv</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">rs_suitable</span><span class="p">.</span><span class="n">slv</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>
<p>まず、TLSFプールから適当なメモリブロックを探します。一次に<code>mapping_search</code>関数で、First-IndexとSecond-Indexを取得し、最終に<code>find_suitable_block</code>で取得出来たブロックヘッダーのポインターと最終First-Index、Second-Indexを持ってくるようにします。</p>

<h3 id="mapping-search"><code>mapping_search()</code></h3>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">const</span> <span class="k">auto</span> <span class="n">fl_sl</span> <span class="o">=</span> <span class="n">mapping_insert</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="n">result</span><span class="p">.</span><span class="n">flv</span> <span class="o">=</span> <span class="n">fl_sl</span><span class="p">.</span><span class="n">first_lv</span><span class="p">;</span>
<span class="n">result</span><span class="p">.</span><span class="n">slv</span> <span class="o">=</span> <span class="n">fl_sl</span><span class="p">.</span><span class="n">scnd_lv</span><span class="p">;</span>
</code></pre></div>
<p>まず<code>mapping_insert()</code>という関数を使って、First-Level Index（<code>flv</code>）とSecond-Level Index（<code>slv</code>）を取得します。</p>

<h3 id="mapping-insert"><code>mapping_insert()</code></h3>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">k_small_block</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">result</span><span class="p">.</span><span class="n">first_lv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">scnd_lv</span>  <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="p">(</span><span class="n">k_small_block</span> <span class="o">/</span> <span class="n">tlsf_raw_t</span><span class="o">::</span><span class="n">k_sli_max</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="n">result</span><span class="p">.</span><span class="n">first_lv</span> <span class="o">=</span> <span class="n">ms_bit</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="n">result</span><span class="p">.</span><span class="n">scnd_lv</span>  <span class="o">=</span> 
        <span class="p">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">first_lv</span> <span class="o">-</span> <span class="n">tlsf_raw_t</span><span class="o">::</span><span class="n">k_sli_log2_max</span><span class="p">))</span> 
      <span class="o">-</span> <span class="n">tlsf_raw_t</span><span class="o">::</span><span class="n">k_sli_max</span><span class="p">;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">first_lv</span> <span class="o">-=</span> <span class="n">tlsf_raw_t</span><span class="o">::</span><span class="n">k_fli_offset</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>この関数でFirst-Level IndexとSecond-Level Indexを持ってきます。ところで、ここで<code>size</code>は8Byte整列されたサイズです。そして定数は以下となります。</p>

<ul>
<li>k_small_block：128Byte</li>
<li>tlsf_raw_t::k_sli_max：32</li>
<li>tlsf_raw_t::k_sli_log2_max：5</li>
<li>tlsf_raw_t::k_fli_offset：6（2^6 == 128Bytes）</li>
</ul>

<p>まず、<code>size</code>が128Byte以下になると、TLSFプールで提供されてるメモリブロックの中で一番小さいものが確保されるようになります。しかし、それ以上になるともっと適切なFLIとSLIの数値を持って来るため、下のようなアルゴリズムを通します。
$$
\begin{align}
\text{mapping}(\text{size}) &amp;\rightarrow (f, s) \\<br />
\text{mapping}(\text{size}) &amp;=
\begin{cases}
f := \lfloor log_2(size) \rfloor \\<br />
s := size * \frac{2^{SLI}}{2^f} - 2^{SLI}
\end{cases}
\end{align}
$$
真ん中の<code>result.first_lv - tlsf_raw_t::k_sli_log2_max</code>は以下となります。
$$
\alpha = log_2(2^{f - SLI})
$$
上の関数では128Byte以下のブロックは全部FLIが0になるし、128Byte以上から1以上のインデックスを持つため、6を引く必要があります。最後に<code>first_lv</code>に6を引くのはそのためです。</p>

<h3 id="find-suitable-block"><code>find_suitable_block()</code></h3>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">const</span> <span class="n">u32</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_sl_bitmap</span><span class="p">[</span><span class="n">fl</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="n">sl</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
<span class="p">{</span>   <span class="c1">// if tmp is not 0.
</span><span class="c1"></span>    <span class="n">result</span><span class="p">.</span><span class="n">flv</span> <span class="o">=</span> <span class="n">fl</span><span class="p">;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">slv</span> <span class="o">=</span> <span class="n">ls_bit</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="n">result</span><span class="p">.</span><span class="n">p_block_hdr</span> <span class="o">=</span> <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">mp_matrix</span><span class="p">[</span><span class="n">result</span><span class="p">.</span><span class="n">flv</span><span class="p">][</span><span class="n">result</span><span class="p">.</span><span class="n">slv</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>   <span class="c1">// if tmp is 0
</span><span class="c1"></span>    <span class="n">result</span><span class="p">.</span><span class="n">flv</span> <span class="o">=</span> <span class="n">ls_bit</span><span class="p">(</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_fl_bitmap</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">fl</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">flv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">result</span><span class="p">.</span><span class="n">slv</span> <span class="o">=</span> <span class="n">ls_bit</span><span class="p">(</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_sl_bitmap</span><span class="p">[</span><span class="n">result</span><span class="p">.</span><span class="n">flv</span><span class="p">]);</span>
        <span class="n">result</span><span class="p">.</span><span class="n">p_block_hdr</span> <span class="o">=</span> <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">mp_matrix</span><span class="p">[</span><span class="n">result</span><span class="p">.</span><span class="n">flv</span><span class="p">][</span><span class="n">result</span><span class="p">.</span><span class="n">slv</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><code>find_suitable_block()</code>関数は、<code>fl</code>と<code>sl</code>を使って最終的にマトリックスに登録されている、要請されたサイズより大きいか同じの適当なメモリブロックを返します。まず、最初にはSLI（Second-Level Index）を探索し、そしてFLIを探索する形でフリーブロックが位置されているFirst-IndexとSecond-Indexを取得します。そして、TLSF管理構造体にある配列から空いているブロックのアドレスを持って来るようにします。</p>

<p>ただし、この<code>flv</code>と<code>slv</code>が0より低い値になると適合なブロック探しは失敗になります。</p>

<h3 id="ls-bit-ms-bit"><code>ls_bit()</code> &amp; <code>ms_bit()</code></h3>

<ul>
<li>ls_bit：Find First Set（最初の１の値を持つビットの番地）を探します。</li>
<li>ms_bit：Find Last Set（最後に１の値を持つビットの番地）を探します。</li>
</ul>

<p>普通のアルゴリズムでも値を計算することは出来るんですが、この関数の中ではもっとビットを早く計算するためにテーブルを使ってます。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">static</span> <span class="k">constexpr</span> <span class="n">i32</span> <span class="n">sk_table</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> 
     <span class="c1">// ...
</span><span class="c1"></span>     <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span>
<span class="p">};</span>

<span class="c1">// in ms_bit (tls)
</span><span class="c1"></span><span class="k">const</span> <span class="n">u32</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">val</span><span class="p">;</span>
<span class="k">const</span> <span class="n">u32</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">u32</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;=</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="mh">0xFF</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">else</span>             <span class="p">{</span> <span class="k">return</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="mh">0xFFFFFF</span> <span class="o">?</span> <span class="mi">16</span> <span class="o">:</span> <span class="mi">24</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}(</span><span class="n">x</span><span class="p">);</span>
<span class="k">return</span> <span class="n">sk_table</span><span class="p">[</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>
</code></pre></div>
<hr />

<p>malloc関数に戻って…</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">extract_block_hdr</span><span class="p">(</span><span class="n">p_b</span><span class="p">,</span> <span class="n">p_tlsf_pool</span><span class="p">,</span> <span class="n">rs_suitable</span><span class="p">.</span><span class="n">flv</span><span class="p">,</span> <span class="n">rs_suitable</span><span class="p">.</span><span class="n">slv</span><span class="p">);</span>

<span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_nb</span> <span class="o">=</span> <span class="n">p_b</span><span class="o">-&gt;</span><span class="n">get_next_block</span><span class="p">();</span>
<span class="n">mem_size</span> <span class="o">=</span> <span class="n">rs_search</span><span class="p">.</span><span class="n">rdup_size</span><span class="p">;</span>
</code></pre></div>
<p>有効なフリーメモリブロックを取得した後には、それをマトリックスから外す必要があります。そして、ブロックと連結されている（リンクリストとして）メモリブロックがある場合には、そのブロックをマトリックスに登録する必要があります。<code>extract_block_hdr</code>はそれをやってくれます。</p>

<h3 id="extract-block-hdr"><code>extract_block_hdr()</code></h3>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"> <span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_item</span> <span class="o">=</span> 
     <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">mp_matrix</span><span class="p">[</span><span class="n">final_fl</span><span class="p">][</span><span class="n">final_sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_b</span><span class="o">-&gt;</span><span class="n">get_free_ptrs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
 <span class="k">if</span> <span class="p">(</span><span class="n">p_item</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="n">p_item</span><span class="o">-&gt;</span><span class="n">get_free_ptrs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">p_prev</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="k">else</span>
 <span class="p">{</span>
     <span class="n">clear_bit</span><span class="p">(</span><span class="n">final_sl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_sl_bitmap</span><span class="p">[</span><span class="n">final_fl</span><span class="p">]);</span>
     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_sl_bitmap</span><span class="p">[</span><span class="n">final_fl</span><span class="p">])</span>
     <span class="p">{</span>
         <span class="n">clear_bit</span><span class="p">(</span><span class="n">final_fl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_fl_bitmap</span><span class="p">);</span>
     <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div>
<p>この関数は、フリーブロック<code>p_b</code>に連結しているまた新しいフリーブロックを同じFirst、Second-Indexに連結して次のメモリ確保に対する準備を行うことをやってくれます。またインデックスに該当する新しいフリーブロックがない場合にはTLSF構造体からFirst、Second-Indexを参照するためのビットマップ（<code>m_sl_bitmap</code>、<code>m_fl_bitmap</code>）から自分のインデックス値が取得出来ないようにリセットします。</p>

<hr />
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="n">tmp_size</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">block_header_t</span><span class="p">))</span>
<span class="p">{</span>   <span class="c1">// 分割する。
</span><span class="c1"></span>    <span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_b2</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_header_t</span><span class="o">*</span><span class="p">)((</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">p_b</span><span class="o">-&gt;</span><span class="n">get_buffer</span><span class="p">()</span> <span class="o">+</span> <span class="n">mem_size</span><span class="p">);</span>
    <span class="c1">// Set p_b2 information...
</span><span class="c1"></span>  
    <span class="n">p_nb</span><span class="o">-&gt;</span><span class="n">set_prev_bhdr</span><span class="p">(</span><span class="n">p_b2</span><span class="p">);</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">split_fl</span><span class="p">,</span> <span class="n">split_sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping_insert</span><span class="p">(</span><span class="n">tmp_size</span><span class="p">);</span>
    <span class="n">insert_block</span><span class="p">(</span><span class="n">p_b2</span><span class="p">,</span> <span class="n">p_tlsf_pool</span><span class="p">,</span> <span class="n">split_fl</span><span class="p">,</span> <span class="n">split_sl</span><span class="p">);</span>
  
    <span class="c1">// p_b2の設定が終わったら、p_bのサイズを更新する。
</span><span class="c1"></span><span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="n">p_nb</span><span class="o">-&gt;</span><span class="n">set_prev_freed</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>最後に、<code>tmp_size := p_b-&gt;block_size - mem_size</code>を計算し、確保されたメモリの量に対して新しい空きブロックが作れたら作るようにします。空きブロックが作られたら、<code>insert_block()</code>関数でTLSF構造体の空きブロック管理マトリックスに入れるようにします。</p>

<h3 id="insert-block"><code>insert_block()</code></h3>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">free_ptr_t</span><span class="o">*</span> <span class="n">p_free_ptr</span> <span class="o">=</span> <span class="n">p_b</span><span class="o">-&gt;</span><span class="n">get_free_ptrs</span><span class="p">();</span>
<span class="n">p_free_ptr</span><span class="o">-&gt;</span><span class="n">p_prev</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="n">p_free_ptr</span><span class="o">-&gt;</span><span class="n">p_next</span> <span class="o">=</span> <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">mp_matrix</span><span class="p">[</span><span class="n">final_fl</span><span class="p">][</span><span class="n">final_sl</span><span class="p">];</span>

<span class="k">if</span> <span class="p">(</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">mp_matrix</span><span class="p">[</span><span class="n">final_fl</span><span class="p">][</span><span class="n">final_sl</span><span class="p">])</span>
<span class="p">{</span>
    <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">mp_matrix</span><span class="p">[</span><span class="n">final_fl</span><span class="p">][</span><span class="n">final_sl</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">get_free_ptrs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">p_prev</span><span class="o">=</span> <span class="n">p_b</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">mp_matrix</span><span class="p">[</span><span class="n">final_fl</span><span class="p">][</span><span class="n">final_sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_b</span><span class="p">;</span>
</code></pre></div>
<p>空きブロック<code>p_b</code>を空きブロック管理マトリックスに入れます。ただし、指定されたインデックスにはすでに空きブロックがあるかもしれません。そのときにはリンクリストで２つを繋ぐようにします。こうすることで、<code>extract_block_hdr</code>などで接近した複数のブロックが一つずつ抜かれて使えるようになります。</p>

<hr />

<p>最後に、取得出来た空きブロック<code>p_b</code>の設定をし、リターン値として返せば終わります。</p>

<h2 id="3-tlsf-realloc">3.<code>tlsf_realloc</code></h2>

<p>TLSFの<code>realloc</code>アルゴリズムは３つの分岐に分かれます。</p>

<ol>
<li>再確保するサイズが既存のサイズより小さく、使ってるブロックが使い回せる場合</li>
<li>確保するサイズは既存より大きいが、隣接する次のブロックを使って確保できる場合</li>
<li>１も２も当てはまらなく、<code>malloc</code>をして完全に新しいブロックを確保する場合</li>
</ol>

<h3 id="1-サイズが既存のサイズより小さい時">1. サイズが既存のサイズより小さい時</h3>

<p>まず、サイズが小さくて隣接したブロックが空きブロックの場合には、その空きブロックと今の余りのメモリバッファを合わせて大きい空きブロックが作れるかを判断することが出来ます。以下のロジックではそれを判断し、満足したら併合するようにしています。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="n">p_next_bhdr</span><span class="o">-&gt;</span><span class="n">is_freed</span><span class="p">())</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">next_fl</span><span class="p">,</span> <span class="n">next_sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping_insert</span><span class="p">(</span><span class="n">p_next_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">());</span>
    <span class="n">extract_block</span><span class="p">(</span><span class="n">p_next_bhdr</span><span class="p">,</span> <span class="n">p_tlsf</span><span class="p">,</span> <span class="n">next_fl</span><span class="p">,</span> <span class="n">next_sl</span><span class="p">);</span>

    <span class="n">old_size</span> <span class="o">+=</span> <span class="n">p_next_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size_with_header</span><span class="p">();</span>
    <span class="n">p_next_bhdr</span> <span class="o">=</span> <span class="n">p_next_bhdr</span><span class="o">-&gt;</span><span class="n">get_next_block</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="n">new_free_size</span> <span class="o">=</span> <span class="n">old_size</span> <span class="o">-</span> <span class="n">new_size</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">new_free_size</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">block_header_t</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">new_free_size</span> <span class="o">-=</span> <span class="n">block_header_t</span><span class="o">::</span><span class="n">sk_block_header_ovhd</span><span class="p">;</span>
    <span class="k">auto</span><span class="o">*</span> <span class="n">p_new_bhdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_header_t</span><span class="o">*</span><span class="p">)((</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_buffer</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_size</span><span class="p">);</span>
    <span class="c1">// p_new_bhdrの設定
</span><span class="c1"></span>    <span class="c1">// p_next_next_bhdr (既存p_next_bhdrの次ブロック)をp_newに連結
</span><span class="c1"></span>　　 <span class="c1">// p_new_bhdrをマトリックスに挿入
</span><span class="c1"></span>    <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">new_fl</span><span class="p">,</span> <span class="n">new_sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping_insert</span><span class="p">(</span><span class="n">new_free_size</span><span class="p">);</span>
    <span class="n">insert_block</span><span class="p">(</span><span class="n">p_new_bhdr</span><span class="p">,</span> <span class="n">p_tlsf</span><span class="p">,</span> <span class="n">new_fl</span><span class="p">,</span> <span class="n">new_sl</span><span class="p">);</span>
    <span class="c1">// 最後にp_bの情報を更新
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>
<h3 id="extract-block"><code>extract_block()</code></h3>

<p>この関数は<code>extract_block_hdr()</code>に似ていますが、自分の前後ブロックを連結させて、空きブロックマトリックスから自分を抜いて参照させないようにしています。ただし、マトリックスリストに先頭に見えないとマトリックスでの削除はされません。</p>

<p>なぜ先頭に出てからこそ削除できるかはわからないですが、多分マトリックスに接近する時に必要となるFirst-IndexとSecond-Indexが前後同じになるから、わざとリンクリストを一通り回って削除するかを判断しなくても済ませるのではないかと思ってます。（間違ってるかもしれません）</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="n">p_free_ptr</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">p_free_ptr</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="o">-&gt;</span><span class="n">get_free_ptrs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">p_prev</span> <span class="o">=</span> <span class="n">p_free_ptr</span><span class="o">-&gt;</span><span class="n">p_prev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">p_free_ptr</span><span class="o">-&gt;</span><span class="n">p_prev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">p_free_ptr</span><span class="o">-&gt;</span><span class="n">p_prev</span><span class="o">-&gt;</span><span class="n">get_free_ptrs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">p_next</span> <span class="o">=</span> <span class="n">p_free_ptr</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="k">auto</span><span class="o">*</span> <span class="n">p_matrix_b</span> <span class="o">=</span> <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">mp_matrix</span><span class="p">[</span><span class="n">final_fl</span><span class="p">][</span><span class="n">final_sl</span><span class="p">];</span> <span class="n">p_matrix_b</span> <span class="o">==</span> <span class="n">p_b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">p_matrix_b</span> <span class="o">=</span> <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">mp_matrix</span><span class="p">[</span><span class="n">final_fl</span><span class="p">][</span><span class="n">final_sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_free_ptr</span><span class="o">-&gt;</span><span class="n">p_next</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_matrix_b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">clear_bit</span><span class="p">(</span><span class="n">final_sl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_sl_bitmap</span><span class="p">[</span><span class="n">final_fl</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_sl_bitmap</span><span class="p">[</span><span class="n">final_fl</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">clear_bit</span><span class="p">(</span><span class="n">final_fl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_fl_bitmap</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<hr />

<h3 id="2-サイズが既存より大きいが-隣接空きブロックで解決できる場合">2. サイズが既存より大きいが、隣接空きブロックで解決できる場合</h3>

<p>隣接した空きブロックをくっつけることでサイズの問題が解決できれば、空きブロックをマトリックスから抜いてくっつけて、そして余ったメモリ空間を新しい空きブロックとして作ります。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">+</span> <span class="n">p_next_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">()))</span>
<span class="p">{</span>
    <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_used_mem</span> <span class="o">-=</span> <span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size_with_header</span><span class="p">();</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">next_fl</span><span class="p">,</span> <span class="n">next_sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping_insert</span><span class="p">(</span><span class="n">p_next_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">());</span>
    <span class="n">extract_block</span><span class="p">(</span><span class="n">p_next_bhdr</span><span class="p">,</span> <span class="n">p_tlsf</span><span class="p">,</span> <span class="n">next_fl</span><span class="p">,</span> <span class="n">next_sl</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="n">p_next_bhdr</span> <span class="o">=</span> <span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_next_block</span><span class="p">();</span>
    <span class="c1">// ...
</span><span class="c1"></span>
    <span class="n">u64</span> <span class="n">new_free_size</span> <span class="o">=</span> <span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">()</span> <span class="o">-</span> <span class="n">new_size</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">new_free_size</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">block_header_t</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">new_free_size</span> <span class="o">-=</span> <span class="n">block_header_t</span><span class="o">::</span><span class="n">sk_block_header_ovhd</span><span class="p">;</span>
        <span class="k">auto</span><span class="o">*</span> <span class="n">p_new_bhdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_header_t</span><span class="o">*</span><span class="p">)((</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_buffer</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_size</span><span class="p">);</span>
        <span class="c1">// ...
</span><span class="c1"></span>        <span class="c1">// ...
</span><span class="c1"></span>
        <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">new_fl</span><span class="p">,</span> <span class="n">new_sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping_insert</span><span class="p">(</span><span class="n">new_free_size</span><span class="p">);</span>
        <span class="n">insert_block</span><span class="p">(</span><span class="n">p_new_bhdr</span><span class="p">,</span> <span class="n">p_tlsf</span><span class="p">,</span> <span class="n">new_fl</span><span class="p">,</span> <span class="n">new_sl</span><span class="p">);</span>
        <span class="c1">// ...
</span><span class="c1"></span>    <span class="p">}</span>
  
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">p_data</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="3-mallocで新しいブロックを探すしかない場合">3. mallocで新しいブロックを探すしかない場合</h3>

<p>どうしようもないので<code>malloc</code>で新しいブロックを探します。探すことが出来たら、<code>memcpy</code>で既存のブロックの内容を新しいブロックにコピーします。ただし、この場合だとPODでしかちゃんとコピーが出来ないのでC++のクラスの情報が入ったブロックをコピーしたい場合には特殊なロジックが要るかもしれません。</p>

<p>最後には既存のブロックを<code>free</code>します。（<code>tlsf_free()</code>）</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// Otherwise, we need to find another free-block.
</span><span class="c1"></span><span class="n">block_buffer_t</span><span class="o">*</span> <span class="n">p_new_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_buffer_t</span><span class="o">*</span><span class="p">)</span><span class="n">tlsf_malloc</span><span class="p">(</span><span class="n">new_size</span><span class="p">,</span> <span class="n">p_tlsf</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_new_buffer</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>

<span class="k">const</span> <span class="n">u64</span> <span class="n">copy_size</span> <span class="o">=</span> <span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">new_size</span> 
    <span class="o">?</span> <span class="nl">new_size</span> 
    <span class="p">:</span> <span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">();</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">p_new_buffer</span><span class="p">,</span> <span class="n">p_buffer</span><span class="p">,</span> <span class="n">copy_size</span><span class="p">);</span>
<span class="n">tlsf_free</span><span class="p">(</span><span class="n">p_buffer</span><span class="p">,</span> <span class="n">p_tlsf</span><span class="p">);</span>
</code></pre></div>
<h2 id="4-tlsf-free">4.<code>tlsf_free()</code></h2>

<p>確保したメモリブロックを解除したい場合にはこの関数を使います。（ただし、PODタイプのみ）<br>しかしメモリ解除をする時に、今解除するメモリブロックに隣接したブロックが空き（フリー）かを確認し、空きだったら併合して一つのブロックに纏めさせることも出来ます。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// 消す前に次のブロックがFreeなのかを確認する。
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_temp_bhdr</span> <span class="o">=</span> <span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_next_block</span><span class="p">();</span>
    <span class="n">p_temp_bhdr</span><span class="o">-&gt;</span><span class="n">is_freed</span><span class="p">())</span>
<span class="p">{</span>   <span class="c1">// 併合
</span><span class="c1"></span>    <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">fl</span><span class="p">,</span> <span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping_insert</span><span class="p">(</span><span class="n">p_temp_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">());</span>
    <span class="n">extract_block</span><span class="p">(</span><span class="n">p_temp_bhdr</span><span class="p">,</span> <span class="n">p_tlsf_pool</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">sl</span><span class="p">);</span>
    <span class="c1">// 後処理
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 消す前に前のブロックがFreeなのかを確認する。
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">is_prev_freed</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">block_header_t</span><span class="o">*</span> <span class="n">p_prev_bhdr</span> <span class="o">=</span> <span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_prev_bhdr</span><span class="p">();</span>
    <span class="c1">// 併合
</span><span class="c1"></span>    <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">fl</span><span class="p">,</span> <span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping_insert</span><span class="p">(</span><span class="n">p_prev_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">());</span>
    <span class="n">extract_block</span><span class="p">(</span><span class="n">p_prev_bhdr</span><span class="p">,</span> <span class="n">p_tlsf_pool</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">sl</span><span class="p">);</span>
    <span class="c1">// 後処理
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>
<p>最後に空いたブロックを空きブロック管理マトリックスに入れます。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// Final mapping insert.
</span><span class="c1"></span><span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">fl</span><span class="p">,</span> <span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping_insert</span><span class="p">(</span><span class="n">p_bhdr</span><span class="o">-&gt;</span><span class="n">get_block_size</span><span class="p">());</span>
<span class="n">insert_block</span><span class="p">(</span><span class="n">p_bhdr</span><span class="p">,</span> <span class="n">p_tlsf_pool</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">sl</span><span class="p">);</span>
</code></pre></div>
<h2 id="5-tlsf-raw-destroy">5.<code>tlsf_raw_destroy</code></h2>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">tlsf_raw_t</span><span class="o">*</span> <span class="n">p_tlsf</span> <span class="o">=</span> <span class="p">(</span><span class="n">tlsf_raw_t</span><span class="o">*</span><span class="p">)</span><span class="n">p_pool</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">has_signature</span><span class="p">())</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">p_tlsf</span><span class="o">-&gt;</span><span class="n">m_used_mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div>
<p>TLSF構造体のシグニチャーを無効化します。それだけです。</p>

<h1 id="改善点">改善点</h1>

<h3 id="ビットシフトアルゴリズムがまだ完全に理解できてない">・ビットシフトアルゴリズムがまだ完全に理解できてない</h3>

<p>First-IndexとSecond-Indexの数値をビットマップ変数に更新するためのアルゴリズムが完全には理解できませんでした。テストケースを作って、どのようにフラグ値が変わるのかを詳しく調べてみたいですね。</p>

<h3 id="まだscalableではない">・まだScalableではない</h3>

<p>TLSFの特徴の一つである、メモリプールをくっつけて更に多くのメモリが確保出来るようにするための機能がまだ実装してませんでした。次の記事を書くときには今抜かれた機能まで付けて、それの説明までしたいです。</p>

<h1 id="まとめ">まとめ</h1>

<p>最後までがんばります。（適当）</p>
]]></content>
		</item>
		
		<item>
			<title>行列変数のネーミングについて</title>
			<link>https://liliilli.github.io/posts/matrix_name/</link>
			<pubDate>Fri, 13 Mar 2020 13:11:47 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/matrix_name/</guid>
			<description>https://www.sebastiansylvan.com/post/matrix_naming_convention/ D3Dスタイル（Row-Major、左から右へ演算していくスタイル）でやると、 vector4_t transformed_point = point * M * A; が普通だけど、このままじゃ後でまた見る時に何</description>
			<content type="html"><![CDATA[<p><a href="https://www.sebastiansylvan.com/post/matrix_naming_convention/">https://www.sebastiansylvan.com/post/matrix_naming_convention/</a></p>

<p>D3Dスタイル（Row-Major、左から右へ演算していくスタイル）でやると、</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">vector4_t</span> <span class="n">transformed_point</span> <span class="o">=</span> <span class="n">point</span> <span class="o">*</span> <span class="n">M</span> <span class="o">*</span> <span class="n">A</span><span class="p">;</span>
</code></pre></div>
<p>が普通だけど、このままじゃ後でまた見る時に何をしているかが分からないかもしれない。</p>

<p>なので、お勧めしている変数名の書き方としては、<code>foo_to_bar</code>または<code>bar_from_too</code>（これはOpenGLかVulkan系列）みたいに座標空間から別の座標空間の名前を書くのが良いらしい。例えば、<code>world_to_view</code>または<code>view_to_projection</code>みたいな…<code>transform_matrix</code>のような名前よりは全然意味がわかるようになってる。</p>

<p>ということで、お勧めした変数ネーミングスタイルで例を書いてみると、</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">const</span> <span class="n">matrix4_t</span> <span class="n">object_to_view</span> <span class="o">=</span> <span class="n">object_to_world</span> <span class="o">*</span> <span class="n">world_to_view</span><span class="p">;</span>
<span class="k">const</span> <span class="n">matrix4_t</span> <span class="n">object_to_proj</span> <span class="o">=</span> <span class="n">object_to_view</span> <span class="o">*</span> <span class="n">view_to_proj</span><span class="p">;</span>

<span class="k">const</span> <span class="n">vector4_t</span> <span class="n">point_in_proj</span> <span class="o">=</span> <span class="n">point</span> <span class="o">*</span> <span class="n">object_to_proj</span><span class="p">;</span>
</code></pre></div>
<p>逆行列の場合には、単純に前の座標空間と後ろの座標空間の名前を書き換えることだけ。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">const</span> <span class="n">matrix4_t</span> <span class="n">view_to_object</span> <span class="o">=</span> <span class="p">(</span><span class="n">object_to_world</span> <span class="o">*</span> <span class="n">world_to_view</span><span class="p">).</span><span class="n">to_inverse</span><span class="p">();</span>

<span class="k">const</span> <span class="n">matrix4_t</span> <span class="n">head_to_right_hand</span> <span class="o">=</span> <span class="n">rigth_hand_to_head</span><span class="p">.</span><span class="n">to_inverse</span><span class="p">();</span>
<span class="k">const</span> <span class="n">matrix4_t</span> <span class="n">object_to_right_hand</span> <span class="o">=</span> 
    <span class="n">object_to_world</span> <span class="o">*</span> <span class="n">world_to_head</span> <span class="o">*</span> <span class="n">head_to_right_hand</span><span class="p">;</span>
</code></pre></div>
<p>OpenGLでは、<code>to</code>の代わりに<code>from</code>を使い、そして演算の手順に沿って逆に書く。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">const</span> <span class="n">matrix4_t</span> <span class="n">proj_from_object</span> <span class="o">=</span> 
    <span class="n">proj_from_view</span> <span class="o">*</span> <span class="n">view_from_world</span> <span class="o">*</span> <span class="n">world_from_object</span><span class="p">;</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>自分でやるDyのCMakeListsファイル説明</title>
			<link>https://liliilli.github.io/posts/dy_cmake/</link>
			<pubDate>Sun, 08 Mar 2020 11:48:19 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/dy_cmake/</guid>
			<description>はじめに 自分の個人プロジェクトのDyという、ゲームエンジンプロジェクトがあって、たまに時間がある時開発をしています。ですけど今は表じゃなく裏</description>
			<content type="html"><![CDATA[

<h1 id="はじめに">はじめに</h1>

<p>自分の個人プロジェクトの<code>Dy</code>という、ゲームエンジンプロジェクトがあって、たまに時間がある時開発をしています。ですけど今は表じゃなく裏で色々と構造上の問題の修正とか、会社で勉強になったところを適用しつつ<code>git</code>を使用せずにこっそりとやったのです。（伏線）</p>

<p>ところで、何日前に酔っ払って家に帰ってきてから開発をしようとしたけど、無闇に<code>CMakeLists.txt</code>ファイルを消してしまいました。やべぇと思いながら削除したファイルを戻そうとしましたが、VS自体で削除したせいで戻せませんでした。当然ビルドも通らなくなりました。</p>

<p>ということで結局書き直さざるを得ませんでしたが、最後に<code>CMakeLists.txt</code>を書いてから半年も過ぎているんでどう書けばいいか全然思いつきませんでした。結局最初からやり直す気持ちで<code>cmake</code>のメモ記事を書いて勉強し、なんとか書き直したんです。</p>

<p>ここからは真下の全文を最初から読み通して、リマインド用としてどんな要素を使ってコードを書いたかを説明したいと思います。</p>

<h1 id="説明">説明</h1>

<h2 id="function-find-platform">・function(_find_platform)</h2>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">function</span><span class="p">(</span><span class="s">_find_platform</span> <span class="s">IVerbose</span> <span class="s">OPlatform</span><span class="p">)</span></code></pre></div>
<blockquote>
<p><a href="https://cmake.org/cmake/help/v3.14/manual/cmake.1.html#build-tool-mode">https://cmake.org/cmake/help/v3.14/manual/cmake.1.html#build-tool-mode</a><br>
<a href="https://cmake.org/cmake/help/v3.14/envvar/VERBOSE.html">https://cmake.org/cmake/help/v3.14/envvar/VERBOSE.html</a></p>
</blockquote>

<p><code>_find_platform</code>という名前をもつ関数です。<code>IVerbose</code>では変数または<code>VERBOSE</code>が入ります。<code>VERBOSE</code>はcmakeで設定ファイルを作るとき、コマンド引数で<code>-v --verbose</code>を入れることで<code>true</code>になるらしいです。</p>

<p>それで<code>IVerbose</code>が<code>true</code>であれば、変数とかログを出力しようとしてます。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">if</span> <span class="p">(</span><span class="s">IVerbose</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">CMAKE_HOST_SYSTEM_NAME</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<blockquote>
<p><a href="https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_SYSTEM_NAME.html">https://cmake.org/cmake/help/latest/variable/CMAKE_HOST_SYSTEM_NAME.html</a></p>
</blockquote>

<p><code>CMAKE_HOST_SYSTEM_NAME</code>は今使っているOSの名前を返します。リナックス、ウィンドウズ、マックの場合には<code>Linux</code>、<code>Windows</code>、<code>Darwin</code>を返します。それじゃないOSの場合には<code>uname -s</code>で返される文字列を持つようです。</p>

<p>文字列を<code>OPlatform</code>変数に入れときます。関数から外側からの変数引数に値を更新する場合には<code>PARENT_SCOPE</code>を使います。もし、どの分岐にも当たらなかったら変数の値は未定です。（<code>-NOTFOUND</code>かもしれませんね）</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OPlatform</span><span class="o">}</span> <span class="s2">&#34;WIN&#34;</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span></code></pre></div>
<h2 id="function-check-supported-platform-iplatformkey-oissupported">・function(_check_supported_platform IPlatformKey OIsSupported)</h2>

<p><code>function(_find_platform)</code>から取得したキーを検証し、ビルドできるプラットフォームなのかを確認してくれます。まず、<code>if</code>で<code>IPlatformKey</code>変数を検証する時には以下のようにします。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">if</span> <span class="p">(</span><span class="s2">&#34;${IPlatformKey}&#34;</span> <span class="s">STREQUAL</span> <span class="s2">&#34;WIN&#34;</span><span class="p">)</span></code></pre></div>
<p><code>&quot;&quot;</code>を抜いて書いてもいいと思いますが、一応安全策として。<code>${}</code>はできるなら必須だと思います。単純に<code>IPlatformKey</code>で書いちゃうよりはマシ…だと思います。ただし、<code>${}</code>つけられるのはcmake 3.0バージョンから出来るらしいです。</p>

<p>関数は別の言語のように早めにリターンすることも出来ます。<code>return()</code>を使いましょう。</p>

<h2 id="function-is-windows-obool">・function(_is_windows OBool)</h2>

<p>プラットフォームがウィンドウズかを確認してくれます。中身は単純に<code>_find_platform</code>関数の呼び出しとウィンドウズなのかを検証する分岐を書いたことに過ぎません。</p>

<h2 id="function-find-winsdk-iverbose-odir-olibdir-oincdir">・function(_find_winsdk IVerbose &hellip; ODir OLibDir OIncDir)</h2>

<blockquote>
<p><a href="https://github.com/rpavlik/cmake-modules/blob/master/FindWindowsSDK.cmake">https://github.com/rpavlik/cmake-modules/blob/master/FindWindowsSDK.cmake</a></p>
</blockquote>

<p>今使っているOSのがウィンドウズかを確認し、ウィンドウズなら一番最新のSDKのルートパス、Includeパス、そしてライブラリーディレクトリのパスを返します。ここでは<code>FindWindowsSDK</code>というモジュールを使って、いちいち手作業でSDKのパス情報などを取得するようにしなくても提供された関数を呼び、変数を参照するだけで情報が取得できるようにしてくれます。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">include</span><span class="p">(</span><span class="s">FindWindowsSDK</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="c"># ... DO SOMETHING
</span><span class="c"></span><span class="nb">get_windowssdk_library_dirs</span><span class="p">(</span><span class="o">${</span><span class="nv">_in_ODir</span><span class="o">}</span> <span class="s">_in_OLibDir</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">get_windowssdk_include_dirs</span><span class="p">(</span><span class="o">${</span><span class="nv">_in_ODir</span><span class="o">}</span> <span class="s">_in_OIncDir</span><span class="p">)</span></code></pre></div>
<h2 id="macro-dy-setup-build-settings">・macro(dy_setup_build_settings)</h2>

<p>基本的なビルド設定を書いてくれます。ソースファイルの取得、IncludeとかInlineフォルダーの検知、C++バージョンの設定、属性（Property）の設定とビルドオプションを付けること等をやってくれます。</p>

<p>関数とは違ってマクロなため、各種要素のスコープ管理処理が若干ややこしくなります。</p>

<h3 id="cmake-build-type">CMAKE_BUILD_TYPE</h3>

<blockquote>
<p><a href="https://cmake.org/cmake/help/v3.0/variable/CMAKE_BUILD_TYPE.html">https://cmake.org/cmake/help/v3.0/variable/CMAKE_BUILD_TYPE.html</a></p>
</blockquote>

<p>プロジェクト全般のビルドタイプの文字列を持ちます。例えば、デバッグモードでビルドする時には<code>Debug</code>または<code>DEBUG</code>を、リリースモードでやる時には<code>Release</code>とか<code>RELEASE</code>という文字列を持ちます。（環境によって異なる可能性もあります。）</p>

<p>そしてこの文字列は<code>CMAKE_CXX_FLAGS_&lt;CONFIG&gt;</code>の<code>&lt;CONFIG&gt;</code>にも影響を及ぶそうです。ビルドモードによって<code>CMAKE_CXX_FLAGS_Debug</code>、<code>_Release</code>になれるらしいです。僕の書いたコードではこの<code>&lt;CONFIG&gt;</code>を後で見る*Generator Expression*を制御する時に使います。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;${PROJECT_NAME} is built with ${CMAKE_BUILD_TYPE} mode.&#34;</span><span class="p">)</span></code></pre></div>
<h3 id="cc-ファイルリストの取得-フィルタリング"><code>.cc</code>ファイルリストの取得、フィルタリング</h3>

<p>以前の<code>CMakeLists.txt</code>ファイルでは、各プロジェクトごとに一々ソースファイルを登録しなければなりませんでした。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">target_sources</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
<span class="s">PRIVATE</span>
	<span class="s">XTFVector.cc</span>
	<span class="s">XString.cc</span>
	<span class="s">XFMemPool.cc</span>
	<span class="c"># などなど...
</span><span class="c"></span>	<span class="s">Utility/test_bit_operation.cc</span>
<span class="p">)</span></code></pre></div>
<p>ですが、今新しく設定ファイルを書く時には一々ファイルのパスを書く手間をなくすよう、<code>Src</code>フォルダーから子フォルダーの中に入っているファイルを検索して、<code>cpp</code>ソースファイルを自動に取得するようにしてくれるようにしました。</p>

<blockquote>
<p><a href="https://cmake.org/cmake/help/v3.14/command/file.html">https://cmake.org/cmake/help/v3.14/command/file.html</a><br><a href="https://cmake.org/cmake/help/v3.14/command/file.html#filesystem">https://cmake.org/cmake/help/v3.14/command/file.html#filesystem</a></p>
</blockquote>

<p><code>file()</code>はファイルシステムのファイルまたはディレクトリに接近するときに使うコマンドです。ここでフォルダーの中のファイルを全部取得するために<code>GLOB_RECURSE</code>を使います。<code>file()</code>コマンド構文の最後に出るのが<code>${CMAKE_CURRENT_SOURCE_DIR}/Src</code>フォルダーから特定ファイルを探すための表現式となります。下の場合にはすべての<code>.cc</code>ファイルのパスを探して、<code>${PROJECT_NAME}_InGetSrcs</code>変数に値を更新します。ただし<code>RELATIVE</code>があるため、絶対パスじゃなく相対パスとなります。</p>

<p>cmake 3.12バージョンからは<code>CONFIGURE_DEPENDS</code>が追加されたため、追加しときました。そもそもソースファイルを取得するために<code>GLOB</code>系列を使うのはおすすめしない方法です。なぜならこのソースファイルリストはファイルを追加するか削除するたびに更新してくれず、あくまでcmakeのキャッシュなどを再設定（Reconfiguration）する時だけ更新するからです。</p>

<p>なので<code>CONFIGURE_DEPENDS</code>を追加することで、一応ビルドタイムでもソースファイルリストを更新する必要があるかをチェックし、<code>GLOB</code>コマンドを再度回してくれるようになります。ですが、ソースファイルの量が多くなると以前よりは時間がかかるかもしれません。</p>

<p>リストを取得する名前もちょっと変わってます。変数のスコープが全域になるかもしれないので、接頭詞としてプロジェクトの名前を付けた変数を使ってます。例えば、プロジェクトの名前が<code>HogeFuga</code>だとしたら、変数の名前は<code>HogeFuga_InGetSrcs</code>になります。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="s">_InGetSrcs</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">file</span><span class="p">(</span>
	<span class="s">GLOB_RECURSE</span> <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="s">_InGetSrcs</span>
	<span class="s">RELATIVE</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/Src&#34;</span>
	<span class="s">CONFIGURE_DEPENDS</span> <span class="s">*.cc</span>
<span class="p">)</span></code></pre></div>
<p>ソースファイルのリストを取得してターゲット（プロジェクト）に追加する前に、<code>_xxxx.cc</code>みたいに接頭詞<code>_</code>が付いたファイルは除外する必要があります。なぜなら上のコードではビルドする必要がないソースファイルまで取得してしまうからです。</p>

<blockquote>
<p><a href="https://cmake.org/cmake/help/latest/command/string.html#regex-specification">https://cmake.org/cmake/help/latest/command/string.html#regex-specification</a><br><a href="https://cmake.org/cmake/help/latest/command/foreach.html">https://cmake.org/cmake/help/latest/command/foreach.html</a></p>
</blockquote>

<p>ここでビルドしないソースファイルをフィルタリングするため、正規表現パターンを使います。ただ、一般正規表現エンジンみたいに複雑な表現をマッチングさせることは出来ないみたいです。使える正規表現は上のURLで見れます。</p>

<p>とにかく複数の値を持つ変数を巡回させるには<code>foreach()</code>と<code>endforeach()</code>を使います。<code>SrcItem</code>は<code>${PROJECT_NAME}_InGetSrcs</code>の持っている複数の値を一個ずつ持ち、中身で何らかのロジックを行います。また、ループ文の中で次のループに移りたい場合には<code>continue()</code>を使います。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">foreach</span><span class="p">(</span><span class="s">SrcItem</span> <span class="o">${</span><span class="nv">${PROJECT_NAME</span><span class="o">}</span><span class="s">_InGetSrcs}</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">if</span> <span class="p">(</span><span class="s2">&#34;Src/${SrcItem}&#34;</span> <span class="s">MATCHES</span> <span class="s2">&#34;/_+[a-zA-Z0-9_ -]*.cc$&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">continue</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>		<span class="nb">target_sources</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PRIVATE</span> <span class="s2">&#34;Src/${SrcItem}&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nb">endforeach</span><span class="p">()</span></code></pre></div>
<h3 id="inc-inlフォルダーの確認-取得">Inc、Inlフォルダーの確認・取得</h3>

<blockquote>
<p><a href="https://cmake.org/cmake/help/latest/command/if.html#condition-syntax">https://cmake.org/cmake/help/latest/command/if.html#condition-syntax</a></p>
</blockquote>

<p>ディレクトリまたはファイルがあるかを確認するには、<code>if (EXISTS &lt;path&gt;)</code>を使います。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">if</span> <span class="p">(</span><span class="s">EXISTS</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/Inc&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">target_include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s">Inc</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nb">if</span> <span class="p">(</span><span class="s">EXISTS</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/Inl&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">target_include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s">Inl</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<h3 id="windows専用include-ライブラリー追加">Windows専用Include・ライブラリー追加</h3>

<p>cmakeを使っているOSがWindowsならば、Windowsから提供している昨日などを使うためにIncludeとLibraryのパスを指定する必要があります。なので追加でSDKのインクルードパスとライブラリーパスを指定するようしてます。</p>

<p>ですが、今はライブラリーパスのみターゲットへ反映するようにしています。インクルードはやっちゃうとWarningエラーがめちゃくちゃ出てるせいでコメント化してます。多分Clang-ClまたはMSVCは自動でSDKのパスをインクルードかけてくれるみたいです。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake">	<span class="c"># It seems it have not to be inserted into all project when WIN.
</span><span class="c"></span>	<span class="c"># target_include_directories(${PROJECT_NAME} PRIVATE ${WinInc})
</span><span class="c"></span>	<span class="nb">target_link_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PRIVATE</span> <span class="o">${</span><span class="nv">WinLib</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="err">
</span><span class="err"></span>	<span class="nb">target_compile_definitions</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> 
	<span class="s">PRIVATE</span> 
		<span class="s2">&#34;UNICODE&#34;</span> 
		<span class="s2">&#34;_UNICODE&#34;</span>
		<span class="s2">&#34;_CRT_SECURE_NO_WARNINGS&#34;</span>
	<span class="p">)</span></code></pre></div>
<p>ちなみに僕のプロジェクトではマルチバイト文字ではなく、ユニコード文字を使います。</p>

<h3 id="propertyの適用">Propertyの適用</h3>

<blockquote>
<p><a href="https://cmake.org/cmake/help/latest/command/set_target_properties.html">https://cmake.org/cmake/help/latest/command/set_target_properties.html</a><br><a href="https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html#target-properties">https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html#target-properties</a></p>
</blockquote>

<p>ターゲットプロジェクトに属性（Property）を適用するためには、<code>set_target_properties</code>を使います。このコマンドが出来る前までは、<code>CXX_...</code>で始まる全域変数を使って、全てのプロジェクトに同一な属性をつけるしかなかったそうですが、バージョン3.0からは<code>..._target_...</code>みたいなコマンドで個別ターゲットを制御するようになったそうです。</p>

<p>とにかく、ターゲットの属性をつけるには<code>PROPERTIES</code>の後から属性を付けます。下のコードでは<code>CXX_STANDARD</code>という、Cppのバージョンを付けませんでしたが、それは後でコマンドラインまたは別個のプロジェクトCMakeLists.txtでつけるようになってます。もし何も指定されなかった場合にはC++17を自動に付けてあげます。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">set_target_properties</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
	<span class="s">PROPERTIES</span>
	<span class="s">LINKER_LANGUAGE</span> <span class="s">CXX</span>
	<span class="s">CXX_STANDARD_REQUIRED</span> <span class="s">ON</span>
	<span class="s">CXX_EXTENSIONS</span> <span class="s">ON</span>
	<span class="s">ARCHIVE_OUTPUT_DIRECTORY</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/lib/${CMAKE_BUILD_TYPE}&#34;</span>
	<span class="s">LIBRARY_OUTPUT_DIRECTORY</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/lib/${CMAKE_BUILD_TYPE}&#34;</span>
	<span class="s">RUNTIME_OUTPUT_DIRECTORY</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/bin/${CMAKE_BUILD_TYPE}&#34;</span>
<span class="p">)</span></code></pre></div>
<h3 id="コンパイルオプション">コンパイルオプション</h3>

<p>最後にプロジェクトをビルドする時のフラグを入れます。ただし、コンパイラごとにフラグに入れ方が違うため、<code>CMAKE_CXX_COMPILER_ID</code>全域変数を参照してコンパイラごとのフラグを入れる分岐を作ります。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">if</span> <span class="p">((</span>	<span class="c"># MSVC or Clang-Cl (Simulated MSVC on Clang)
</span><span class="c"></span>			<span class="o">${</span><span class="nv">CMAKE_CXX_COMPILER_ID</span><span class="o">}</span> <span class="s">STREQUAL</span> <span class="s2">&#34;Clang&#34;</span> 
			<span class="s">AND</span> <span class="s2">&#34;x${CMAKE_CXX_SIMULATE_ID}&#34;</span> <span class="s">STREQUAL</span> <span class="s2">&#34;xMSVC&#34;</span>
		<span class="p">)</span> 
		<span class="s">OR</span> <span class="o">${</span><span class="nv">CMAKE_CXX_COMPILER_ID</span><span class="o">}</span> <span class="s">STREQUAL</span> <span class="s2">&#34;MSVC&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="c"># Clang-Cl, MSVC Flags
</span><span class="c"></span><span class="nb">elseif</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_CXX_COMPILER_ID</span><span class="o">}</span> <span class="s">STREQUAL</span> <span class="s2">&#34;Clang&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="c"># Clang Flags
</span><span class="c"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="nb">message</span><span class="p">(</span><span class="s">FATAL_ERROR</span> <span class="s2">&#34;This project only supports Clang/Clang-cl or MSVC compiler now.&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<p>ここで注意すべきところは、WindowsのVS（Visual Studio）でcmakeを使い、そしてVSから提供しているClangコンパイラではなく、自分のclangを取り入れてビルドさせる場合には<code>CMAKE_CXX_SIMULATE_ID</code>も検査する必要があります。（基本提供しているClangコンパイラでも起こりえる可能性はあります。）</p>

<p>なので、<code>Clang-Cl</code>を使ってる時には、</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">if</span> <span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_CXX_COMPILER_ID</span><span class="o">}</span> <span class="s">STREQUAL</span> <span class="s2">&#34;Clang&#34;</span> <span class="s">AND</span> <span class="o">${</span><span class="nv">CMAKE_CXX_SIMULATE_ID</span><span class="o">}</span> <span class="s">STREQUAL</span> <span class="s2">&#34;MSVC&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="c"># DO SOMETHING
</span><span class="c"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<p>で検査します。</p>

<p>コンパイラの検査が通ったら、<code>target_compile_options</code>を使い、フラグを入れます。3.0以前のバージョンでは<code>CXX_FLAGS</code>みたいなものを使ってたそうですが、あのやり方じゃ全体プロジェクトのフラグへ影響がありえます。なので今は<code>target_compile_options</code>を使ってターゲットごとのフラグを設定します。</p>

<p>ちょっと注目すべきところは、<code>generator expression</code>を使ってるとこです。<code>$&lt;$&lt;CONFIG:Debug&gt;:${ComOpts_MsvcDebug}&gt;</code>またはDebugがReleaseにされているのが２つも存在しているのは、上で説明していた<code>&lt;CONFIG&gt;</code>の文字列を見て、ビルドする時にビルドモードによってフラグを洗濯的に入れるためです。</p>

<p>例えば、<code>Debug</code>モードの場合には２つめは無視され、１つ目は<code>ComOpts_MscvDebug</code>変数で指定されたフラグリストがターゲットに入ります。<code>Release</code>モードならば逆です。各フラグ変数はコード一番下で書いています。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;$&lt;$&lt;CONFIG:Debug&gt;:${ComOpts_MsvcDebug}&gt;&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;$&lt;$&lt;CONFIG:Release&gt;:${ComOpts_MsvcRelease}&gt;&#34;</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">ComOpts_MsvcCommon</span> 
	<span class="s">/GR-</span> <span class="s">/W4</span> <span class="s">/WX</span> <span class="s">/MP</span> 
	<span class="s">-Wno-error=unused-command-line-argument</span>
	<span class="s">-Wno-error=expansion-to-defined</span>
	<span class="s">-Wno-error=ignored-pragma-intrinsic</span>
<span class="p">)</span> <span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">ComOpts_MsvcDebug</span> <span class="s">/Od</span> <span class="o">${</span><span class="nv">ComOpts_MsvcCommon</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">ComOpts_MsvcRelease</span> <span class="s">/O2</span> <span class="o">${</span><span class="nv">ComOpts_MsvcCommon</span><span class="o">}</span><span class="p">)</span></code></pre></div>
<h1 id="プロジェクトごとのcmakelists-txt">プロジェクトごとのCMakeLists.txt</h1>

<p>各プロジェクトでは下だけを書くことで終わります。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.12</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">DyCommon</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">STATIC</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">dy_setup_build_settings</span><span class="p">()</span></code></pre></div>
<p>または</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span> <span class="p">(</span><span class="s">VERSION</span> <span class="s">3.12</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">TestD3D12</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">add_dependencies</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">DyCommon</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s">DyCommon</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PROPERTIES</span> <span class="s">CXX_STANDARD</span> <span class="s">20</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">dy_setup_build_settings</span><span class="p">()</span></code></pre></div>
<p>ほとんどは<code>dy_setup_build_settings</code>マクロが設定してくれます。はい、おわり。</p>

<h1 id="反省点">反省点</h1>

<h3 id="unity-buildまたは類似unityの導入">Unity Buildまたは類似Unityの導入？</h3>

<p>今は<code>file(GLOB_RECURSE)</code>でソースファイルをまとめてターゲットにバインディングしているようにしてますが、やるなら<code>file</code>コマンドをより活用して一時のUnityビルドファイルを作り、そこにリストをインクルードするコードをCmake側から書いてUnityファイルだけビルド通るようにすることも良さそうじゃないかな～と思いました。</p>

<p>まず、<code>file(GLOB)</code>自体が設定時にコマンド実行が行うため、設定後で新しいファイルを追加しようとしたら再度設定をし直さなければならないです。生産性も下がりそうだし、ビルドするまでの時間もかかりそうだから、やるならUnityビルドしかけたりする方が良いんじゃね…？とふと思いつきました。</p>

<p>後で試してみて、上手く出来たらコード改良して切り換えたいです。</p>

<h3 id="d3d12ライブラリ導入の制御が足りない">D3D12ライブラリ導入の制御が足りない</h3>

<p>現在のコードでは、WindowsならD3D12も自動に入れるようにしています。ですが、D3D12のライブラリは基本的にはWindows10以上のみ対応しているらしく、以前のWindowsOSでは当然ビルドエラーが出ちゃうか、意図してない挙動になれると思います。</p>

<p>なんで、解決策として<code>option</code>コマンドなどでD3D12を入れるかないかを設定するようにし、OSのプラットフォームを詳しく区別させてWin10ではなければD3D12のインポートを解除するようにしつつ、フラグの<code>true/false</code>によって洗濯的にライブラリを入れるようにコードを修正すれば良いんじゃないかなと思いますね。</p>

<h3 id="add-subdirectoryではなく-importで出来るのでは">add_subdirectoryではなく、IMPORTで出来るのでは？</h3>

<blockquote>
<p><a href="https://www.youtube.com/watch?v=y7ndUhdQuU8">https://www.youtube.com/watch?v=y7ndUhdQuU8</a><br><a href="https://www.youtube.com/watch?v=y9kSr5enrSk">https://www.youtube.com/watch?v=y9kSr5enrSk</a></p>
</blockquote>

<p><code>add_subdirectory</code>ではなく、<code>IMPORT</code>でプロジェクトを関連させたりビルドさせたりすることが出来るらしいけど、詳しくは存じないです。単純に勘違いしたかもしれませんね…</p>

<h3 id="警告メッセージをむりやり抑えてしまった">警告メッセージをむりやり抑えてしまった</h3>

<p>Cmake＋Clang-Clでは<code>/MP</code>（マルチプロセッサで並列ビルドを行う）フラグが通じないみたいです。<code>/W4 /WX</code>まで付けたせいでエラーが出まくって、一応<code>-Wno</code>フラグでなんとか警告として扱うように抑えましたが、ちょっと気に食わないですね。</p>

<h1 id="全文">全文</h1>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.12</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">Dy</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># @brief Find platform key string if found.
</span><span class="c">#	Returned `OPlatform` key string is one of below list when found.
</span><span class="c">#	* WIN : Windows
</span><span class="c">#	* LNX : Linux
</span><span class="c">#	* MAC : MacOS (Darwin)
</span><span class="c">#	If not found, key string will be `-NOTFOUND`.
</span><span class="c">#
</span><span class="c"># @param IVerbose verbosity flag. input value is true / false.
</span><span class="c"># @return_var OPlatform 
</span><span class="c"></span><span class="nb">function</span><span class="p">(</span><span class="s">_find_platform</span> <span class="s">IVerbose</span> <span class="s">OPlatform</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">if</span> <span class="p">(</span><span class="s">IVerbose</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">CMAKE_HOST_SYSTEM_NAME</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="nb">if</span> <span class="p">(</span><span class="s2">&#34;${CMAKE_HOST_SYSTEM_NAME}&#34;</span> <span class="s">STREQUAL</span> <span class="s2">&#34;Windows&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s">IVerbose</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Found Windows.&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OPlatform</span><span class="o">}</span> <span class="s2">&#34;WIN&#34;</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">elseif</span><span class="p">(</span><span class="s2">&#34;${CMAKE_HOST_SYSTEM_NAME}&#34;</span> <span class="s">STREQUAL</span> <span class="s2">&#34;Linux&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s">IVerbose</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Found Linux.&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OPlatform</span><span class="o">}</span> <span class="s2">&#34;LNX&#34;</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">elseif</span><span class="p">(</span><span class="s2">&#34;${CMAKE_HOST_SYSTEM_NAME}&#34;</span> <span class="s">STREQUAL</span> <span class="s2">&#34;Darwin&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s">IVerbose</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Found MacOS.&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OPlatform</span><span class="o">}</span> <span class="s2">&#34;MAC&#34;</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nb">endfunction</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># @brief Check given platform is supported with `IPlatformKey` variable.
</span><span class="c">#	Returned `OIsSupported` key have true or false whether given platform is supported or not.
</span><span class="c">#	* true : Detected platform is suppported.
</span><span class="c">#	* false : Detected platform is not supported yet.
</span><span class="c"># 
</span><span class="c"># @param IPlatformKey Get platform key by using _find_platform function.
</span><span class="c"># @return_var OIsSupported
</span><span class="c"></span><span class="nb">function</span><span class="p">(</span><span class="s">_check_supported_platform</span> <span class="s">IPlatformKey</span> <span class="s">OIsSupported</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">if</span> <span class="p">(</span><span class="s2">&#34;${IPlatformKey}&#34;</span> <span class="s">STREQUAL</span> <span class="s2">&#34;WIN&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OIsSupported</span><span class="o">}</span> <span class="s">true</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">return</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="c"># If there is no matched key, just return with false.
</span><span class="c"></span>	<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OISSupported</span><span class="o">}</span> <span class="s">false</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endfunction</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># @brief Check if platform is windows.
</span><span class="c">#
</span><span class="c"># @return_var OBool
</span><span class="c"></span><span class="nb">function</span><span class="p">(</span><span class="s">_is_windows</span> <span class="s">OBool</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">_find_platform</span><span class="p">(</span><span class="s">false</span> <span class="s">_in_key</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">if</span> <span class="p">(</span><span class="s2">&#34;${_in_key}&#34;</span> <span class="s">STREQUAL</span> <span class="s2">&#34;WIN&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OBool</span><span class="o">}</span> <span class="s">true</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">return</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="c"># If not matched, return false.
</span><span class="c"></span>	<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OBool</span><span class="o">}</span> <span class="s">false</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endfunction</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># @brief Find Windows SDK pathes and properties information.
</span><span class="c">#
</span><span class="c"># @return_var ODirs All found SDK path list.
</span><span class="c"># @return_var OBuildVers NOt used
</span><span class="c"># @return_var ONames Not used
</span><span class="c"># @return_var ODir Latest SDK path. 
</span><span class="c"># @return_var OLibDir Latest SDK include file path.
</span><span class="c"># @return_var OIncDir Latest SDK library file path.
</span><span class="c"></span><span class="nb">function</span><span class="p">(</span><span class="s">_find_winsdk</span> <span class="s">IVerbose</span> <span class="s">ODirs</span> <span class="s">OBuildVers</span> <span class="s">ONames</span> <span class="s">ODir</span> <span class="s">OLibDir</span> <span class="s">OIncDir</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">_is_windows</span><span class="p">(</span><span class="s">_in_flag</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">if</span> <span class="p">(</span><span class="s">_in_flag</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">include</span><span class="p">(</span><span class="s">FindWindowsSDK</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="c">#
</span><span class="c"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s">NOT</span> <span class="s">WINDOWSSDK_FOUND</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">message</span><span class="p">(</span><span class="s">FATAL_ERROR</span> <span class="s2">&#34;Proper Windows SDK is not found.&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">return</span><span class="p">()</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="c">#
</span><span class="c"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s">IVerbose</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WINDOWSSDK_DIRS</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WINDOWSSDK_FOUND_PREFERENCE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WINDOWSSDK_LATEST_NAME</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WINDOWSSDK_LATEST_DIR</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="c"># Update variables.
</span><span class="c"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">ODirs</span><span class="o">}</span> <span class="o">${</span><span class="nv">WINDOWSSDK_DIRS</span><span class="o">}</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">ODir</span><span class="o">}</span> <span class="o">${</span><span class="nv">WINDOWSSDK_LATEST_DIR</span><span class="o">}</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="s">_in_ODir</span> <span class="o">${</span><span class="nv">WINDOWSSDK_LATEST_DIR</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">get_windowssdk_library_dirs</span><span class="p">(</span><span class="o">${</span><span class="nv">_in_ODir</span><span class="o">}</span> <span class="s">_in_OLibDir</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">get_windowssdk_include_dirs</span><span class="p">(</span><span class="o">${</span><span class="nv">_in_ODir</span><span class="o">}</span> <span class="s">_in_OIncDir</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="nb">windowssdk_name_lookup</span><span class="p">(</span><span class="o">${</span><span class="nv">_in_ODir</span><span class="o">}</span> <span class="s">_in_ONames</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">windowssdk_build_lookup</span><span class="p">(</span><span class="o">${</span><span class="nv">_in_ODir</span><span class="o">}</span> <span class="s">_in_OBuildVers</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OBuildVers</span><span class="o">}</span> <span class="o">${</span><span class="nv">_in_OBuildVers</span><span class="o">}</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">ONames</span><span class="o">}</span> <span class="o">${</span><span class="nv">_in_ONames</span><span class="o">}</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OLibDir</span><span class="o">}</span> <span class="o">${</span><span class="nv">_in_OLibDir</span><span class="o">}</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">OIncDir</span><span class="o">}</span> <span class="o">${</span><span class="nv">_in_OIncDir</span><span class="o">}</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nb">endfunction</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># @macro dy_setup_build_settings
</span><span class="c">#
</span><span class="c"># @brief Set up default build settings.
</span><span class="c">#	Every project that needs to be built should be call this macro.
</span><span class="c"></span><span class="nb">macro</span><span class="p">(</span><span class="s">dy_setup_build_settings</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;${PROJECT_NAME} is built with ${CMAKE_BUILD_TYPE} mode.&#34;</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="c"># If there are source files in /Src, add source files (.cc) but except for prefix `_` files.
</span><span class="c"></span>	<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="s">_InGetSrcs</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">file</span><span class="p">(</span>
		<span class="s">GLOB_RECURSE</span> <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="s">_InGetSrcs</span>
		<span class="s">RELATIVE</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/Src&#34;</span>
		<span class="s">CONFIGURE_DEPENDS</span> <span class="s">*.cc</span>
	<span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="c"># Check if there are `Inc` and `Inl` directory in ${CMAKE_CURRENT_SOURCE_DIR}.
</span><span class="c"></span>	<span class="nb">if</span> <span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="s">_InGetSrcs</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="c"># If exist, add target_include_directories as PUBLIC.
</span><span class="c"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s">EXISTS</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/Inc&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">target_include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s">Inc</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s">EXISTS</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/Inl&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">target_include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s">Inl</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>		<span class="c"># If exist, add target_include_directories as INTERFACE.
</span><span class="c"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s">EXISTS</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/Inc&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">target_include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">INTERFACE</span> <span class="s">Inc</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s">EXISTS</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/Inl&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">target_include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">INTERFACE</span> <span class="s">Inl</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="c"># ...To match a literal - using brackets, 
</span><span class="c"></span>	<span class="c"># make it the first or the last character e.g. [+*/-] matches basic mathematical operators.
</span><span class="c"></span>	<span class="nb">foreach</span><span class="p">(</span><span class="s">SrcItem</span> <span class="o">${</span><span class="nv">${PROJECT_NAME</span><span class="o">}</span><span class="s">_InGetSrcs}</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">if</span> <span class="p">(</span><span class="s2">&#34;Src/${SrcItem}&#34;</span> <span class="s">MATCHES</span> <span class="s2">&#34;/_+[a-zA-Z0-9_ -]*.cc$&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">continue</span><span class="p">()</span><span class="err">
</span><span class="err"></span>		<span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>			<span class="nb">target_sources</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PRIVATE</span> <span class="s2">&#34;Src/${SrcItem}&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="nb">endforeach</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="c"># Set CXX Properties
</span><span class="c"></span>	<span class="nb">get_target_property</span><span class="p">(</span><span class="s">CxxStdVersion</span> <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">CXX_STANDARD</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">if</span> <span class="p">(</span><span class="s">CxxStdVersion</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;${PROJECT_NAME} is built with C++${CxxStdVersion}&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">else</span> <span class="p">()</span><span class="err">
</span><span class="err"></span>		<span class="c"># -NOTFOUND 
</span><span class="c"></span>		<span class="nb">set</span><span class="p">(</span><span class="s">CxxStdVersion</span> <span class="s">17</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">set_property</span><span class="p">(</span><span class="s">TARGET</span> <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PROPERTY</span> <span class="s">CXX_STANDARD</span> <span class="s">17</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">target_compile_definitions</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s">CPP_DyCommon_VER_17</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="c"># Set properties.
</span><span class="c"></span>	<span class="nb">set_target_properties</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
		<span class="s">PROPERTIES</span>
		<span class="s">LINKER_LANGUAGE</span> <span class="s">CXX</span>
		<span class="s">CXX_STANDARD_REQUIRED</span> <span class="s">ON</span>
		<span class="s">CXX_EXTENSIONS</span> <span class="s">ON</span>
		<span class="s">ARCHIVE_OUTPUT_DIRECTORY</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/lib/${CMAKE_BUILD_TYPE}&#34;</span>
		<span class="s">LIBRARY_OUTPUT_DIRECTORY</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/lib/${CMAKE_BUILD_TYPE}&#34;</span>
		<span class="s">RUNTIME_OUTPUT_DIRECTORY</span> <span class="s2">&#34;${CMAKE_CURRENT_SOURCE_DIR}/bin/${CMAKE_BUILD_TYPE}&#34;</span>
	<span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="c"># Add compile option flags.
</span><span class="c"></span>	<span class="nb">if</span> <span class="p">((</span>	<span class="c"># MSVC or Clang-Cl (Simulated MSVC on Clang)
</span><span class="c"></span>			<span class="o">${</span><span class="nv">CMAKE_CXX_COMPILER_ID</span><span class="o">}</span> <span class="s">STREQUAL</span> <span class="s2">&#34;Clang&#34;</span> 
			<span class="s">AND</span> <span class="s2">&#34;x${CMAKE_CXX_SIMULATE_ID}&#34;</span> <span class="s">STREQUAL</span> <span class="s2">&#34;xMSVC&#34;</span>
		<span class="p">)</span> 
		<span class="s">OR</span> <span class="o">${</span><span class="nv">CMAKE_CXX_COMPILER_ID</span><span class="o">}</span> <span class="s">STREQUAL</span> <span class="s2">&#34;MSVC&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="c"># CXX Flags.
</span><span class="c"></span>		<span class="nb">if</span> <span class="p">(</span><span class="o">${</span><span class="nv">CxxStdVersion</span><span class="o">}</span> <span class="s">EQUAL</span> <span class="s2">&#34;20&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>			<span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;/std:c++latest&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>			<span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;/std:c++${CxxStdVersion}&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="c"># Additional Flags.
</span><span class="c"></span>		<span class="c"># https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html
</span><span class="c"></span>		<span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;$&lt;$&lt;CONFIG:Debug&gt;:${ComOpts_MsvcDebug}&gt;&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;$&lt;$&lt;CONFIG:Release&gt;:${ComOpts_MsvcRelease}&gt;&#34;</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="nb">elseif</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_CXX_COMPILER_ID</span><span class="o">}</span> <span class="s">STREQUAL</span> <span class="s2">&#34;Clang&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="c"># CXX Flags.
</span><span class="c"></span>		<span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;-std=c++${CxxStdVersion}&#34;</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="c"># Additional Flags.
</span><span class="c"></span>		<span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;$&lt;$&lt;CONFIG:Debug&gt;:${ComOpts_ClangDebug}&gt;&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;$&lt;$&lt;CONFIG:Release&gt;:${ComOpts_ClangRelease}&gt;&#34;</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>		<span class="nb">message</span><span class="p">(</span><span class="s">FATAL_ERROR</span> <span class="s2">&#34;This project only supports Clang/Clang-cl or MSVC compiler now.&#34;</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span>	<span class="c"># If windows, let project add WIN32 and D3D12 libraries.
</span><span class="c"></span>	<span class="nb">_is_windows</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="s">IsWin</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">if</span> <span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="s">IsWin</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="c"># It seems it have not to be inserted into all project when WIN.
</span><span class="c"></span>		<span class="c"># target_include_directories(${PROJECT_NAME} PRIVATE ${WinInc})
</span><span class="c"></span>		<span class="nb">target_link_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PRIVATE</span> <span class="o">${</span><span class="nv">WinLib</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span>		<span class="nb">target_compile_definitions</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> 
		<span class="s">PRIVATE</span> 
			<span class="s2">&#34;UNICODE&#34;</span> 
			<span class="s2">&#34;_UNICODE&#34;</span>
			<span class="s2">&#34;_CRT_SECURE_NO_WARNINGS&#34;</span>
		<span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">target_link_libraries</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> 
		<span class="s">PRIVATE</span> 
			<span class="s2">&#34;d3d12.lib&#34;</span> 
			<span class="s2">&#34;d3dcompiler.lib&#34;</span> 
			<span class="s2">&#34;dxgi.lib&#34;</span>
		<span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nb">endmacro</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># -----------------------------------------------------------------------------
</span><span class="c"># 
</span><span class="c"># MAIN ROUTINES
</span><span class="c">#
</span><span class="c"># -----------------------------------------------------------------------------
</span><span class="c"></span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_VERBOSE_MAKEFILE</span> <span class="s">true</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_MODULE_PATH</span> <span class="s2">&#34;${CMAKE_SOURCE_DIR}/Module&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">include</span><span class="p">(</span><span class="s">CMakePrintHelpers</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">include</span><span class="p">(</span><span class="s">cotire</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">_find_platform</span><span class="p">(</span><span class="s">VERBOSE,</span> <span class="s">PlatformKey</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">_check_supported_platform</span><span class="p">(</span><span class="s">PlatformKey,</span> <span class="s">IsSupportedPlatform</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">if</span> <span class="p">(</span><span class="s">IsSupportedPlatform</span> <span class="s">EQUAL</span> <span class="s">false</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">message</span><span class="p">(</span><span class="s">FATAL_ERROR</span> <span class="s2">&#34;${PlatformKey} is not supported platform.&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">_is_windows</span><span class="p">(</span><span class="s">_out_iswindows</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">if</span> <span class="p">(</span><span class="s">_out_iswindows</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">_find_winsdk</span><span class="p">(</span><span class="s">VERBOSE</span> <span class="s">WinDirs</span> <span class="s">WinBuildVers</span> <span class="s">WinName</span> <span class="s">WinDir</span> <span class="s">WinLib</span> <span class="s">WinInc</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">if</span> <span class="p">(</span><span class="s">VERBOSE</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WinDirs</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WinDir</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WinLib</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WinInc</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WinName</span><span class="p">)</span><span class="err">
</span><span class="err"></span>		<span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">WinBuildVers</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c">#
</span><span class="c"># Compiler Flags
</span><span class="c">#
</span><span class="c"></span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">ComOpts_MsvcCommon</span> 
	<span class="s">/GR-</span> <span class="s">/W4</span> <span class="s">/WX</span> <span class="s">/MP</span> 
	<span class="s">-Wno-error=unused-command-line-argument</span>
	<span class="s">-Wno-error=expansion-to-defined</span>
	<span class="s">-Wno-error=ignored-pragma-intrinsic</span>
<span class="p">)</span> <span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">ComOpts_MsvcDebug</span> <span class="s">/Od</span> <span class="o">${</span><span class="nv">ComOpts_MsvcCommon</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">ComOpts_MsvcRelease</span> <span class="s">/O2</span> <span class="o">${</span><span class="nv">ComOpts_MsvcCommon</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">ComOpts_ClangCommon</span> <span class="s">-Wall</span> <span class="s">-Werror</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">ComOpts_ClangDebug</span> <span class="o">${</span><span class="nv">ComOpts_ClangCommon</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">ComOpts_ClangRelease</span> <span class="s">-O3</span> <span class="o">${</span><span class="nv">ComOpts_ClangCommon</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c">#
</span><span class="c"># Subdirectory (Need to be changed with IMPORT module.)
</span><span class="c">#
</span><span class="c"></span><span class="err">
</span><span class="err"></span><span class="nb">add_subdirectory</span><span class="p">(</span><span class="s">Engine</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">add_subdirectory</span><span class="p">(</span><span class="s">TestPrj</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">add_subdirectory</span><span class="p">(</span><span class="s">ThirdParty</span><span class="p">)</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>CMakeのメモまとめ</title>
			<link>https://liliilli.github.io/posts/cmake_memo/</link>
			<pubDate>Tue, 03 Mar 2020 23:59:05 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/cmake_memo/</guid>
			<description>https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1 Do&amp;rsquo;s and Don&amp;rsquo;ts CMakeで避けるべきのパターン https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1 link_directories、include_librariesなどのグローバル関数を使わ</description>
			<content type="html"><![CDATA[

<p><a href="https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html">https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html</a></p>

<p><a href="https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1">https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1</a></p>

<h1 id="do-s-and-don-ts">Do&rsquo;s and Don&rsquo;ts</h1>

<h2 id="cmakeで避けるべきのパターン">CMakeで避けるべきのパターン</h2>

<blockquote>
<p><a href="https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html">https://cliutils.gitlab.io/modern-cmake/chapters/intro/dodonot.html</a><br><a href="https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1">https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1</a></p>
</blockquote>

<ul>
<li><code>link_directories</code>、<code>include_libraries</code>などのグローバル関数を使わないこと。</li>
<li><code>PUBLIC</code>はあんまり使わずにできる限り<code>PRIVATE</code>にすべき。</li>
<li>ファイルを取得するために<code>GLOB</code>を使わないこと。もしかして使わざるをえない場合には<code>CONFIGURE_DEPENDS</code>フラグを使えば使わないままに<code>GLOB</code>を使うようはうまく動作するらしい。</li>
</ul>

<p><a href="https://cmake.org/cmake/help/latest/command/file.html">公式マニュアル</a>によれば、<code>GLOB</code>は<code>&lt;globbing-expressions&gt;</code>に当てはまるファイルのリストを取得し、それを変数に入れ込むらしい。この表現式は正規表現パターンみたいな文法を持ってる。<code>GLOB</code>の詳しいことはマニュアルを見ること。</p>

<ul>
<li>リンキングする時には<code>PUBLIC/PRIVATE</code>の指定を忘れないこと。</li>
</ul>

<h2 id="cmakeでやればイイかもパターン">CMakeでやればイイかもパターン</h2>

<ul>
<li>Make <code>ALIAS</code> targets to keep usage consistent.</li>
<li>関数の名前は小文字を推薦。変数は大文字でやる方が良いらしい。</li>
<li><code>cmake_policy</code>を使うこと。<a href="https://cmake.org/cmake/help/latest/command/cmake_policy.html">「リンク」</a></li>
<li>ビルトインコマンドなどはだいたい文字の大小を区別してないが、出来れば少文字でやる方が良いらしい。</li>
</ul>

<h1 id="basics">Basics</h1>

<h2 id="最低限バージョンを指定">最低限バージョンを指定</h2>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.1</span><span class="p">)</span></code></pre></div>
<p><code>VERSION &lt;version&gt;</code>によってCMakeのコードをビルドする時の規定が決まる。一番最新のCMakeを持っているとしても上の<code>VERSION</code>の後について来る数値によってビルドが通るか否かが決まる。バージョンによるポリシー（規定・規則）の違いは<a href="https://cmake.org/cmake/help/latest/manual/cmake-policies.7.html">リンク</a>を見ること。</p>

<p>特にCMakeのバージョンが3.12にアップグレードするに連れて</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.1...3.15</span><span class="p">)</span></code></pre></div>
<p>のように<strong>範囲</strong>を決めることが出来るようになった。<br>なので厳密には上記の構文は以下のように書かなかればならないらしい。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.1...3.15</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># CMakeのバージョンが3.12より下なら、CMakeのバージョンに合うポリシーを入れてビルドを行う。
</span><span class="c"></span><span class="nb">if</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_VERSION</span><span class="o">}</span> <span class="s">VERSION_LESS</span> <span class="s">3.12</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nb">cmake_policy</span><span class="p">(</span><span class="s">VERSION</span> <span class="o">${</span><span class="nv">CMAKE_MAJOR_VERSION</span><span class="o">}</span><span class="s">.</span><span class="o">${</span><span class="nv">CMAKE_MINOR_VERSION</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<p>または<code>cmake_minimum_required</code>を使うことも出来る。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.1</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_VERSION</span><span class="o">}</span> <span class="s">VERSION_LESS</span> <span class="s">3.15</span><span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nb">cmake_policy</span><span class="p">(</span><span class="s">VERSION</span> <span class="o">${</span><span class="nv">CMAKE_MAJOR_VERSION</span><span class="o">}</span><span class="s">.</span><span class="o">${</span><span class="nv">CMAKE_MINOR_VERSION</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>    <span class="nb">cmake_policy</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.15</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<h2 id="プロジェクトセッティング">プロジェクトセッティング</h2>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">project</span><span class="p">(</span><span class="s">MyProject</span> 
	<span class="s">VERSION</span> <span class="s">1.0</span> <span class="c"># `MyProject_Version`とか`PROJECT_VERSION`変数などに数値が更新される
</span><span class="c"></span>    <span class="s">DESCRIPTION</span> <span class="s2">&#34;Very nice project&#34;</span> <span class="c"># 3.8以降から付けられる
</span><span class="c"></span>    <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span> <span class="err">#</span> <span class="err">基本</span> <span class="err">`C</span> <span class="err">CXX`で指定されている</span></code></pre></div>
<h2 id="ターゲット-targets-をよく使うべき">ターゲット（Targets）をよく使うべき</h2>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">target_include_directories</span><span class="p">(</span><span class="s">&lt;target&gt;</span> <span class="s">PUBLIC</span> <span class="s">&lt;rel/abs_directory_path&gt;</span><span class="p">)</span></code></pre></div>
<p><a href="https://cmake.org/cmake/help/latest/command/target_include_directories.html">target_include_directories</a>コマンドは<code>target</code>にディレクトリーのパスを関連付ける。</p>

<p><code>PUBLIC</code>でできたパスの場合は、他のターゲットがこのターゲットを参照するときに、このターゲットに関連付けられたディレクトリーパスも一緒に参照するということである。<code>PRIVATE</code>にした場合には自分だけ参照して他のターゲットなどには干渉しないらしい。<code>INTERFACE</code>はヘッダー専用ライブラリーに使うものである。</p>

<p>ターゲットを別のターゲットの関連付ける時にはこう使う。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">add_library</span><span class="p">(</span><span class="s">&lt;another_target&gt;</span> <span class="s">STATIC</span> <span class="s">another.cpp</span> <span class="s">another.h</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">&lt;another_target&gt;</span> <span class="s">PUBLIC</span> <span class="s">&lt;target&gt;</span><span class="p">)</span></code></pre></div>
<p><a href="https://cmake.org/cmake/help/latest/command/target_link_libraries.html">target_link_libraries</a>は<code>&lt;another_target&gt;</code>に他のライブラリまたはターゲットを依存させる時に使う。もしターゲットがCMakeのターゲットリストで見えなかったら、ライブラリーで探してくれる。<code>&lt;target&gt;</code>ではなく、パスでも指定することが出来る。</p>

<p>ターゲットはそれぞれ<code>include_directories</code>とか<code>linked_libraries</code>などを持っているので、ターゲットの依存するスコープなどを制限したい場合に<code>PUBLIC</code>または<code>PRIVATE/INTERFACE</code>などを使うらしい。</p>

<h1 id="変数とキャッシュ">変数とキャッシュ</h1>

<h2 id="ローカル変数">ローカル変数</h2>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">set</span><span class="p">(</span><span class="s">MY_VARIABLE</span> <span class="s2">&#34;value&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">MY_LIST</span> <span class="s2">&#34;one&#34;</span> <span class="s2">&#34;two&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">MY_LIST_THAT_SAME_ABOVE</span> <span class="s2">&#34;one;two&#34;</span><span class="p">)</span></code></pre></div>
<p><code>set</code>コマンドで変数を設定し、設定した変数に接近する時には<code>${}</code>を使って値を取得出来る。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="err">${MY_LIST}</span></code></pre></div>
<p>変数のスコープは、<code>set</code>などで変数を決めてから下のディレクトリーのCMakeLists.txtファイルまで及ぶ。現在ファイルだけスコープを決めたければ、<code>set</code>コマンドで変数を設定する時に最後に<code>PARENT_SCOPE</code>を入れれば現在ファイルだけでスコープが決まるらしい。</p>

<p>またCMakeの変数はスペース（空白）文字に寄って区切られているため、空白文字が入ってそうなパスが入った変数に接近する時には、<code>&quot;&quot;</code>を付けて接近するほうが良さそうかも。</p>

<h2 id="キャッシュ変数">キャッシュ変数</h2>

<p>CMakeでビルドする時に変数の値などを決めたいなら、<strong>キャッシュ変数</strong>を使う。BOOLならば普通の<strong>OPTION</strong>でも良いが、</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">option</span><span class="p">(</span><span class="s">MY_OPTION</span> <span class="s2">&#34;This is settable from the command line&#34;</span> <span class="s">OFF</span><span class="p">)</span></code></pre></div>
<p>それじゃなく複雑な値を入れたい場合には以下のように中に<code>CACHE</code>を入れる。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">set</span><span class="p">(</span><span class="s">MY_CACHE_VARIABLE</span> <span class="s2">&#34;VALUE&#34;</span> <span class="s">CACHE</span> <span class="s">STRING</span> <span class="s2">&#34;Description&#34;</span><span class="p">)</span></code></pre></div>
<p>ただしこれじゃGUIまたは外部からCMakeをビルドする時に変数の値を変更することは出来ない。なので（１）のようにするか、それとも<code>INTERNAL</code>を使って（２）のように書いて外部から値が設定するようにするしかない。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">set</span><span class="p">(</span><span class="s">MY_CACHE_VARIABLE</span> <span class="s2">&#34;VALUE&#34;</span> <span class="s">CACHE</span> <span class="s">STRING</span> <span class="s2">&#34;&#34;</span> <span class="s">FORCE</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">mark_as_advanced</span><span class="p">(</span><span class="s">MY_CACHE_VARIABLE</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">MY_CACHE_VARIABLE</span> <span class="s2">&#34;VALUE&#34;</span> <span class="s">CACHE</span> <span class="s">INTERNAL</span> <span class="s2">&#34;&#34;</span><span class="p">)</span></code></pre></div>
<p>このキャッシュ変数を使って実装されたビルトイン変数は<a href="https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html">リンク</a>で見れる。</p>

<h2 id="properties">Properties</h2>

<p>属性（Properties）は変数と使い方は同じだが、ターゲットまたはディレクトリーにくっ付いたものである。Propertiesもグローバル属性があるんだけど、ターゲットの大体の属性は<code>CMAKE_</code>として始まる変数を見て、属性を値を埋めるように設計されているらしい。</p>

<p>例えば、<code>CMAKE_CXX_STANDARD</code>の場合にはすべてのターゲットの<code>CXX_STANDARD</code>造成の値を更新するようになっている。もしかして一つ一つ属性を付けようとしたら、以下のようにすれば良い。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">set_property</span><span class="p">(</span><span class="s">TARGET</span> <span class="s">TargetName</span>
             <span class="s">PROPERTY</span> <span class="s">CXX_STANDARD</span> <span class="s">11</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="c"># または複数で
</span><span class="c"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">TargetName</span> <span class="s">PROPERTIES</span> <span class="s">CXX_STANDARD</span> <span class="s">11</span><span class="p">)</span></code></pre></div>
<p>ターゲットから属性の値を持ってくる時には<code>get_property</code>を使う。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">get_property</span><span class="p">(</span><span class="s">ResultVariable</span> <span class="s">TARGET</span> <span class="s">TargetName</span> <span class="s">PROPERTY</span> <span class="s">CXX_STANDARD</span><span class="p">)</span></code></pre></div>
<p>属性のリストは<a href="https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html">リンク</a>で見れるらしい。</p>

<h1 id="programming-in-cmake">Programming in CMake</h1>

<h2 id="if-構文"><code>if</code>構文</h2>

<p><code>if</code>構文は変数と表現式をどう使うかによって<code>THEN</code>に入ることと<code>ELSE</code>に入ることが変わる。例えば、ある変数<code>variable</code>がある時、普通に<code>variable</code>に入れたら、</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">if</span> <span class="p">(</span><span class="s">variable</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="c"># &#39;ON&#39;, &#39;YES&#39;, &#39;Y&#39;, または０じゃない数字
</span><span class="c"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="c"># &#39;0&#39;, &#39;OFF&#39;, &#39;NO&#39;, &#39;N&#39;, &#39;IGNORE&#39;, &#39;NOTFOUND&#39;, &#39;&#34;&#34;&#39; または最後に&#39;-NOTFOUND&#39;で終わる時
</span><span class="c"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<p>ただし、検証しようとする変数がどちらに当てはまらないと、自動に<code>${variable}</code>としてまた検証を行う。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">if</span> <span class="p">(</span><span class="o">${</span><span class="nv">variable</span><span class="o">}</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="c"># false-like 表現式じゃなければすべてtrueになる
</span><span class="c"></span><span class="nb">else</span><span class="p">()</span><span class="err">
</span><span class="err"></span>	<span class="c"># &#39;&#34;&#34;&#39; または true になれない表現式はすべてこっちへ
</span><span class="c"></span><span class="nb">endif</span><span class="p">()</span></code></pre></div>
<h2 id="generator-expressions">Generator-Expressions</h2>

<h2 id="マクロと関数">マクロと関数</h2>

<blockquote>
<p><a href="https://cmake.org/cmake/help/latest/command/macro.html">macro</a><br><a href="https://cmake.org/cmake/help/latest/command/function.html">function</a></p>
</blockquote>

<p><code>function</code>と<code>macro</code>はほとんど同じだが、関数は引数として入れる変数が外部から見えないようになっている。もしかし入れられた引数を結果値または関数の内部で更新したい場合には<code>PARENT_SCOPE</code>を使う。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">function</span><span class="p">(</span><span class="s">SIMPLE</span> <span class="s">REQUIRED_ARG</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">message</span><span class="p">(</span><span class="s">STATUE</span> <span class="s2">&#34;Simple arguments: ${REQUIRED_ARG}, followed by ${ARGV}&#34;</span><span class="p">)</span><span class="err">
</span><span class="err"></span>	<span class="nb">set</span><span class="p">(</span><span class="o">${</span><span class="nv">REQUIRED_ARG</span><span class="o">}</span> <span class="s2">&#34;From SIMPLE&#34;</span> <span class="s">PARENT_SCOPE</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endfunction</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">simple</span><span class="p">(</span><span class="s">This</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">message</span><span class="p">(</span><span class="s2">&#34;Output: ${This}&#34;</span><span class="p">)</span> <span class="err">#</span> <span class="err">Output:</span> <span class="err">From</span> <span class="err">SIMPLE</span></code></pre></div>
<p>ここで<code>${ARGV}</code>と<code>${ARGN}</code>という関数で呼べるビルトイン変数があってこれを使い渡した引数を出力することができるだろう。そして、CMakeの関数では他の言語とは違いリターン値がない。なので関数から何かを返したい場合には出力専用の引数を作ってそこに<code>PARENT_SCOPE</code>でセットすること。</p>

<h1 id="デバッグ">デバッグ</h1>

<h2 id="変数などを出力">変数などを出力</h2>

<p>普通<code>message</code>で出力することができる。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;MY_VARIABLE=${MY_VARIABLE}&#34;</span><span class="p">)</span></code></pre></div>
<p>ただし、ビルトインのモジュールを使えば<code>printf</code>でやってる感覚を無くし、よりモーダンな接近法で変数リストを出力することができる。</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="nb">include</span><span class="p">(</span><span class="s">CMakePrintHelpers</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">cmake_print_variables</span><span class="p">(</span><span class="s">MY_VARIABLE</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">cmake_print_properties</span><span class="p">(</span>
    <span class="s">TARGETS</span> <span class="s">my_target</span>
    <span class="s">PROPERTIES</span> <span class="s">POSITION_INDEPENDENT_CODE</span>
<span class="p">)</span></code></pre></div>
<h2 id="デバッグモードでビルド">デバッグモードでビルド</h2>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="err">-DCMAKE_BUILD_TYPE=Debug</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Hugoブログを使いこなせるためのメモ</title>
			<link>https://liliilli.github.io/posts/hugo_memo/</link>
			<pubDate>Tue, 03 Mar 2020 23:10:28 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/hugo_memo/</guid>
			<description>すごく久しぶりにHugoのブログを使おうとしましたが、ブログに記事を書くどころかHugoの使い方すらすっかり忘れてしまいました。だもんで自分</description>
			<content type="html"><![CDATA[

<p>すごく久しぶりにHugoのブログを使おうとしましたが、ブログに記事を書くどころかHugoの使い方すらすっかり忘れてしまいました。だもんで自分用のメモみたいなことを書いていつでも覚えさせられるようにしたいと思います。</p>

<p>ちなみにブログの設定環境はWindowsです。新しくインストールするなら<code>$ brew install hugo</code>みたいなもんは当然出来ないし、Windowsのパッケージをダウンロードして設置するしかないみたいですね。</p>

<h1 id="覚えておくといい-かも-メモリスト">覚えておくといい（かも）メモリスト</h1>

<h2 id="レポジトリー登録">レポジトリー登録</h2>

<ul>
<li><p>WindowsではHugoをインストールしてから環境変数に登録する必要があります。</p></li>

<li><p>HugoはDeployで生成された本サイトページと、そのページを生成するためのリソースが一つのディレクトリの中にまとまっているので、遠隔リポジトリーなどにリソースをセーブする為には２つのリポジトリーを作ることが一番良いらしい。</p>

<ul>
<li>例えば、Hugoの本コンテンツとリソースを入れ込む用途として使う<code>&lt;YOUR-PROJECT&gt;</code>と
結果としてDeployされた<code>&lt;USERNAME&gt;.github.io</code>レポジトリ。
<br /></li>
</ul></li>

<li><p><code>&lt;YOUR-PROJECT&gt;</code>は本プロジェクトとして<br></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git remote add origin git@github.com:integerous/blog.git</code></pre></div></li>

<li><p><code>&lt;USERNAME&gt;.github.io</code>はSubmoduleとして登録する。<br></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git submodule add -b master <span class="se">\
</span><span class="se"></span>git@github.com:integerous/integerous.github.io.git public</code></pre></div></li>
</ul>

<p>上記のようにすることで<code>public</code>っていうDeployされた時に作られるウェブサイトフォルダーは本プロジェクトとは違って<code>&lt;USERNAME&gt;.github.io</code>を持つことになる。</p>

<h2 id="コンテンツ生成">コンテンツ生成</h2>

<ul>
<li>コンテンツ生成はブログのフォルダーから<code>$ hugo new posts/test1.md</code>みたいなコマンドを売ってファイルを生成する。Draftで生成したい場合には<code>-D</code>を最後につける。</li>
<li>コンテンツをローカルで見る為には<code>hugo server</code>または<code>hugo server -D</code>で確認できる。</li>
</ul>

<h2 id="コンテンツアップロード">コンテンツアップロード</h2>

<ol>
<li>まず<code>$ hugo -t テーマの名前</code>で設置されたテーマが適用されたコンテンツを<code>public</code>フォルダーに生成。</li>
<li><code>public</code>フォルダーに移動し、gitなどで<code>&lt;USERNAME&gt;.github.io</code>にコミットする。</li>

<li><p>ルートフォルダーに戻り、生リソースを<code>&lt;YOUR-PROJECT&gt;</code>にコミットする。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git push origin master</code></pre></div></li>
</ol>

<h1 id="最後に">最後に</h1>

<p>ちなみにほぼ３ヶ月ぐらい放置してたブログをまだ使おうとしたのは、個人プロジェクトの<code>CMakeLists.txt</code>を削除してしまい、また書こうとしても<code>CMake</code>なんてすっかり忘れてしまってブログにメモとりながら再実装する必要があったからです。これで一日無駄使いしてしまいWINAPIのFiberのサンプルを書く時間なんてなくなってしまいました。</p>

<p>ソースコードはちゃんとバックアップしましょうね。</p>

<h1 id="リンク">リンク</h1>

<p><a href="https://github.com/Integerous/Integerous.github.io">Hugo로 Github.io 블로그 만들기</a></p>
]]></content>
		</item>
		
		<item>
			<title>C&#43;&#43;2aのconceptsを使ってみた。</title>
			<link>https://liliilli.github.io/posts/cpp_concept/</link>
			<pubDate>Thu, 21 Nov 2019 20:33:04 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/cpp_concept/</guid>
			<description>C++のConceptを簡略説明 C++2a（20）から追加する文法の一つであるconceptは、あるタイプの制約条件を記すことができる識別子</description>
			<content type="html"><![CDATA[

<h1 id="c-のconceptを簡略説明">C++のConceptを簡略説明</h1>

<p>C++2a（20）から追加する文法の一つである<code>concept</code>は、あるタイプの制約条件を記すことができる識別子です。制約条件というのは<code>Constraints</code>と呼びますが、あくまでも付与された<code>concept</code>を満足するための一連の条件組だと言えます。以下はある<code>concept</code>を宣言するコードです。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">is_floating_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<p>注意することは、宣言したconceptは、他のconceptを宣言する時に型引数で<code>typename</code>または<code>class</code>の代わりに使うことはできません。また、<code>requires</code>を使うこともできません。ただし、定義する構文で使うことはできます。</p>

<p>constraintsはconceptだけじゃなくて、<code>requires</code>文法を使ってタイプの条件を設定することができます。C#に例えたら、多分<code>where</code>が一番近いんじゃないかな？と思いますね。下はconceptを使わずにconstraintsだけを使っているコードです。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// First syntax of `requires` and `constraints`
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go3</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">v2</span><span class="p">)</span> <span class="k">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>宣言したconceptは次のように使えます。conceptじゃない構文であれば、<code>typename</code>と<code>class</code>の代わりに使えることがわかります。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="n">is_floating_point</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go4</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>ただし、上のコードではあくまでも<code>v1</code>と<code>v2</code>が<code>Float</code>という型に縛られているので、<code>v1</code>に<code>double</code>を入れたり<code>v2</code>に<code>float</code>を入れてコンパイルすることはできません。下のコードでは、上記の問題点を解決するため<code>template</code>を使わず、conceptを型として使います。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">auto</span> <span class="nf">go5</span><span class="p">(</span><span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>[const/volatile] concept auto [&amp;, &amp;&amp;]</code>を使うことで<code>v1</code>と<code>v2</code>のタイプは別々のタイプが持てるようになります。実はリターン型<code>auto</code>の前にもconceptをくっつけることが出来ます。</p>

<p>最後に、変数にもconceptが使えます。<code>auto</code>を一緒に使いますが、前にconceptを書けることでタイプ自体じゃなくてできる行動・特性をもつタイプの一連として考えるようになり、もっと柔軟なロジックを組むことが出来ます。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//floating_point auto val2 = go6(1.2f, 3.4f); 
</span><span class="c1">// go6は`int`を返しますが、`int`はfloating_pointコンセプトの条件が満たしていないので
</span><span class="c1">// コンパイルエラーが出ます。
</span><span class="c1"></span><span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">val3</span> <span class="o">=</span> <span class="n">go5</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>
</code></pre></div>
<h1 id="もっと詳しく知りたい方へ">もっと詳しく知りたい方へ</h1>

<p>上の説明は、<code>concept</code>と<code>requires</code>、そして条件構文でできることの一部しか紹介していません。詳しく知りたい型には以下の文書をお読みいただけましたら嬉しいです。</p>

<p><a href="https://en.cppreference.com/w/cpp/language/constraints">https://en.cppreference.com/w/cpp/language/constraints</a></p>

<p>また、C++のコードがウェブで作成できるCompiler Explorerというサイトで、gcc (trunk)またはclang (concepts)を選択しましたら<code>concept</code>が実装されたバージョンでコードが組めることが出来ます。</p>

<h1 id="full-code">Full code</h1>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go1</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">value1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">value2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">typename</span> <span class="n">Float</span><span class="p">,</span>
    <span class="k">typename</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;&gt;</span>
<span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go2</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">value1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">value2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">value1</span> <span class="o">+</span> <span class="n">value2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// First syntax of `requires`.
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go3</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">v2</span><span class="p">)</span> 
    <span class="k">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Using concept instead of typename or class in template.
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">is_floating_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">is_floating_point</span> <span class="n">Float</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">go4</span><span class="p">(</span><span class="k">const</span> <span class="n">Float</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Float</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">concept</span> <span class="n">floating_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// We can write `floating_point` explicitly before `auto` return.
</span><span class="c1">// When `floating_point` is written before auto, return value should
</span><span class="c1">// satisfy `floating_point` constraint.
</span><span class="c1"></span><span class="k">auto</span> <span class="nf">go5</span><span class="p">(</span><span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="nf">go6</span><span class="p">(</span><span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="kt">int</span><span class="p">{</span><span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">};</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//go1(1, 2.3);
</span><span class="c1"></span>    <span class="c1">//go1(1.2f, 2.3);
</span><span class="c1"></span>    <span class="n">go1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>          <span class="c1">// Float is int.
</span><span class="c1"></span>    <span class="n">go1</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">2.3f</span><span class="p">);</span>    <span class="c1">// Float is float.
</span><span class="c1"></span>    <span class="n">go1</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">);</span>      <span class="c1">// Float is double.
</span><span class="c1"></span>
    <span class="c1">//go2(1, 2);        // Substitution is failed, and output message is bizzare.
</span><span class="c1"></span>    <span class="n">go2</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">);</span>      <span class="c1">// Float is double.
</span><span class="c1"></span>
    <span class="c1">// Substitution is failed 
</span><span class="c1"></span>    <span class="c1">// but output message is humble and more readable.
</span><span class="c1"></span>    <span class="c1">//go3(1, 2);
</span><span class="c1"></span>    <span class="c1">//go3(1, 2.3);
</span><span class="c1"></span>    <span class="n">go3</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>        

    <span class="c1">// constraints not satisfied
</span><span class="c1"></span>    <span class="c1">//go4(1, 10);
</span><span class="c1"></span>    <span class="c1">// Also need one uniformed type.
</span><span class="c1"></span>    <span class="c1">// template argument deduction/substitution failed:
</span><span class="c1"></span>    <span class="c1">//go4(1.2f, 3.4);     
</span><span class="c1"></span>    <span class="n">go4</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>
    <span class="n">go4</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>

    <span class="c1">// error: use of function &#39;auto go5(auto:1, auto:2) 
</span><span class="c1"></span>    <span class="c1">// [with auto:1 = int; auto:2 = int]&#39; with unsatisfied constraints
</span><span class="c1"></span>    <span class="c1">//go5(1, 10);
</span><span class="c1"></span>    <span class="n">go5</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>
    <span class="n">go5</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>
    <span class="n">go5</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>
    <span class="n">go5</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">val1</span> <span class="o">=</span> <span class="n">go6</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span> <span class="c1">// This outputs warning but not error,
</span><span class="c1"></span>    <span class="c1">// But below is failed to compile.
</span><span class="c1"></span>    <span class="c1">// &lt; constraints not satisfied
</span><span class="c1"></span>    <span class="c1">// &lt; the expression &#39;is_floating_point_v&lt;T&gt;&#39; evaluated to &#39;false&#39;
</span><span class="c1"></span>    <span class="c1">//floating_point auto val2 = go6(1.2f, 3.4f);
</span><span class="c1"></span>    <span class="k">const</span> <span class="n">floating_point</span> <span class="k">auto</span> <span class="n">val3</span> <span class="o">=</span> <span class="n">go5</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span> <span class="mf">3.4f</span><span class="p">);</span>
    <span class="k">return</span> <span class="kt">int</span><span class="p">{</span><span class="n">val3</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>ShaderToyでPBRを書いてから、自ら解説してみた。</title>
			<link>https://liliilli.github.io/posts/shadertoy_pbr/</link>
			<pubDate>Sat, 16 Nov 2019 19:51:58 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/shadertoy_pbr/</guid>
			<description>実は2週前に、ShaderToyというウェブでGLSLがかけて、それをレンダリングすることができるサイトで、上のシェーダーを書いてました。前</description>
			<content type="html"><![CDATA[

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/WsdSDf?gui=true&t=10&paused=true&muted=false" allowfullscreen></iframe>
実は2週前に、ShaderToyというウェブでGLSLがかけて、それをレンダリングすることができるサイトで、上のシェーダーを書いてました。前にもShaderToyで色々と書いたんですが、PBRを本格に適用して書いたのは今が初めてです。</p>

<p>なんで、このシェーダーを書きながら、どうやってPBRのDiffuseとSpecularを実装したのかを簡単と大雑把に書きたいと思います。図形の作り方、またはレイマーチングのやり方に関しては説明いたしません。</p>

<h1 id="本編">本編</h1>

<p>PBRレンダリングを勉強するときによく見られるDisneyの<code>Physical-Based Shading at Disney</code>、または色々のPBRが基づく理論文書を読みますと、光と視点のよるある地点の色は以下になります。</p>

<p>$$
f(\pmb{l}, \pmb{v}) = \text{diffuse} + \text{specular}
$$
<code>Diffuse</code>と<code>Specular</code>はそれぞれの特性を独立的に持てると言えます。なので、実施に最終色を入れるときに次のように単純に<code>Diffuse</code>と<code>Specular</code>を入れます。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="c1">// fragColorは[0,1]のvec4(R,G,B,A)です。</span>
<span class="n">fragColor</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">dif</span> <span class="o">+</span> <span class="n">spc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></code></pre></div>
<blockquote>
<p>$$ f(\pmb{l}, \pmb{v}) $$ は実際には色そのまのを表してはいません。あくまでBRDF（Bidirectional-Reflectance Distribution Funciton）のモデルを表したものであり、実際にはぶつかった入射光線と表面の法線での半球で、すべての反射光線がどの角度とエナジーを持つのかを調べて、全部合わせないと正確な数値が計算できません。</p>

<p>ただし、今はもっと抽象化した数式を使ってレンダリングをしようとします。リアルタイムで完全な数式を解いて色を得ることはほぼ不可能だし、もっと抽象化したモデルでもだいたい通じます。</p>
</blockquote>

<h2 id="diffuse">Diffuse</h2>

<p>普通よく使うのは<code>Lambertian</code>ですが<code>Oren-Nayar</code>っていう、もっと正確なPBRモデルもあります。僕は最初は<code>Lambertian</code>を使いましたが、最終は<code>Oren-Nayar</code>にしました。</p>

<h3 id="lambertian">Lambertian</h3>

<p>$$
f(\pmb{l}, \pmb{v}) = \frac{\rho_{ss}}{\pi}
$$</p>

<p><code>Diffuse</code>モデルの中で一番簡単なモデルです。色だけでモデルBRDFが決まりますし、だとしてもそれっぽく見えるようになるので普通のゲームでもよく使います。</p>

<p>ここで
$$
\rho_{ss}
$$
は、表面のアルベド（物体が光を弾いたときの反射率）を表します。これだけがLambertianのモデルの数値になります。</p>

<p>下のコードはLambertianモデルを使って、実際のピクセルのカラーを表現するコードです。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">FactorDiffLambertian</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">/</span> <span class="n">pi</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">vec3</span> <span class="n">DiffuseLambertian</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> 
                       <span class="k">in</span> <span class="k">vec3</span> <span class="n">diffuse</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">ambient</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mix</span><span class="p">(</span><span class="n">ambient</span><span class="p">,</span> <span class="n">diffuse</span><span class="p">,</span> <span class="n">FactorDiffLambertian</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>注意するとこは、<code>FactorDiffLamberitan</code>の中の<code>dot(l, n)</code>は実際はLambertianのモデルの数式に含まれていません。<code>mix(ambient, diffuse, ...)</code>の<code>diffuse</code>が上記の
$$
\rho_{ss}
$$
になります。
そして、<code>FactorDiffLambertian</code>関数は、以下の数式
$$
L_o(\mathbf{v}) = \int_{\mathbf{l}\in\Omega}{f(\mathbf{l}, \mathbf{v})L_i(\mathbf{l})(\mathbf{n}\cdot\mathbf{l})d\mathbf{l}}
$$
の<code>dot(l, n)</code>項を表しています。（ただし、πは事前に入れときました。反省するとこですね。）</p>

<p>このモデルの特徴は表面が平坦だと見なしてレンダリングを行うところです。Roughnessが関与するとこが無く、単純にアルベドと光と表面の法線ベクトルによる明度だけをレンダリングします。ということで、ちょっと単純だけどコストが速いし、それなりにごまかせば他のモデルとあんまり違いは出ないと思います。</p>

<h3 id="oren-nayar">Oren-Nayar</h3>

<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model">https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model</a>
<a href="https://mimosa-pudica.net/improved-oren-nayar.html">https://mimosa-pudica.net/improved-oren-nayar.html</a></p>
</blockquote>

<p>このモデルは上のLambertianとは違って、表面の粗さによって明度の違いのレンダリングを調節できます。Oren-Nayarとともに表面の粗さによるDiffuseレンダリングモデルを総じて、<code>Rough-surface diffuse BRDF</code>と呼びます。</p>

<p>とりあえずOren-Nayarは論文をみますとFull-Model（完全モデル）とQuantitive-Model（ある程度省略したモデル）に分かれています。ウィキペディアに乗っているのはQuantitive-Modelだし、僕もフールモデルじゃなくてQuantitive-Modelを使ってOren-Nayarを実装してます。</p>

<p>Oren-Nayar（Quantitiveバージョン）は以下の数式となります。
$$
\begin{align}
L_{r} &amp;=
    \frac{\rho}{\pi}
    \cdot (\mathbf{l} \cdot \mathbf{n})
    \cdot (A + (B \cdot \max[0, \cos(\phi_{i} - \phi_{v})]
        \cdot \sin\alpha
        \cdot \tan\beta))
    \cdot E_0
\\<br />
A &amp;= 1 - 0.5\frac{\sigma^2}{\sigma^2 + 0.33}
\\<br />
B &amp;= 0.45 \frac{\sigma^2}{\sigma^2 + 0.09}
\\<br />
\alpha &amp;= \max(
    \theta_{\mathbf{l} \cdot \mathbf{n}},
    \theta_{\mathbf{v} \cdot \mathbf{n}})
\\<br />
\beta &amp;= \min(
    \theta_{\mathbf{l} \cdot \mathbf{n}},
    \theta_{\mathbf{v} \cdot \mathbf{n}})
\end{align}
$$
しかし僕は2番目のリンクにあるベクトルを使った数式を使いました。
$$
\begin{align}
L_o &amp;= \frac{\rho}{\pi}\cdot(\mathbf{l}\cdot\mathbf{n})(A + B\frac{\mathbf{s}}{t})
\\<br />
s &amp;= \mathbf{l}\cdot\mathbf{v} - (\mathbf{n}\cdot\mathbf{l})(\mathbf{n}\cdot\mathbf{v})
\\<br />
t &amp;=
\begin{cases}
1 &amp; \text{if $s \le 0$} \\<br />
\max(\mathbf{n}\cdot\mathbf{v}, \mathbf{n}\cdot\mathbf{l}) &amp; \text{if $s \gt 0$}
\end{cases}
\\<br />
A &amp;= (1 - 0.5\frac{\sigma^2}{\sigma^2 + 0.33} + 0.17\rho\frac{\sigma^2}{\sigma^2 + 0.13})
\\<br />
B &amp;= 0.45\frac{\sigma^2}{\sigma^2 + 0.09}
\end{align}
$$
なぜなら、上の数式を直接反映してみたらところどころでバグによる明るい曲線が見えるからです。多分<code>tan()</code>項でバグったりして不具合が描画されると思いますが、直せずに下のベクトル形態の数式を使ってOren-NayarのQuantitive-Modelを実装しました。</p>

<p>数式で見れる<code>\rho</code>（$ \rho $ ）はアルベドを表します。普通Lamberitanのアルベドのように、アルベドカラーを入れます。そして<code>\sigma</code>（$ \sigma $）は表面の粗さ（Roughness）を示します。だいたい０～１の値を持ちます。</p>

<p>上の数式を表したコードは下にあります。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">OrenNayarAlpha</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">OrenNayarBeta</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mix</span><span class="p">(</span>
        <span class="mf">1.</span><span class="n">f</span><span class="p">,</span>
        <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)),</span>
        <span class="n">step</span><span class="p">(</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">OrenNayarAlpha</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">OrenNayarA</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">-</span> <span class="mf">0.5</span><span class="n">f</span> <span class="o">*</span> <span class="p">(</span>
         		<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
    <span class="o">/</span> <span class="c1">// ----------------------</span>
        	<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.33</span><span class="n">f</span><span class="p">)</span>           
    <span class="p">)</span>
    <span class="o">+</span> <span class="mf">0.17</span><span class="n">f</span> <span class="o">*</span> <span class="p">(</span>
        		<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
    <span class="o">/</span> <span class="c1">// ----------------------</span>
        	<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.13</span><span class="n">f</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">OrenNayarB</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mf">0.45</span><span class="n">f</span> <span class="o">*</span> <span class="p">(</span>
         		<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
    <span class="o">/</span> <span class="c1">// ----------------------</span>
        	<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.09</span><span class="n">f</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">FactorDiffOrenNayar</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">float</span> <span class="n">A</span>  	<span class="o">=</span> <span class="n">OrenNayarA</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    <span class="k">float</span> <span class="n">B</span> 	<span class="o">=</span> <span class="n">OrenNayarB</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    <span class="k">float</span> <span class="n">_a</span> 	<span class="o">=</span> <span class="n">OrenNayarAlpha</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">float</span> <span class="n">_b</span> 	<span class="o">=</span> <span class="n">OrenNayarBeta</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">FactorDiffLambertian</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span> <span class="o">*</span> <span class="p">(</span><span class="n">_a</span> <span class="o">/</span> <span class="n">_b</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">vec3</span> <span class="n">DiffuseOrenNayar</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> 
                      <span class="k">in</span> <span class="k">vec3</span> <span class="n">diffuse</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">ambient</span><span class="p">,</span> 
                      <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mix</span><span class="p">(</span><span class="n">ambient</span><span class="p">,</span> <span class="n">diffuse</span><span class="p">,</span> <span class="n">FactorDiffOrenNayar</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>一気にコードの量が増えましたが、分析していただきましたら大したものはないことがわかります。</p>

<p>実は、2番目のリンク先で投稿した方の改良したOren-Nayarモデルも実装はしたんですが、光が表面全体を照らすときの描画が好きじゃなかったので断念してOren-NayarのQuantitive-Modelを最終採用しました。</p>

<h2 id="specular">Specular</h2>

<p>SpecularのBRDFも、上のDiffuseのようにMicrofacet理論に基づいたモデルを使っています。Specular（ハイライト）は、Diffuseとは違ってカメラの目線によってある位置にハイライトの陰影がつけられるかが異なります。（なんで、Lambertianみたいな単純なモデルは無いです）</p>

<p>普通に使ってるPBRのSpecularモデルは、以下の<strong>Cook-Torrance Model</strong>です。
$$
f_{spec}(\mathbf{l}, \mathbf{v}) = \frac
    {F(\mathbf{h}, \mathbf{l})G_{2}(\mathbf{l},\mathbf{v},\mathbf{h})D(\mathbf{h})}
    {4|\mathbf{n}\cdot\mathbf{l}||\mathbf{n}\cdot\mathbf{v}|}
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">cn</span> <span class="o">=</span> <span class="mf">4.</span><span class="n">f</span> <span class="o">*</span> <span class="n">max</span><span class="p">(</span><span class="mf">.25</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ld</span><span class="p">))</span> <span class="o">*</span> <span class="n">max</span><span class="p">(</span><span class="mf">.25</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="n">fwd</span><span class="p">));</span>
            
<span class="k">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">GTR</span><span class="p">(</span><span class="mi">9</span><span class="n">e</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="n">kBx1</span><span class="p">.</span><span class="n">mRough</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="mf">2.</span><span class="n">f</span><span class="p">);</span>
<span class="k">float</span> <span class="n">f</span> <span class="o">=</span> <span class="n">Schlick</span><span class="p">(</span><span class="n">kBx1</span><span class="p">.</span><span class="n">mR0</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
<span class="k">float</span> <span class="n">g</span> <span class="o">=</span> <span class="n">SeparableMaskingShadowing</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">kBx1</span><span class="p">.</span><span class="n">mRough</span><span class="p">);</span>
            
<span class="n">spc</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">f</span> <span class="o">*</span> <span class="n">g</span> <span class="o">/</span> <span class="n">cn</span><span class="p">;</span></code></pre></div>
<h3 id="fresnel-reflection">Fresnel Reflection</h3>

<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Fresnel_equations">https://en.wikipedia.org/wiki/Fresnel_equations</a>
<a href="https://en.wikipedia.org/wiki/Schlick%27s_approximation">https://en.wikipedia.org/wiki/Schlick%27s_approximation</a></p>
</blockquote>

<p>上記のCook-Torrance Modelにて、分子の
$$
F(\mathbf{h}, \mathbf{l})
$$
はフレネルの式を示します。要するに、光の入射光線がある物体の表面にぶつかるときの正反射率を表す数式です。全ての物質は自分のIOR（屈折率）と外部のIORによってそれぞれ違う反射率を持ちます。</p>

<p>ウィキペディアを見ていただきますと正確な数式がありますが、CGでシェーダープログラムにフレネルの式の全部をやらせるには負担がかかりすぎます。なので、下の単純なモデルを使いながらある程度フレネルの式を従います。
$$
F(\mathbf{h}, \mathbf{l}) \approx F_0 + (1 - F_0)(1 - (\mathbf{h}\cdot\mathbf{l})^+)^5
$$
この数式は<strong>Schlick-Approximation</strong>と言います。空気中の物質に対するフレネルの式の数値を得たいときの使います。もちろん、抽象化されたモデルなので正確ではありません。ですがフレネルの式の数値のグラフでの変動をある程度沿っています。</p>

<p>ここで、
$$
F_0
$$
は垂直入射の時のFresnel反射係数の実部です。この数値はRGBまたは普通のグレースケールの数値として入れられます。グレースケールになる場合には、物質が金属ではない場合で使えます。RGBは金属の物質のフレネルの数値を求めたい場合に使えます。（大雑把でしたけど、もっと詳しくお調べしたい方々は*Real-Time Rendering 4th*のChapter9をお読みくださいませ）
$$
\mathbf{h} = \text{normalize($\mathbf{l} + \mathbf{v}$)}
$$
<code>h</code>はハーフウェイベクトル（Halfway Vector）と言います。DiffuseとSpecularを一つに統合したレンダリングモデルである、Blinn-Phong Reflectance Modelでも使うやつです。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">Schlick</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r0</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">r0</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">r0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)),</span> <span class="mf">5.</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// または</span>

<span class="k">float</span> <span class="n">Schlick</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r0</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">td</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">r0</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">r0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="n">cos</span><span class="p">(</span><span class="n">td</span><span class="p">)),</span> <span class="mf">5.</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>上のコードはSchlick Approximationを2つのバージョンで実装したものです。下のバージョンの<code>td</code>は、<code>n</code>と<code>v</code>の角度差を表します。</p>

<h3 id="normal-distribution-function">Normal Distribution Function</h3>

<p>法線分布関数だと呼ばれる<strong>Normal Distribution Function</strong>は、微小面の法線がどうやって分布されているかを示す関数です。この関数は統計的に測定されて使っているか、それともある抽象化した数学関数を用いて使います。詳しくはmicrofacet理論の触れますので割愛します。</p>

<p>ですけどこのNDFに特徴の一つは、あるNDF関数があって、そしてある表面の法線ベクトル <code>N</code> があった時に、球面を覆う単位ベクトルを入れたNDFの値の積分は、<code>N</code> を持つ微細表面の面積になります。ということで、
$$
\int_{\mathbf{m} \in \Theta} {D(\mathbf{m})(\mathbf{n} \cdot \mathbf{m})d\mathbf{m}} = 1
$$
になります。</p>

<p>また、カメラまたは目線のベクトル<code>v</code>があるとき、ある表面の法線ベクトルが<code>n</code>で、そして微細表面の球体の単位ベクトルが<code>m</code>だとしたら、
$$
\int_{\mathbf{m} \in \Theta}{D(\mathbf{m})(\mathbf{v}\cdot\mathbf{m})d\mathbf{m}} = \mathbf{v}\cdot\mathbf{n}
$$
です。目によって実際に見える微小面の面積は微小面の凸凹の法線ベクトルたちを目線のベクトルとの内積し、結果値を全部足したのと同じです。<code>v * m</code>で目に見えない微小面はなくなりまし、見える表面は残ります。</p>

<p>一応これもリアルタイムでは計算しにくいので、上の特性から派生した様々な抽象化したモデルがあります。僕はDisney BRDFで使った<strong>GTR (Generalized-Trowbridge-Reitz）</strong>モデルを使いました。このモデルはGGX（Trowbridge-Reitz）モデルを一般化したものです。
$$
D_{GTR} = \frac{c}{(a^2\cos^2(\theta_{h})+\sin^2(\theta_{h}))^\gamma}
$$</p>

<blockquote>
<p>実はこの数式も実使用で使うために簡略化された数式です。Realtime-RenderingでGTRの完全数式を見てみますと結構ひどいです。（白目）</p>
</blockquote>

<p>上の数式で、<code>gamma</code>が2ならGGXと同じになります。以下はGTRをコードに写したものです。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">GTR</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">c</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">dh</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">gamma</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> 
        						 <span class="n">c</span>
    <span class="o">/</span> <span class="c1">//--------------------------------------------------------</span>
        <span class="n">pow</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">dh</span><span class="p">),</span> <span class="n">gamma</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h3 id="joint-masking-shadowing-function">Joint Masking Shadowing Function</h3>

<p>Joint Masking Shadowing Functionを説明する前に、簡単に一般Masking Function <code>G</code>を説明させていただきたいと思います。日本語でいうと<strong>幾何減衰項</strong>（読み方はわかりません）と言います。Masking Functionは微小面（Microfacet）によって発生するシャドウィング（自己陰影）、マスキング（自己遮蔽）を表したものです。</p>

<p>幾何減衰項は上で説明したNDFに（法線分布関数）と密接に関連されます。上の表面の法線・微小面の法線・目線の法線との関係がある数式は、以下のように変形できます。
$$
\int_{\in\Theta}{G_1(\mathbf{m}, \mathbf{v})D(\mathbf{m})(\mathbf{v}\cdot\mathbf{m})^+d\mathbf{m}} = \mathbf{v}\cdot\mathbf{n}
$$
ここで <code>G_1(m, v)</code>は<strong>Smith Function</strong>といい、<code>v</code>に対して見える<code>m</code>の比率を表します。ですけど、G1は実際には<code>m</code>が目線の反対方向を向いていなければ、G1の数値に全然影響がない特徴を持ちます。なのでSmith Function G1の数式は
$$
G_1(\mathbf{m}, \mathbf{v}) = \frac{\chi^+(\mathbf{m}\cdot\mathbf{v})}{1 + \Lambda(\mathbf{v})}
$$
となります。コードでは上の分子の項は、<code>m</code>と<code>v</code>の内積が0より大きければ1として置換できます。ですがこれをこのまま使うのではなく、BRDFを建てる時には以下のようにG1の代わりにG2を使います。
$$
f(\mathbf{l}, \mathbf{v}) =
    \int_{\mathbf{m}\in\Theta}
        f_{\mu}(\mathbf{l}, \mathbf{v}, \mathbf{m})
        G_2(\mathbf{l}, \mathbf{v}, \mathbf{m})
        D(\mathbf{m})
        \frac{(\mathbf{m}\cdot\mathbf{l})^+}{|\mathbf{n}\cdot\mathbf{l}|}
        \frac{(\mathbf{m}\cdot\mathbf{v})^+}{|\mathbf{n}\cdot\mathbf{v}|}
        d\mathbf{m}
\\<br />
\\<br />
G_2(\mathbf{l}, \mathbf{v}, \mathbf{m}) =
    G_1(\mathbf{v}, \mathbf{m})
    G_1(\mathbf{l}, \mathbf{m})
$$
上のG2の形以外に、様々な変形数式が存在します。G1を2つくっつけて掛け算する数式が一番だったりしますが、不具合が存在しますので下のも使われるそうです。（下は*Smith Height-Correlated Masking-Shadowing Function*）と言います。
$$
G_2(\mathbf{l}, \mathbf{v}, \mathbf{m}) = \frac{\chi^+(\mathbf{v}\cdot\mathbf{m})\chi^+(\mathbf{l}\cdot\mathbf{m})}{1 + \Lambda(\mathbf{v}) + \Lambda(\mathbf{l})}
$$
僕は一番簡単な分離型G2を使いました。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">Lambda</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">rad</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> 
        <span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="n">f</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span><span class="n">f</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="n">f</span> <span class="o">/</span> <span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span><span class="n">f</span><span class="p">)))</span> <span class="o">*</span> <span class="mf">.5</span><span class="n">f</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">SmithMasking</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">rad</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span>
        		<span class="mf">1.</span><span class="n">f</span>
    <span class="o">/</span> <span class="c1">//-----------------------</span>
        <span class="p">(</span><span class="mf">1.</span><span class="n">f</span> <span class="o">+</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">rad</span><span class="p">,</span> <span class="n">r</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">SeparableMaskingShadowing</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">tl</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">tv</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">SmithMasking</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">SmithMasking</span><span class="p">(</span><span class="n">tv</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h1 id="まとめ">まとめ</h1>

<p>以上、大雑把にコードを振り返りながらPBRの書き方、中身についてメモをしてみました。</p>

<h1 id="もっと詳しく調べたい方に">もっと詳しく調べたい方に</h1>

<ul>
<li><a href="https://qiita.com/mebiusbox2/items/1cd65993ffb546822213">https://qiita.com/mebiusbox2/items/1cd65993ffb546822213</a></li>

<li><p><a href="https://qiita.com/mebiusbox2/items/8db00cdcaf263992a5ce">https://qiita.com/mebiusbox2/items/8db00cdcaf263992a5ce</a></p></li>

<li><p><a href="https://qiita.com/emadurandal/items/3a8db7bc61438245654d">https://qiita.com/emadurandal/items/3a8db7bc61438245654d</a></p></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Chained-Group Allocationパターンについてメモ</title>
			<link>https://liliilli.github.io/posts/chained-group-allocation/</link>
			<pubDate>Sat, 09 Nov 2019 22:15:34 +0900</pubDate>
			
			<guid>https://liliilli.github.io/posts/chained-group-allocation/</guid>
			<description>https://www.plflib.org/chained_group_allocation_pattern.htm を見て、分かったことをメモしたいと思います。 Abstract Chanined-Group Allocationパターンは、ダブルリンクリストを拡張して、書くノードは付加的な情報を持</description>
			<content type="html"><![CDATA[

<p><a href="https://www.plflib.org/chained_group_allocation_pattern.htm">https://www.plflib.org/chained_group_allocation_pattern.htm</a><br>を見て、分かったことをメモしたいと思います。</p>

<h2 id="abstract">Abstract</h2>

<p><strong>Chanined-Group Allocation</strong>パターンは、ダブルリンクリストを拡張して、書くノードは付加的な情報を持ちながらメモリを動的に確保して使わせるパターンです。書くノードは２の二乗バイトのメモリを持ち、もしいま使っているノードが全部埋まったら、次のメモリを持つノードのメモリ量は今までのメモリ量を合わせた分になります。</p>

<h2 id="description">Description</h2>

<p>このパターンは、どれぐらいのメモリが必要になるかが事前にわからないときに使えるパターンだそうです。といったら、<code>std::vector&lt;T, A&gt;</code> とはあんまり変わらないじゃないのと思うかもしれないんですが、動的にメモリを管理して、拡張または縮小するのは同じだけれども、具体的には違うそうです。</p>

<p><code>std::vector&lt;T, A&gt;</code> の場合には、メモリが必ず一列になる必要があります。たとえ、あるベクターがあるメモリを持っているとして、もしメモリを拡張しなければならない場合には全体メモリを他のより広いメモリに移す作業を行いますね。しかし、今のパターンはメモリをまた再割当てせずに、新しいインスタンスの確保のためのメモリ空間を割り当てて、リンクリストのポインターに繋げることで拡張を行います。</p>

<p>このパターンでは「メモリブロック」（または空間を指しているポインター）と「メモリブロックに関しての様々な情報」をまとめて「グループ」と言います。情報の中にはダブルリンクリストを構成するための前のメモリノードと後のメモリノードへのポインターが必ず入ります。それ以外に、今ノードが持っているメモリブロックに何個まで入れるか、何個入ったか、Skipfieldなどなどが入りそうです。</p>

<blockquote>
<p>Skipfieldは後の<code>Colony</code>コンテナーを説明するときに説明したいと思います。</p>
</blockquote>

<p>Abstractで書いたように、各ノードは２の二乗バイトのメモリを持ちます。例えば、１番目のブロックが<code>int</code>で8個を持っているとしたら（32Bytes）、次のブロックはまた8個（32Bytes）、そして次々のブロックは1番目と2番目のブロックを足した分の16個（64Bytes）のメモリを持つようにします。で、4番目のブロックは8＋8＋16＝32個が入れるメモリ領域を持つでしょう。</p>

<h2 id="advantages">Advantages</h2>

<p><code>std::vector</code>のような連続メモリとは違って、メモリ領域がリンクリストとして連結していることによって、イテレータとポインターを持っているときに、コンテナーにインスタンスを挿入することでの無効化（Invalidation）が起こらなくなります。</p>

<p>そしてメモリ確保を個別にやってからリンクリストとして連結することで、Resizeなどの関数でよく起こりうるメモリ再確保⇒存在しているインスタンスのコピーまたはムーブコストが発生しなくなります。こうすることで要素（インスタンス）を追加する時の副作用コストが顕著に減ります。（削除する時にもメモリを解除して、リンクリストから除外させれば終わりなんでこれも速いです。）</p>

<p>また、Groupを静的のリストの形として管理したら、Groupのための動的メモリ確保をすることが省きそうなので一部状況ではもっと速く動作すると思われます。</p>

<h2 id="disadvantages">Disadvantages</h2>

<p>メモリ確保がリンクリストとして管理されるので、<code>std::vector</code>のような連続メモリに対してはイテレーターが一回りする速度は遅くなるかもしれません。特に、確保したメモリの実際領域がバラバラになっていたら、キャッシュを改めないとならなくなります。</p>

<p>また、連続メモリでのイテレーターが進むときに、単純にポインターを一つ動くだけとは違って、このパターンのイテレーターは次のメモリを持っているノードに移るべきかを分岐として検証しなければならなくなります。</p>

<p>よって、各メモリの確保数が2の二乗なこともこういった性能落ちを抑制するために意図的に設定した数値だそうです。そして各ノードの持っているメモリが大きすぎないように、各ノードのメモリ確保の限界値を決めることもより速い性能をするために必要だと言ってます。</p>

<h2 id="コード">コード？</h2>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TType</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">DGroup</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">DMeta</span>
    <span class="p">{</span>
        <span class="n">DGroup</span><span class="o">*</span> <span class="n">mpPrev</span><span class="p">;</span>
        <span class="n">DGroup</span><span class="o">*</span> <span class="n">mpNext</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mCnt</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mCap</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">TType</span><span class="o">*</span> <span class="n">mpMem</span><span class="p">;</span>
    <span class="n">DMeta</span>  <span class="n">mMeta</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="p">)</span><span class="o">::</span><span class="n">calloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mpMem</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mpMem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCnt</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">{</span>   <span class="c1">// Create _2.
</span><span class="c1"></span>
        <span class="c1">// We need to calculate next capacity (2^) O(k)
</span><span class="c1"></span>        <span class="kt">unsigned</span> <span class="n">nextCap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">pCur</span> <span class="o">=</span> <span class="n">_1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">pCur</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">nextCap</span> <span class="o">+=</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span>
            <span class="n">pCur</span> <span class="o">=</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="p">)</span><span class="o">::</span><span class="n">calloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DGroup</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mpMem</span>           <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">nextCap</span><span class="p">);</span>
        <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span>      <span class="o">=</span> <span class="n">nextCap</span><span class="p">;</span>
        <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span>    <span class="o">=</span> <span class="n">_2</span><span class="p">;</span>
        <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpPrev</span>    <span class="o">=</span> <span class="n">_1</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mpMem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">nextCap</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">nextCap</span><span class="p">);</span>
            <span class="n">_2</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCnt</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// DO SOME COMPLEXT THING...
</span><span class="c1"></span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// _2-&gt;mpMem[i - 1].~int();
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="p">{</span>
        <span class="k">auto</span><span class="o">*</span> <span class="n">pDelete</span>       <span class="o">=</span> <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span><span class="p">;</span>
        <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span>    <span class="o">=</span> <span class="n">pDelete</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mpNext</span><span class="p">;</span>
        <span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">pDelete</span><span class="p">);</span> 
        <span class="n">pDelete</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">_1</span><span class="o">-&gt;</span><span class="n">mMeta</span><span class="p">.</span><span class="n">mCap</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// _1-&gt;mpMem[i - 1].~int();
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="p">{</span>
        <span class="k">auto</span><span class="o">*</span> <span class="n">pDelete</span>       <span class="o">=</span> <span class="n">_1</span><span class="p">;</span>
        <span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">pDelete</span><span class="p">);</span>
        <span class="n">pDelete</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="最後に">最後に</h2>
]]></content>
		</item>
		
	</channel>
</rss>
