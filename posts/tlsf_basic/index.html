<!doctype html><html lang=en dir=" auto"><head><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=DotGothic16&family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel=stylesheet><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>TLSF Allocatorを作ってみた | neuromantic</title><meta name=keywords content="untagged"><meta name=description content="TLSFとは何なのか http://www.gii.upv.es/tlsf/http://www.gii.upv.es/tlsf/files/ecrts04_tlsf.pdfhttps://www.researchgate.net/publication/234785757_A_comparison_of_memory_allocators_for_real-time_applications TLSF（Two-Level Segregate Fit）は、リアルタイムで要求される速度、安定性、決定性（Deterministic）を"><meta name=author content="Jongmin Yun, Neu."><link rel=canonical href=https://liliilli.github.io/posts/tlsf_basic/><link crossorigin=anonymous href=/assets/css/stylesheet.min.80dbcc80c00cba63b71a6526cb77f5aab60620dd3fecc491bc3a5da1af3d4c62.css integrity="sha256-gNvMgMAMumO3GmUmy3f1qrYGIN0/7MSRvDpdoa89TGI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://liliilli.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://liliilli.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://liliilli.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://liliilli.github.io/apple-touch-icon.png><link rel=mask-icon href=https://liliilli.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.0"><meta property="og:title" content="TLSF Allocatorを作ってみた"><meta property="og:description" content="TLSFとは何なのか http://www.gii.upv.es/tlsf/http://www.gii.upv.es/tlsf/files/ecrts04_tlsf.pdfhttps://www.researchgate.net/publication/234785757_A_comparison_of_memory_allocators_for_real-time_applications TLSF（Two-Level Segregate Fit）は、リアルタイムで要求される速度、安定性、決定性（Deterministic）を"><meta property="og:type" content="article"><meta property="og:url" content="https://liliilli.github.io/posts/tlsf_basic/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-15T19:13:14+09:00"><meta property="article:modified_time" content="2020-03-17T23:17:23+09:00"><meta property="og:site_name" content="neuromantic"><meta name=twitter:card content="summary"><meta name=twitter:title content="TLSF Allocatorを作ってみた"><meta name=twitter:description content="TLSFとは何なのか http://www.gii.upv.es/tlsf/http://www.gii.upv.es/tlsf/files/ecrts04_tlsf.pdfhttps://www.researchgate.net/publication/234785757_A_comparison_of_memory_allocators_for_real-time_applications TLSF（Two-Level Segregate Fit）は、リアルタイムで要求される速度、安定性、決定性（Deterministic）を"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://liliilli.github.io/posts/"},{"@type":"ListItem","position":3,"name":"TLSF Allocatorを作ってみた","item":"https://liliilli.github.io/posts/tlsf_basic/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"TLSF Allocatorを作ってみた","name":"TLSF Allocatorを作ってみた","description":"TLSFとは何なのか http://www.gii.upv.es/tlsf/http://www.gii.upv.es/tlsf/files/ecrts04_tlsf.pdfhttps://www.researchgate.net/publication/234785757_A_comparison_of_memory_allocators_for_real-time_applications TLSF（Two-Level Segregate Fit）は、リアルタイムで要求される速度、安定性、決定性（Deterministic）を","keywords":["untagged"],"articleBody":"TLSFとは何なのか  http://www.gii.upv.es/tlsf/http://www.gii.upv.es/tlsf/files/ecrts04_tlsf.pdfhttps://www.researchgate.net/publication/234785757_A_comparison_of_memory_allocators_for_real-time_applications\n TLSF（Two-Level Segregate Fit）は、リアルタイムで要求される速度、安定性、決定性（Deterministic）を重視としたメモリ割当のアルゴリズム、そしてそれを実装したメモリアロケータを示します。普通のかんたんなメモリプール（Pool）とは違って、割当をしたいサイズを入れればその分のメモリを割り当ててくれる汎用性も持ちます。\n普通にmallocとかfreeとかすれば良いんじゃね？と思う方もいると思いますが、メモリが十分なら普通にシステムコールをして構わないと思います。しかし、組み込み系とかビデオゲーム機の中に仕込まれた限定的なメモリを十分活用しくちゃという状況ならmallocとかfreeだけでは内部メモリのフラグメンテーションを抑えることは出来ません。\n（OS自体でメモリの管理を行ってフラグメンテーションを抑えることは出来ると思いますが、厳密にはAPP側でもそれを制御したいですね）\nなんでそのフラグメンテーションを抑えながらも速度を保つためにいろんなDMA（Dynamic Memory Allocator（動的メモリ確保））アルゴリズムが出ました。その中で一つのアルゴリズムがTLSFです。\nTLSFは以下の特徴を持つそうです。\n メモリの確保、解除などに最悪O(1)の処理時間を持つ。 x86アーキテクチャで最悪168個のアセンブリコードを持つため、比較的速い。 平均15~25％のフラグメンテーション性能向上している。 リアルタイム条件のプログラムなでど使える。 確保したメモリの領域を拡張・縮小することが出来る。（この記事ではこれの実装は扱いません）  TLSFの概略な構造  http://www.gii.upv.es/tlsf/files/papers/tlsf_desc.pdf\n 上の説明文をお読みください。\nなんでTLSFを実装しようとしたの いくつかのゲームエンジンの中で、メモリを制御するために実装されているのがTLSFだったからです。それにOSでも使ってるらしいし、インターネットで一番明確ながらもソースコードも公開がされ、勉強になりそうなアルゴリズム（ライブラリー）だったので、まずTLSFから始めようとして実装することになりました。\nまた、TLSF自体はソースが公開されてはいるんですが、ライセンスがGPLまたはLPGLであるため自分の作っているプロジェクトに取り入れることが難しかったです。なので勉強兼ねて新しく実装し、それを個人プロジェクトに入れようとしたいこともあります。\nソースコード  https://gist.github.com/liliilli/01d0a8505dcc3fe4f5c951fbc179c769\n 説明する前に、まずコードを見せたいと思います。\nTSLF関数の全体を説明するのではなく、一部だけを取って説明したいですので、全体のフローはソースコードを見てください。\n基本APIリスト //! @brief Create tlsf pool. //! @param pool_size Overall memory pool size. //! @param p_pool Memory pool pointer to start. //! @return If successful, return available memory size of pool. //! If failed, return one of error codes below. //! * ADDRESS_IS_NULL : given p_pool is nullptr. //! * SIZE_IS_ZERO : pool_size is 0. //! * NOT_SUFFICIENT_MEM_SIZE : pool_size is not sufficient to create tlsf allocator. //! * NOT_ALIGNED_ADDRESS : p_pool is not aligned. u64 tlsf_raw_create(u64 pool_size, void* p_pool) DY_NOEXCEPT; //! @brief Destroy tlsf memory pool trivially. //! This function does not check tlsf has a valid object. //! @param p_pool Valid tlsf memory pool pointer. void tlsf_raw_destroy(void* p_pool) DY_NOEXCEPT; //! @brief Check if tlsf memory pool can be destroyed safely. //! This function checks tlsf has valid and every objects are released. //! @param p_pool valid tlsf memory pool pointer. bool tlsf_can_destroy(void* p_pool) DY_NOEXCEPT; //! @brief Try allocate memory with given mem_size. //! Created memory block may not have same mem_size size value, but aligned memory size. //! This function only should be used POD types. (trivial or standard_layout type) //! @param mem_size Minimum memory size to allocate. //! @param p_tlsf Tlsf pool pointer. //! @return If successful, return buffer pointer. Otherwise, return nullptr. void* tlsf_malloc(u64 mem_size, tlsf_raw_t* p_tlsf) DY_NOEXCEPT; //! @brief Try reallocate valid memory trivially. //! Reallocated memory block may not have same mem_size size value, but aligned memory size. //! This function only must be used POD types. (trivial or standard_layout type) //! @param p_data Valid data pointer. This pointer should be in given p_tlsf pool. //! @param mem_size Minimum memory size to reallocate. //! @param p_tlsf Tlsf pool pointer. //! @return If successful, return reallocated buffer pointer. //! Otherwise, return nullptr. void* tlsf_realloc(void* p_data, u64 new_size, tlsf_raw_t* p_tlsf) DY_NOEXCEPT; //! @brief Try calloc memory trivially. //! Created memory block may not have same mem_size size value, but aligned memory size. //! This function only should be used POD types. (trivial or standard_layout type) //! Created memory will be initialized with 0 (i32) //! @param mem_size Minimum memory size to allocate. //! @param elem_cnt The count of element list to allocate. //! @param p_tlsf Tlsf pool pointer. //! //! @return If successful, return buffer pointer. Otherwise, return nullptr. void* tlsf_calloc(u64 mem_size, u64 elem_cnt, tlsf_raw_t* p_tlsf) DY_NOEXCEPT; //! @brief Free valid memory trivially. //! This function only should be called when p_data is POD type. (trivial or standard_layout) //! @param p_data Valid data pointer. //! @param p_tlsf_pool Tlsf pool pointer. void tlsf_free(void* p_data, tlsf_raw_t* p_tlsf_pool) DY_NOEXCEPT;  tlsf_raw_create：確保したメモリ領域にTLSFプールを作ろうとします。TLSF自体は確保されたオブジェクトのメモリ領域を管理するために、ちょっと大きいヘッダー構造体が入れるので、メモリ数値がそれの大きさ以上にならないとTLSFプールの生成は失敗になります。 tlsf_raw_destroy：有効なTLSFプールを解除します。ただし、この関数はオブジェクトの確保されたメモリは解除してくれないため、この関数を呼ぶ前にtlsf_can_destroyでTLSFプールが解除できるかを確認することが必要です。 tlsf_can_destroy：有効なTLSFプールが解除できるかを問います。TLSFプールのメモリ管理をするTLSFヘッダー構造体は、プールで確保または解除が行われるたびにいくらのメモリ数値が変動されたかを覚えます。その数値が0かではないかを検査してプールが最終的に解除できるかを判断します。 tlsf_malloc：TLSFプールに対しmalloc（メモリ確保）をやってくれます。もし確保されたプールで入れられるメモリブロックがなければ、確保失敗でnullptrが返されます。また注意する点は、メモリが成功的に確保されるとき、必ずしもmem_sizeサイズだけが確保されるわけではないです。TLSF自体は出来る限り8Byteまたは16Byte桁アドレスに合わせようとするので、実際に確保されるメモリも当然8または16バイトに合わせようとします。 tlsf_realloc：同一TLSFプールから確保したメモリを再確保（realloc）します。TLSFプールのフラグメンテーションによって別の領域で再確保を行うか、それともメモリを拡張するだけで収めれるか分かれることがあります。また、再確保するメモリサイズに比べてプールの現状確保出来るメモリ量が足りなかったら、再確保は失敗します。 tlsf_calloc：Cライブラリーのcallocと一緒です。メモリ確保が成功したら、メモリ空間を0で初期化してくれます。 tlsf_free：TLSFメモリプールから確保したメモリを解除します。  説明 1.tlsf_raw_create if (mem_pool_size  sizeof(tlsf_raw_t) + block_header_t::sk_block_header_ovhd * 8) { return error_info{ NOT_SUFFICIENT_MEM_SIZE }; } 確保しようとするTLSFメモリプールのサイズが一定値以上かをチェックします。tlsf_raw_tはTLSFメモリプールを管理する構造体です。block_header_tは確保されるオブジェクトのメモリ空間の前に出てくるヘッダーです。現在オブジェクトのメモリサイズがいくらか、前、次のメモリブロックはどこに位置しているかについて情報を持ちます。\nclass tlsf_raw_t final { public: static constexpr u64 k_fli_max = 30; static constexpr u64 k_fli_offset = 6; static constexpr u64 k_fli_real = k_fli_max - k_fli_offset; static constexpr u64 k_sli_log2_max = 5; static constexpr u64 k_sli_max = 1  k_sli_log2_max; u32 m_tlsf_signature; area_info_t* m_area_head; u32 m_fl_bitmap; u32 m_sl_bitmap[k_fli_real]; block_header_t* mp_matrix[k_fli_real][k_sli_max]; u64 m_max_mem; // いらなくて良し  u64 m_used_mem; // 以下メンバー関数宣言 }; tlsf_raw_tで注目する変数は、m_fl_bitmapとm_sl_bitmap、そしてmp_matrixです。\nfl_bitmapとsl_bitmapはメモリ解除されて使えるブロックのハッシュ情報をビット単位で刻んで入れられるようになった変数らしいです。TLSFはメモリの要求される容量によって２階層のリストから適度な空きブロックへのポインターを持ってこれるようになってるので、この変数でFirst-IndexとSecond-Indexを取得するようになってます。この変数を用いた取得のやり方はfind_suitable_block関数で見れます。\nmp_matrixはメモリ解除されたメモリブロックのポインター先を持ちます。find_suitable_blockの中で返されたFirst-IndexとSecond-Index数値でこの配列変数から割当をするブロックのヘッダーを取得します。\nstruct block_header_t { static constexpr u64 sk_min_block_size = sizeof(free_ptr_t); static const u64 sk_block_header_ovhd; static constexpr u8 sk_free_block = 0x01; static constexpr u8 sk_prev_free = 0x02; block_header_t* p_prev_header; u64 stored_size; union { free_ptr_t free_ptr; block_buffer_t buffer; } ptr; // 以下メンバー関数宣言 }; block_header_tは確保された（または解除した後の）メモリブロックについての情報を持ちます。実際のデータバッファはptr.bufferから始まり、stored_size  2バイトまで続きます。もしブロックが解除した状態ならptrはfree_ptrに前と後のブロックヘッダー情報を入れるようになっています。\nまた、stored_sizeはデータバッファのサイズだけではなく、0番と1番のビットに自分がフリーブロックなのか、そして前のブロックがフリーかをフラグとして設定するようにしています。なので、TLSFの中で確保されたデータバッファのサイズは必ず4倍の数値になります。（こうしてキャッシュラインなどが整頓される効果も得られます。）\ntlsf_raw_create関数にまた戻ってTLSFシグニチャーを設定し、memsetで0に初期化を行います。\nblock_header_t* p_area_info_bhdr = process_area( p_tlsf-get_first_block_header(), get_rddn_size_default(mem_pool_size - sizeof(tlsf_raw_t)) ); p_tlsf-m_area_head = (area_info_t*)p_area_info_bhdr-get_buffer(); // make first block of tlsf pool. block_header_t* p_first_bhdr = p_area_info_bhdr-get_next_block(); tlsf_free(p_first_bhdr-get_buffer(), p_tlsf); TLSFメモリプールは普通のメモリプールとは違って扱うメモリ空間自体を拡張することが出来ます。ただし、拡張した別途のメモリ領域のアドレスは既存のTLSFと連続してない可能性があるので、リンクリスト（連結リスト）でアドレスを保持する必要があります。\nそのため、tlsf_raw_tの後には追加メモリ領域が保持するブロックのアドレス情報を持つ構造体、area_info_tがついて来ます。（ただし、area_info_t自体も特殊ブロックのバッファ部分に置かれるようになっています。）\nprocess_area() process_area()関数は、TLSFプールの初期メモリブロックを設定する関数です。初期で設定されるメモリブロックは以下となります。\n p_ib：area_info_tのブロック：別途のメモリ領域を使えるようにする。 p_next_b：任意オブジェクトメモリ確保のためのブロック p_next_next_b：メモリ領域の終わりを示すブロック（バッファのサイズは0）  p_next_bのバッファサイズを初期化するとき、またはp_ibのバッファサイズを設定する時には必ずメモリが整列されなければならないため、get_rddn_size_default()とget_rddn_size_default()関数を使ってメモリサイズを調整します。\nblock_header_t* p_next_b = p_ib-get_next_block(); p_next_b-set_buffer_size(get_rddn_size_default( size - 3 * block_header_t::sk_min_block_size - p_ib-get_block_size()) ); size - 3 * block_header_t::sk_min_block_size - p_ib-get_block_size()は、まずTLSF構造体を除外したメモリサイズに３つのブロックヘッダーサイズと、area_info_t分のメモリサイズを引いた、TLSFプールが生成された後で使えるメモリ量を示します。\n 本関数に戻って、\n// make first block of tlsf pool.  block_header_t* p_first_bhdr = p_area_info_bhdr-get_next_block(); tlsf_free(p_first_bhdr-get_buffer(), p_tlsf); p_next_b部分のブロックがまだ使える状態ではないので、TLSFを管理する構造体のbitmap変数とmatrixにアドレスをフラグを更新して使えるためfree関数を呼びます。最後にはp_next_bの使えるメモリ量を返して終わりです。\n2.tlsf_malloc mem_size = calc_min_memblock_size(mem_size); const auto rs_search = mapping_search(mem_size); const auto rs_suitable = find_suitable_block(p_tlsf_pool, rs_search.flv, rs_search.slv); block_header_t* p_b = rs_suitable.p_block_hdr; if (!p_b) { return nullptr; } if (rs_suitable.flv == -1 || rs_suitable.slv == -1) { return nullptr; } まず、TLSFプールから適当なメモリブロックを探します。一次にmapping_search関数で、First-IndexとSecond-Indexを取得し、最終にfind_suitable_blockで取得出来たブロックヘッダーのポインターと最終First-Index、Second-Indexを持ってくるようにします。\nmapping_search() const auto fl_sl = mapping_insert(size); result.flv = fl_sl.first_lv; result.slv = fl_sl.scnd_lv; まずmapping_insert()という関数を使って、First-Level Index（flv）とSecond-Level Index（slv）を取得します。\nmapping_insert() if (size  k_small_block) { result.first_lv = 0; result.scnd_lv = size / (k_small_block / tlsf_raw_t::k_sli_max); } else { result.first_lv = ms_bit(size); result.scnd_lv = (size  (result.first_lv - tlsf_raw_t::k_sli_log2_max)) - tlsf_raw_t::k_sli_max; result.first_lv -= tlsf_raw_t::k_fli_offset; } この関数でFirst-Level IndexとSecond-Level Indexを持ってきます。ところで、ここでsizeは8Byte整列されたサイズです。そして定数は以下となります。\n k_small_block：128Byte tlsf_raw_t::k_sli_max：32 tlsf_raw_t::k_sli_log2_max：5 tlsf_raw_t::k_fli_offset：6（2^6 == 128Bytes）  まず、sizeが128Byte以下になると、TLSFプールで提供されてるメモリブロックの中で一番小さいものが確保されるようになります。しかし、それ以上になるともっと適切なFLIとSLIの数値を持って来るため、下のようなアルゴリズムを通します。 $$ \\begin{align} \\text{mapping}(\\text{size}) \u0026\\rightarrow (f, s) \\\\\\\n\\text{mapping}(\\text{size}) \u0026= \\begin{cases} f := \\lfloor log_2(size) \\rfloor \\\\\\\ns := size * \\frac{2^{SLI}}{2^f} - 2^{SLI} \\end{cases} \\end{align} $$ 真ん中のresult.first_lv - tlsf_raw_t::k_sli_log2_maxは以下となります。 $$ \\alpha = log_2(2^{f - SLI}) $$ 上の関数では128Byte以下のブロックは全部FLIが0になるし、128Byte以上から1以上のインデックスを持つため、6を引く必要があります。最後にfirst_lvに6を引くのはそのためです。\nfind_suitable_block() const u32 tmp = p_tlsf-m_sl_bitmap[fl] \u0026 (~0  sl); if (tmp) { // if tmp is not 0.  result.flv = fl; result.slv = ls_bit(tmp); result.p_block_hdr = p_tlsf-mp_matrix[result.flv][result.slv]; } else { // if tmp is 0  result.flv = ls_bit(p_tlsf-m_fl_bitmap \u0026 (~0  (fl + 1))); if (result.flv  0) { result.slv = ls_bit(p_tlsf-m_sl_bitmap[result.flv]); result.p_block_hdr = p_tlsf-mp_matrix[result.flv][result.slv]; } } find_suitable_block()関数は、flとslを使って最終的にマトリックスに登録されている、要請されたサイズより大きいか同じの適当なメモリブロックを返します。まず、最初にはSLI（Second-Level Index）を探索し、そしてFLIを探索する形でフリーブロックが位置されているFirst-IndexとSecond-Indexを取得します。そして、TLSF管理構造体にある配列から空いているブロックのアドレスを持って来るようにします。\nただし、このflvとslvが0より低い値になると適合なブロック探しは失敗になります。\nls_bit() \u0026 ms_bit()  ls_bit：Find First Set（最初の１の値を持つビットの番地）を探します。 ms_bit：Find Last Set（最後に１の値を持つビットの番地）を探します。  普通のアルゴリズムでも値を計算することは出来るんですが、この関数の中ではもっとビットを早く計算するためにテーブルを使ってます。\nstatic constexpr i32 sk_table[256] = { -1, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, // ...  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 }; // in ms_bit (tls) const u32 x = (u32)val; const u32 a = [](const u32 v) { if (v  0xFFFF) { return v  0xFF ? 0 : 8; } else { return v  0xFFFFFF ? 16 : 24; } }(x); return sk_table[x  a] + a;  malloc関数に戻って…\nextract_block_hdr(p_b, p_tlsf_pool, rs_suitable.flv, rs_suitable.slv); block_header_t* p_nb = p_b-get_next_block(); mem_size = rs_search.rdup_size; 有効なフリーメモリブロックを取得した後には、それをマトリックスから外す必要があります。そして、ブロックと連結されている（リンクリストとして）メモリブロックがある場合には、そのブロックをマトリックスに登録する必要があります。extract_block_hdrはそれをやってくれます。\nextract_block_hdr() block_header_t* p_item = p_tlsf-mp_matrix[final_fl][final_sl] = p_b-get_free_ptrs()-p_next; if (p_item != nullptr) { p_item-get_free_ptrs()-p_prev = nullptr; } else { clear_bit(final_sl, \u0026p_tlsf-m_sl_bitmap[final_fl]); if (!p_tlsf-m_sl_bitmap[final_fl]) { clear_bit(final_fl, \u0026p_tlsf-m_fl_bitmap); } } この関数は、フリーブロックp_bに連結しているまた新しいフリーブロックを同じFirst、Second-Indexに連結して次のメモリ確保に対する準備を行うことをやってくれます。またインデックスに該当する新しいフリーブロックがない場合にはTLSF構造体からFirst、Second-Indexを参照するためのビットマップ（m_sl_bitmap、m_fl_bitmap）から自分のインデックス値が取得出来ないようにリセットします。\n if (tmp_size = sizeof(block_header_t)) { // 分割する。  block_header_t* p_b2 = (block_header_t*)((u8*)p_b-get_buffer() + mem_size); // Set p_b2 information...  p_nb-set_prev_bhdr(p_b2); const auto [split_fl, split_sl] = mapping_insert(tmp_size); insert_block(p_b2, p_tlsf_pool, split_fl, split_sl); // p_b2の設定が終わったら、p_bのサイズを更新する。 } else { p_nb-set_prev_freed(false); } 最後に、tmp_size := p_b-block_size - mem_sizeを計算し、確保されたメモリの量に対して新しい空きブロックが作れたら作るようにします。空きブロックが作られたら、insert_block()関数でTLSF構造体の空きブロック管理マトリックスに入れるようにします。\ninsert_block() free_ptr_t* p_free_ptr = p_b-get_free_ptrs(); p_free_ptr-p_prev = nullptr; p_free_ptr-p_next = p_tlsf-mp_matrix[final_fl][final_sl]; if (p_tlsf-mp_matrix[final_fl][final_sl]) { p_tlsf-mp_matrix[final_fl][final_sl]-get_free_ptrs()-p_prev= p_b; } p_tlsf-mp_matrix[final_fl][final_sl] = p_b; 空きブロックp_bを空きブロック管理マトリックスに入れます。ただし、指定されたインデックスにはすでに空きブロックがあるかもしれません。そのときにはリンクリストで２つを繋ぐようにします。こうすることで、extract_block_hdrなどで接近した複数のブロックが一つずつ抜かれて使えるようになります。\n 最後に、取得出来た空きブロックp_bの設定をし、リターン値として返せば終わります。\n3.tlsf_realloc TLSFのreallocアルゴリズムは３つの分岐に分かれます。\n 再確保するサイズが既存のサイズより小さく、使ってるブロックが使い回せる場合 確保するサイズは既存より大きいが、隣接する次のブロックを使って確保できる場合 １も２も当てはまらなく、mallocをして完全に新しいブロックを確保する場合  1. サイズが既存のサイズより小さい時 まず、サイズが小さくて隣接したブロックが空きブロックの場合には、その空きブロックと今の余りのメモリバッファを合わせて大きい空きブロックが作れるかを判断することが出来ます。以下のロジックではそれを判断し、満足したら併合するようにしています。\nif (p_next_bhdr-is_freed()) { const auto [next_fl, next_sl] = mapping_insert(p_next_bhdr-get_block_size()); extract_block(p_next_bhdr, p_tlsf, next_fl, next_sl); old_size += p_next_bhdr-get_block_size_with_header(); p_next_bhdr = p_next_bhdr-get_next_block(); } u64 new_free_size = old_size - new_size; if (new_free_size = sizeof(block_header_t)) { new_free_size -= block_header_t::sk_block_header_ovhd; auto* p_new_bhdr = (block_header_t*)((u8*)p_bhdr-get_buffer() + new_size); // p_new_bhdrの設定  // p_next_next_bhdr (既存p_next_bhdrの次ブロック)をp_newに連結 　// p_new_bhdrをマトリックスに挿入  const auto [new_fl, new_sl] = mapping_insert(new_free_size); insert_block(p_new_bhdr, p_tlsf, new_fl, new_sl); // 最後にp_bの情報を更新 } extract_block() この関数はextract_block_hdr()に似ていますが、自分の前後ブロックを連結させて、空きブロックマトリックスから自分を抜いて参照させないようにしています。ただし、マトリックスリストに先頭に見えないとマトリックスでの削除はされません。\nなぜ先頭に出てからこそ削除できるかはわからないですが、多分マトリックスに接近する時に必要となるFirst-IndexとSecond-Indexが前後同じになるから、わざとリンクリストを一通り回って削除するかを判断しなくても済ませるのではないかと思ってます。（間違ってるかもしれません）\nif (p_free_ptr-p_next) { p_free_ptr-p_next-get_free_ptrs()-p_prev = p_free_ptr-p_prev; } if (p_free_ptr-p_prev) { p_free_ptr-p_prev-get_free_ptrs()-p_next = p_free_ptr-p_next; } if (auto* p_matrix_b = p_tlsf-mp_matrix[final_fl][final_sl]; p_matrix_b == p_b) { p_matrix_b = p_tlsf-mp_matrix[final_fl][final_sl] = p_free_ptr-p_next; if (!p_matrix_b) { clear_bit(final_sl, \u0026p_tlsf-m_sl_bitmap[final_fl]); if (!p_tlsf-m_sl_bitmap[final_fl]) { clear_bit(final_fl, \u0026p_tlsf-m_fl_bitmap); } } }  2. サイズが既存より大きいが、隣接空きブロックで解決できる場合 隣接した空きブロックをくっつけることでサイズの問題が解決できれば、空きブロックをマトリックスから抜いてくっつけて、そして余ったメモリ空間を新しい空きブロックとして作ります。\nif (new_size  (old_size + p_next_bhdr-get_block_size())) { p_tlsf-m_used_mem -= p_bhdr-get_block_size_with_header(); const auto [next_fl, next_sl] = mapping_insert(p_next_bhdr-get_block_size()); extract_block(p_next_bhdr, p_tlsf, next_fl, next_sl); // ...  p_next_bhdr = p_bhdr-get_next_block(); // ...  u64 new_free_size = p_bhdr-get_block_size() - new_size; if (new_free_size = sizeof(block_header_t)) { new_free_size -= block_header_t::sk_block_header_ovhd; auto* p_new_bhdr = (block_header_t*)((u8*)p_bhdr-get_buffer() + new_size); // ...  // ...  const auto [new_fl, new_sl] = mapping_insert(new_free_size); insert_block(p_new_bhdr, p_tlsf, new_fl, new_sl); // ...  } // ...  return p_data; } 3. mallocで新しいブロックを探すしかない場合 どうしようもないのでmallocで新しいブロックを探します。探すことが出来たら、memcpyで既存のブロックの内容を新しいブロックにコピーします。ただし、この場合だとPODでしかちゃんとコピーが出来ないのでC++のクラスの情報が入ったブロックをコピーしたい場合には特殊なロジックが要るかもしれません。\n最後には既存のブロックをfreeします。（tlsf_free()）\n// Otherwise, we need to find another free-block. block_buffer_t* p_new_buffer = (block_buffer_t*)tlsf_malloc(new_size, p_tlsf); if (!p_new_buffer) { return nullptr; } const u64 copy_size = p_bhdr-get_block_size()  new_size ? new_size : p_bhdr-get_block_size(); memcpy(p_new_buffer, p_buffer, copy_size); tlsf_free(p_buffer, p_tlsf); 4.tlsf_free() 確保したメモリブロックを解除したい場合にはこの関数を使います。（ただし、PODタイプのみ）しかしメモリ解除をする時に、今解除するメモリブロックに隣接したブロックが空き（フリー）かを確認し、空きだったら併合して一つのブロックに纏めさせることも出来ます。\n// 消す前に次のブロックがFreeなのかを確認する。 if (block_header_t* p_temp_bhdr = p_bhdr-get_next_block(); p_temp_bhdr-is_freed()) { // 併合  const auto [fl, sl] = mapping_insert(p_temp_bhdr-get_block_size()); extract_block(p_temp_bhdr, p_tlsf_pool, fl, sl); // 後処理 } // 消す前に前のブロックがFreeなのかを確認する。 if (p_bhdr-is_prev_freed()) { block_header_t* p_prev_bhdr = p_bhdr-get_prev_bhdr(); // 併合  const auto [fl, sl] = mapping_insert(p_prev_bhdr-get_block_size()); extract_block(p_prev_bhdr, p_tlsf_pool, fl, sl); // 後処理 } 最後に空いたブロックを空きブロック管理マトリックスに入れます。\n// Final mapping insert. const auto [fl, sl] = mapping_insert(p_bhdr-get_block_size()); insert_block(p_bhdr, p_tlsf_pool, fl, sl); 5.tlsf_raw_destroy tlsf_raw_t* p_tlsf = (tlsf_raw_t*)p_pool; if (!p_tlsf-has_signature()) { return false; } return p_tlsf-m_used_mem == 0; TLSF構造体のシグニチャーを無効化します。それだけです。\n改善点 ・ビットシフトアルゴリズムがまだ完全に理解できてない First-IndexとSecond-Indexの数値をビットマップ変数に更新するためのアルゴリズムが完全には理解できませんでした。テストケースを作って、どのようにフラグ値が変わるのかを詳しく調べてみたいですね。\n・まだScalableではない TLSFの特徴の一つである、メモリプールをくっつけて更に多くのメモリが確保出来るようにするための機能がまだ実装してませんでした。次の記事を書くときには今抜かれた機能まで付けて、それの説明までしたいです。\nまとめ 最後までがんばります。（適当）\n","wordCount":"8276","inLanguage":"en","datePublished":"2020-03-15T19:13:14+09:00","dateModified":"2020-03-17T23:17:23+09:00","author":{"@type":"Person","name":"Jongmin Yun, Neu."},"mainEntityOfPage":{"@type":"WebPage","@id":"https://liliilli.github.io/posts/tlsf_basic/"},"publisher":{"@type":"Organization","name":"neuromantic","logo":{"@type":"ImageObject","url":"https://liliilli.github.io/favicon.ico"}}}</script></head><body id=" top"><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://liliilli.github.io accesskey=h title="neuromantic (Alt + H)">neuromantic</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://liliilli.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://liliilli.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://liliilli.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://liliilli.github.io/series/ title=Series><span>Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://liliilli.github.io>Home</a>&nbsp;»&nbsp;<a href=https://liliilli.github.io/posts/>Posts</a></div><h1 class=post-title>TLSF Allocatorを作ってみた</h1><div class=post-meta>2020, March 15&nbsp;·&nbsp;Jongmin Yun, Neu.</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#tlsf%e3%81%a8%e3%81%af%e4%bd%95%e3%81%aa%e3%81%ae%e3%81%8b aria-label=TLSFとは何なのか>TLSFとは何なのか</a></li><li><a href=#tlsf%e3%81%ae%e6%a6%82%e7%95%a5%e3%81%aa%e6%a7%8b%e9%80%a0 aria-label=TLSFの概略な構造>TLSFの概略な構造</a></li><li><a href=#%e3%81%aa%e3%82%93%e3%81%a7tlsf%e3%82%92%e5%ae%9f%e8%a3%85%e3%81%97%e3%82%88%e3%81%86%e3%81%a8%e3%81%97%e3%81%9f%e3%81%ae aria-label=なんでTLSFを実装しようとしたの>なんでTLSFを実装しようとしたの</a></li><li><a href=#%e3%82%bd%e3%83%bc%e3%82%b9%e3%82%b3%e3%83%bc%e3%83%89 aria-label=ソースコード>ソースコード</a></li><li><a href=#%e5%9f%ba%e6%9c%acapi%e3%83%aa%e3%82%b9%e3%83%88 aria-label=基本APIリスト>基本APIリスト</a></li><li><a href=#%e8%aa%ac%e6%98%8e aria-label=説明>説明</a><ul><li><a href=#1tlsf_raw_create aria-label=1.tlsf_raw_create>1.<code>tlsf_raw_create</code></a><ul><li><a href=#process_area aria-label=process_area()><code>process_area()</code></a></li></ul></li><li><a href=#2tlsf_malloc aria-label=2.tlsf_malloc>2.<code>tlsf_malloc</code></a><ul><li><a href=#mapping_search aria-label=mapping_search()><code>mapping_search()</code></a></li><li><a href=#mapping_insert aria-label=mapping_insert()><code>mapping_insert()</code></a></li><li><a href=#find_suitable_block aria-label=find_suitable_block()><code>find_suitable_block()</code></a></li><li><a href=#ls_bit--ms_bit aria-label="ls_bit() &amp;amp; ms_bit()"><code>ls_bit()</code> & <code>ms_bit()</code></a></li><li><a href=#extract_block_hdr aria-label=extract_block_hdr()><code>extract_block_hdr()</code></a></li><li><a href=#insert_block aria-label=insert_block()><code>insert_block()</code></a></li></ul></li><li><a href=#3tlsf_realloc aria-label=3.tlsf_realloc>3.<code>tlsf_realloc</code></a><ul><li><a href=#1-%e3%82%b5%e3%82%a4%e3%82%ba%e3%81%8c%e6%97%a2%e5%ad%98%e3%81%ae%e3%82%b5%e3%82%a4%e3%82%ba%e3%82%88%e3%82%8a%e5%b0%8f%e3%81%95%e3%81%84%e6%99%82 aria-label="1. サイズが既存のサイズより小さい時">1. サイズが既存のサイズより小さい時</a></li><li><a href=#extract_block aria-label=extract_block()><code>extract_block()</code></a></li><li><a href=#2-%e3%82%b5%e3%82%a4%e3%82%ba%e3%81%8c%e6%97%a2%e5%ad%98%e3%82%88%e3%82%8a%e5%a4%a7%e3%81%8d%e3%81%84%e3%81%8c%e9%9a%a3%e6%8e%a5%e7%a9%ba%e3%81%8d%e3%83%96%e3%83%ad%e3%83%83%e3%82%af%e3%81%a7%e8%a7%a3%e6%b1%ba%e3%81%a7%e3%81%8d%e3%82%8b%e5%a0%b4%e5%90%88 aria-label="2. サイズが既存より大きいが、隣接空きブロックで解決できる場合">2. サイズが既存より大きいが、隣接空きブロックで解決できる場合</a></li><li><a href=#3-malloc%e3%81%a7%e6%96%b0%e3%81%97%e3%81%84%e3%83%96%e3%83%ad%e3%83%83%e3%82%af%e3%82%92%e6%8e%a2%e3%81%99%e3%81%97%e3%81%8b%e3%81%aa%e3%81%84%e5%a0%b4%e5%90%88 aria-label="3. mallocで新しいブロックを探すしかない場合">3. mallocで新しいブロックを探すしかない場合</a></li></ul></li><li><a href=#4tlsf_free aria-label=4.tlsf_free()>4.<code>tlsf_free()</code></a></li><li><a href=#5tlsf_raw_destroy aria-label=5.tlsf_raw_destroy>5.<code>tlsf_raw_destroy</code></a></li></ul></li><li><a href=#%e6%94%b9%e5%96%84%e7%82%b9 aria-label=改善点>改善点</a><ul><ul><li><a href=#%e3%83%93%e3%83%83%e3%83%88%e3%82%b7%e3%83%95%e3%83%88%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0%e3%81%8c%e3%81%be%e3%81%a0%e5%ae%8c%e5%85%a8%e3%81%ab%e7%90%86%e8%a7%a3%e3%81%a7%e3%81%8d%e3%81%a6%e3%81%aa%e3%81%84 aria-label=・ビットシフトアルゴリズムがまだ完全に理解できてない>・ビットシフトアルゴリズムがまだ完全に理解できてない</a></li><li><a href=#%e3%81%be%e3%81%a0scalable%e3%81%a7%e3%81%af%e3%81%aa%e3%81%84 aria-label=・まだScalableではない>・まだScalableではない</a></li></ul></ul></li><li><a href=#%e3%81%be%e3%81%a8%e3%82%81 aria-label=まとめ>まとめ</a></li></ul></div></details></div><div class=post-content><h1 id=tlsfとは何なのか>TLSFとは何なのか<a hidden class=anchor aria-hidden=true href=#tlsfとは何なのか>#</a></h1><blockquote><p><a href=http://www.gii.upv.es/tlsf/>http://www.gii.upv.es/tlsf/</a>
<a href=http://www.gii.upv.es/tlsf/files/ecrts04_tlsf.pdf>http://www.gii.upv.es/tlsf/files/ecrts04_tlsf.pdf</a>
<a href=https://www.researchgate.net/publication/234785757_A_comparison_of_memory_allocators_for_real-time_applications>https://www.researchgate.net/publication/234785757_A_comparison_of_memory_allocators_for_real-time_applications</a></p></blockquote><p>TLSF（Two-Level Segregate Fit）は、リアルタイムで要求される速度、安定性、決定性（Deterministic）を重視としたメモリ割当のアルゴリズム、そしてそれを実装したメモリアロケータを示します。普通のかんたんなメモリプール（Pool）とは違って、割当をしたいサイズを入れればその分のメモリを割り当ててくれる汎用性も持ちます。</p><p>普通に<code>malloc</code>とか<code>free</code>とかすれば良いんじゃね？と思う方もいると思いますが、メモリが十分なら普通にシステムコールをして構わないと思います。しかし、組み込み系とかビデオゲーム機の中に仕込まれた限定的なメモリを十分活用しくちゃという状況なら<code>malloc</code>とか<code>free</code>だけでは内部メモリのフラグメンテーションを抑えることは出来ません。</p><p>（OS自体でメモリの管理を行ってフラグメンテーションを抑えることは出来ると思いますが、厳密にはAPP側でもそれを制御したいですね）</p><p>なんでそのフラグメンテーションを抑えながらも速度を保つためにいろんなDMA（Dynamic Memory Allocator（動的メモリ確保））アルゴリズムが出ました。その中で一つのアルゴリズムがTLSFです。</p><p>TLSFは以下の特徴を持つそうです。</p><ul><li>メモリの確保、解除などに最悪<code>O(1)</code>の処理時間を持つ。</li><li>x86アーキテクチャで最悪168個のアセンブリコードを持つため、比較的速い。</li><li>平均15~25％のフラグメンテーション性能向上している。</li><li>リアルタイム条件のプログラムなでど使える。</li><li>確保したメモリの領域を拡張・縮小することが出来る。（この記事ではこれの実装は扱いません）</li></ul><h1 id=tlsfの概略な構造>TLSFの概略な構造<a hidden class=anchor aria-hidden=true href=#tlsfの概略な構造>#</a></h1><blockquote><p><a href=http://www.gii.upv.es/tlsf/files/papers/tlsf_desc.pdf>http://www.gii.upv.es/tlsf/files/papers/tlsf_desc.pdf</a></p></blockquote><p>上の説明文をお読みください。</p><h1 id=なんでtlsfを実装しようとしたの>なんでTLSFを実装しようとしたの<a hidden class=anchor aria-hidden=true href=#なんでtlsfを実装しようとしたの>#</a></h1><p>いくつかのゲームエンジンの中で、メモリを制御するために実装されているのがTLSFだったからです。それにOSでも使ってるらしいし、インターネットで一番明確ながらもソースコードも公開がされ、勉強になりそうなアルゴリズム（ライブラリー）だったので、まずTLSFから始めようとして実装することになりました。</p><p>また、TLSF自体はソースが公開されてはいるんですが、ライセンスがGPLまたはLPGLであるため自分の作っているプロジェクトに取り入れることが難しかったです。なので勉強兼ねて新しく実装し、それを個人プロジェクトに入れようとしたいこともあります。</p><h1 id=ソースコード>ソースコード<a hidden class=anchor aria-hidden=true href=#ソースコード>#</a></h1><blockquote><p><a href=https://gist.github.com/liliilli/01d0a8505dcc3fe4f5c951fbc179c769>https://gist.github.com/liliilli/01d0a8505dcc3fe4f5c951fbc179c769</a></p></blockquote><p>説明する前に、まずコードを見せたいと思います。</p><p>TSLF関数の全体を説明するのではなく、一部だけを取って説明したいですので、全体のフローはソースコードを見てください。</p><h1 id=基本apiリスト>基本APIリスト<a hidden class=anchor aria-hidden=true href=#基本apiリスト>#</a></h1><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>//! @brief Create tlsf pool.
</span><span class=c1>//! @param pool_size Overall memory pool size.
</span><span class=c1>//! @param p_pool Memory pool pointer to start.
</span><span class=c1>//! @return If successful, return available memory size of pool.
</span><span class=c1>//!     If failed, return one of error codes below.
</span><span class=c1>//!     * ADDRESS_IS_NULL : given p_pool is nullptr.
</span><span class=c1>//!     * SIZE_IS_ZERO : pool_size is 0.
</span><span class=c1>//!     * NOT_SUFFICIENT_MEM_SIZE : pool_size is not sufficient to create tlsf allocator.
</span><span class=c1>//!     * NOT_ALIGNED_ADDRESS : p_pool is not aligned.
</span><span class=c1></span><span class=n>u64</span> <span class=nf>tlsf_raw_create</span><span class=p>(</span><span class=n>u64</span> <span class=n>pool_size</span><span class=p>,</span> <span class=kt>void</span><span class=o>*</span> <span class=n>p_pool</span><span class=p>)</span> <span class=n>DY_NOEXCEPT</span><span class=p>;</span>

<span class=c1>//! @brief Destroy tlsf memory pool trivially.
</span><span class=c1>//!     This function does not check tlsf has a valid object.
</span><span class=c1>//! @param p_pool Valid tlsf memory pool pointer.
</span><span class=c1></span><span class=kt>void</span> <span class=nf>tlsf_raw_destroy</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>p_pool</span><span class=p>)</span> <span class=n>DY_NOEXCEPT</span><span class=p>;</span>

<span class=c1>//! @brief Check if tlsf memory pool can be destroyed safely.
</span><span class=c1>//!     This function checks tlsf has valid and every objects are released.
</span><span class=c1>//! @param p_pool valid tlsf memory pool pointer.
</span><span class=c1></span><span class=kt>bool</span> <span class=nf>tlsf_can_destroy</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>p_pool</span><span class=p>)</span> <span class=n>DY_NOEXCEPT</span><span class=p>;</span>

<span class=c1>//! @brief Try allocate memory with given mem_size.
</span><span class=c1>//!     Created memory block may not have same mem_size size value, but aligned memory size.
</span><span class=c1>//!     This function only should be used POD types. (trivial or standard_layout type)
</span><span class=c1>//! @param mem_size Minimum memory size to allocate.
</span><span class=c1>//! @param p_tlsf Tlsf pool pointer.
</span><span class=c1>//! @return If successful, return buffer pointer. Otherwise, return nullptr.
</span><span class=c1></span><span class=kt>void</span><span class=o>*</span> <span class=nf>tlsf_malloc</span><span class=p>(</span><span class=n>u64</span> <span class=n>mem_size</span><span class=p>,</span> <span class=n>tlsf_raw_t</span><span class=o>*</span> <span class=n>p_tlsf</span><span class=p>)</span> <span class=n>DY_NOEXCEPT</span><span class=p>;</span>

<span class=c1>//! @brief Try reallocate valid memory trivially.
</span><span class=c1>//!     Reallocated memory block may not have same mem_size size value, but aligned memory size.
</span><span class=c1>//!     This function only must be used POD types. (trivial or standard_layout type)
</span><span class=c1>//! @param p_data Valid data pointer. This pointer should be in given p_tlsf pool.
</span><span class=c1>//! @param mem_size Minimum memory size to reallocate.
</span><span class=c1>//! @param p_tlsf Tlsf pool pointer.
</span><span class=c1>//! @return If successful, return reallocated buffer pointer.
</span><span class=c1>//!     Otherwise, return nullptr.
</span><span class=c1></span><span class=kt>void</span><span class=o>*</span> <span class=nf>tlsf_realloc</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>p_data</span><span class=p>,</span> <span class=n>u64</span> <span class=n>new_size</span><span class=p>,</span> <span class=n>tlsf_raw_t</span><span class=o>*</span> <span class=n>p_tlsf</span><span class=p>)</span> <span class=n>DY_NOEXCEPT</span><span class=p>;</span>

<span class=c1>//! @brief Try calloc memory trivially.
</span><span class=c1>//!     Created memory block may not have same mem_size size value, but aligned memory size.
</span><span class=c1>//!     This function only should be used POD types. (trivial or standard_layout type)
</span><span class=c1>//!     Created memory will be initialized with 0 (i32)
</span><span class=c1>//! @param mem_size Minimum memory size to allocate.
</span><span class=c1>//! @param elem_cnt The count of element list to allocate.
</span><span class=c1>//! @param p_tlsf Tlsf pool pointer.
</span><span class=c1>//!
</span><span class=c1>//! @return If successful, return buffer pointer. Otherwise, return nullptr.
</span><span class=c1></span><span class=kt>void</span><span class=o>*</span> <span class=nf>tlsf_calloc</span><span class=p>(</span><span class=n>u64</span> <span class=n>mem_size</span><span class=p>,</span> <span class=n>u64</span> <span class=n>elem_cnt</span><span class=p>,</span> <span class=n>tlsf_raw_t</span><span class=o>*</span> <span class=n>p_tlsf</span><span class=p>)</span> <span class=n>DY_NOEXCEPT</span><span class=p>;</span>

<span class=c1>//! @brief Free valid memory trivially.
</span><span class=c1>//!     This function only should be called when p_data is POD type. (trivial or standard_layout)
</span><span class=c1>//! @param p_data Valid data pointer.
</span><span class=c1>//! @param p_tlsf_pool Tlsf pool pointer.
</span><span class=c1></span><span class=kt>void</span> <span class=nf>tlsf_free</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>p_data</span><span class=p>,</span> <span class=n>tlsf_raw_t</span><span class=o>*</span> <span class=n>p_tlsf_pool</span><span class=p>)</span> <span class=n>DY_NOEXCEPT</span><span class=p>;</span>
</code></pre></div><ul><li><code>tlsf_raw_create</code>：確保したメモリ領域にTLSFプールを作ろうとします。TLSF自体は確保されたオブジェクトのメモリ領域を管理するために、ちょっと大きいヘッダー構造体が入れるので、メモリ数値がそれの大きさ以上にならないとTLSFプールの生成は失敗になります。</li><li><code>tlsf_raw_destroy</code>：有効なTLSFプールを解除します。ただし、この関数はオブジェクトの確保されたメモリは解除してくれないため、この関数を呼ぶ前に<code>tlsf_can_destroy</code>でTLSFプールが解除できるかを確認することが必要です。</li><li><code>tlsf_can_destroy</code>：有効なTLSFプールが解除できるかを問います。TLSFプールのメモリ管理をするTLSFヘッダー構造体は、プールで確保または解除が行われるたびにいくらのメモリ数値が変動されたかを覚えます。その数値が<code>0</code>かではないかを検査してプールが最終的に解除できるかを判断します。</li><li><code>tlsf_malloc</code>：TLSFプールに対しmalloc（メモリ確保）をやってくれます。もし確保されたプールで入れられるメモリブロックがなければ、確保失敗で<code>nullptr</code>が返されます。また注意する点は、メモリが成功的に確保されるとき、必ずしも<code>mem_size</code>サイズだけが確保されるわけではないです。TLSF自体は出来る限り8Byteまたは16Byte桁アドレスに合わせようとするので、実際に確保されるメモリも当然8または16バイトに合わせようとします。</li><li><code>tlsf_realloc</code>：同一TLSFプールから確保したメモリを再確保（realloc）します。TLSFプールのフラグメンテーションによって別の領域で再確保を行うか、それともメモリを拡張するだけで収めれるか分かれることがあります。また、再確保するメモリサイズに比べてプールの現状確保出来るメモリ量が足りなかったら、再確保は失敗します。</li><li><code>tlsf_calloc</code>：Cライブラリーの<code>calloc</code>と一緒です。メモリ確保が成功したら、メモリ空間を0で初期化してくれます。</li><li><code>tlsf_free</code>：TLSFメモリプールから確保したメモリを解除します。</li></ul><h1 id=説明>説明<a hidden class=anchor aria-hidden=true href=#説明>#</a></h1><h2 id=1tlsf_raw_create>1.<code>tlsf_raw_create</code><a hidden class=anchor aria-hidden=true href=#1tlsf_raw_create>#</a></h2><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>if</span> <span class=p>(</span><span class=n>mem_pool_size</span> <span class=o>&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tlsf_raw_t</span><span class=p>)</span> <span class=o>+</span> <span class=n>block_header_t</span><span class=o>::</span><span class=n>sk_block_header_ovhd</span> <span class=o>*</span> <span class=mi>8</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>return</span> <span class=n>error_info</span><span class=p>{</span> <span class=n>NOT_SUFFICIENT_MEM_SIZE</span> <span class=p>};</span>
<span class=p>}</span>
</code></pre></div><p>確保しようとするTLSFメモリプールのサイズが一定値以上かをチェックします。<code>tlsf_raw_t</code>はTLSFメモリプールを管理する構造体です。<code>block_header_t</code>は確保されるオブジェクトのメモリ空間の前に出てくるヘッダーです。現在オブジェクトのメモリサイズがいくらか、前、次のメモリブロックはどこに位置しているかについて情報を持ちます。</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>tlsf_raw_t</span> <span class=k>final</span>
<span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=n>u64</span> <span class=n>k_fli_max</span> <span class=o>=</span> <span class=mi>30</span><span class=p>;</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=n>u64</span> <span class=n>k_fli_offset</span> <span class=o>=</span> <span class=mi>6</span><span class=p>;</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=n>u64</span> <span class=n>k_fli_real</span> <span class=o>=</span> <span class=n>k_fli_max</span> <span class=o>-</span> <span class=n>k_fli_offset</span><span class=p>;</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=n>u64</span> <span class=n>k_sli_log2_max</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=n>u64</span> <span class=n>k_sli_max</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>k_sli_log2_max</span><span class=p>;</span>

    <span class=n>u32</span>             <span class=n>m_tlsf_signature</span><span class=p>;</span>
    <span class=n>area_info_t</span><span class=o>*</span>    <span class=n>m_area_head</span><span class=p>;</span>
    <span class=n>u32</span>             <span class=n>m_fl_bitmap</span><span class=p>;</span>
    <span class=n>u32</span>             <span class=n>m_sl_bitmap</span><span class=p>[</span><span class=n>k_fli_real</span><span class=p>];</span>
    <span class=n>block_header_t</span><span class=o>*</span> <span class=n>mp_matrix</span><span class=p>[</span><span class=n>k_fli_real</span><span class=p>][</span><span class=n>k_sli_max</span><span class=p>];</span>
    <span class=n>u64</span>             <span class=n>m_max_mem</span><span class=p>;</span> <span class=c1>// いらなくて良し
</span><span class=c1></span>    <span class=n>u64</span>             <span class=n>m_used_mem</span><span class=p>;</span>

    <span class=c1>// 以下メンバー関数宣言
</span><span class=c1></span><span class=p>};</span>
</code></pre></div><p><code>tlsf_raw_t</code>で注目する変数は、<code>m_fl_bitmap</code>と<code>m_sl_bitmap</code>、そして<code>mp_matrix</code>です。</p><p><code>fl_bitmap</code>と<code>sl_bitmap</code>はメモリ解除されて使えるブロックのハッシュ情報をビット単位で刻んで入れられるようになった変数らしいです。TLSFはメモリの要求される容量によって２階層のリストから適度な空きブロックへのポインターを持ってこれるようになってるので、この変数でFirst-IndexとSecond-Indexを取得するようになってます。この変数を用いた取得のやり方は<code>find_suitable_block</code>関数で見れます。</p><p><code>mp_matrix</code>はメモリ解除されたメモリブロックのポインター先を持ちます。<code>find_suitable_block</code>の中で返されたFirst-IndexとSecond-Index数値でこの配列変数から割当をするブロックのヘッダーを取得します。</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>block_header_t</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=n>u64</span> <span class=n>sk_min_block_size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>free_ptr_t</span><span class=p>);</span>
    <span class=k>static</span> <span class=k>const</span> <span class=n>u64</span> <span class=n>sk_block_header_ovhd</span><span class=p>;</span>

    <span class=k>static</span> <span class=k>constexpr</span> <span class=n>u8</span> <span class=n>sk_free_block</span> <span class=o>=</span> <span class=mh>0x01</span><span class=p>;</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=n>u8</span> <span class=n>sk_prev_free</span> <span class=o>=</span> <span class=mh>0x02</span><span class=p>;</span>

    <span class=n>block_header_t</span><span class=o>*</span> <span class=n>p_prev_header</span><span class=p>;</span>
    <span class=n>u64</span>             <span class=n>stored_size</span><span class=p>;</span>
    <span class=k>union</span>
    <span class=p>{</span>
        <span class=n>free_ptr_t</span>      <span class=n>free_ptr</span><span class=p>;</span>
        <span class=n>block_buffer_t</span>  <span class=n>buffer</span><span class=p>;</span>
    <span class=p>}</span> <span class=n>ptr</span><span class=p>;</span>
  
    <span class=c1>// 以下メンバー関数宣言
</span><span class=c1></span><span class=p>};</span>
</code></pre></div><p><code>block_header_t</code>は確保された（または解除した後の）メモリブロックについての情報を持ちます。実際のデータバッファは<code>ptr.buffer</code>から始まり、<code>stored_size >> 2</code>バイトまで続きます。もしブロックが解除した状態なら<code>ptr</code>は<code>free_ptr</code>に前と後のブロックヘッダー情報を入れるようになっています。</p><p>また、<code>stored_size</code>はデータバッファのサイズだけではなく、0番と1番のビットに自分がフリーブロックなのか、そして前のブロックがフリーかをフラグとして設定するようにしています。なので、TLSFの中で確保されたデータバッファのサイズは必ず4倍の数値になります。（こうしてキャッシュラインなどが整頓される効果も得られます。）</p><p><code>tlsf_raw_create</code>関数にまた戻ってTLSFシグニチャーを設定し、<code>memset</code>で0に初期化を行います。</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>block_header_t</span><span class=o>*</span> <span class=n>p_area_info_bhdr</span> <span class=o>=</span> <span class=n>process_area</span><span class=p>(</span>
    <span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>get_first_block_header</span><span class=p>(),</span> 
    <span class=n>get_rddn_size_default</span><span class=p>(</span><span class=n>mem_pool_size</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tlsf_raw_t</span><span class=p>))</span>
<span class=p>);</span>
<span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>m_area_head</span> <span class=o>=</span> <span class=p>(</span><span class=n>area_info_t</span><span class=o>*</span><span class=p>)</span><span class=n>p_area_info_bhdr</span><span class=o>-&gt;</span><span class=n>get_buffer</span><span class=p>();</span>
<span class=c1>// make first block of tlsf pool.
</span><span class=c1></span><span class=n>block_header_t</span><span class=o>*</span> <span class=n>p_first_bhdr</span> <span class=o>=</span> <span class=n>p_area_info_bhdr</span><span class=o>-&gt;</span><span class=n>get_next_block</span><span class=p>();</span>
<span class=n>tlsf_free</span><span class=p>(</span><span class=n>p_first_bhdr</span><span class=o>-&gt;</span><span class=n>get_buffer</span><span class=p>(),</span> <span class=n>p_tlsf</span><span class=p>);</span>
</code></pre></div><p>TLSFメモリプールは普通のメモリプールとは違って扱うメモリ空間自体を拡張することが出来ます。ただし、拡張した別途のメモリ領域のアドレスは既存のTLSFと連続してない可能性があるので、リンクリスト（連結リスト）でアドレスを保持する必要があります。</p><p>そのため、<code>tlsf_raw_t</code>の後には追加メモリ領域が保持するブロックのアドレス情報を持つ構造体、<code>area_info_t</code>がついて来ます。（ただし、<code>area_info_t</code>自体も特殊ブロックのバッファ部分に置かれるようになっています。）</p><h3 id=process_area><code>process_area()</code><a hidden class=anchor aria-hidden=true href=#process_area>#</a></h3><p><code>process_area()</code>関数は、TLSFプールの初期メモリブロックを設定する関数です。初期で設定されるメモリブロックは以下となります。</p><ul><li><code>p_ib</code>：<code>area_info_t</code>のブロック：別途のメモリ領域を使えるようにする。</li><li><code>p_next_b</code>：任意オブジェクトメモリ確保のためのブロック</li><li><code>p_next_next_b</code>：メモリ領域の終わりを示すブロック（バッファのサイズは0）</li></ul><p><code>p_next_b</code>のバッファサイズを初期化するとき、または<code>p_ib</code>のバッファサイズを設定する時には必ずメモリが整列されなければならないため、<code>get_rddn_size_default()</code>と<code>get_rddn_size_default()</code>関数を使ってメモリサイズを調整します。</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>block_header_t</span><span class=o>*</span> <span class=n>p_next_b</span> <span class=o>=</span> <span class=n>p_ib</span><span class=o>-&gt;</span><span class=n>get_next_block</span><span class=p>();</span>
<span class=n>p_next_b</span><span class=o>-&gt;</span><span class=n>set_buffer_size</span><span class=p>(</span><span class=n>get_rddn_size_default</span><span class=p>(</span>
    <span class=n>size</span> <span class=o>-</span> <span class=mi>3</span> <span class=o>*</span> <span class=n>block_header_t</span><span class=o>::</span><span class=n>sk_min_block_size</span> <span class=o>-</span> <span class=n>p_ib</span><span class=o>-&gt;</span><span class=n>get_block_size</span><span class=p>())</span>
<span class=p>);</span>
</code></pre></div><p><code>size - 3 * block_header_t::sk_min_block_size - p_ib->get_block_size()</code>は、まずTLSF構造体を除外したメモリサイズに３つのブロックヘッダーサイズと、<code>area_info_t</code>分のメモリサイズを引いた、TLSFプールが生成された後で使えるメモリ量を示します。</p><hr><p>本関数に戻って、</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++> <span class=c1>// make first block of tlsf pool.
</span><span class=c1></span> <span class=n>block_header_t</span><span class=o>*</span> <span class=n>p_first_bhdr</span> <span class=o>=</span> <span class=n>p_area_info_bhdr</span><span class=o>-&gt;</span><span class=n>get_next_block</span><span class=p>();</span>
 <span class=n>tlsf_free</span><span class=p>(</span><span class=n>p_first_bhdr</span><span class=o>-&gt;</span><span class=n>get_buffer</span><span class=p>(),</span> <span class=n>p_tlsf</span><span class=p>);</span>
</code></pre></div><p><code>p_next_b</code>部分のブロックがまだ使える状態ではないので、TLSFを管理する構造体の<code>bitmap</code>変数と<code>matrix</code>にアドレスをフラグを更新して使えるため<code>free</code>関数を呼びます。最後には<code>p_next_b</code>の使えるメモリ量を返して終わりです。</p><h2 id=2tlsf_malloc>2.<code>tlsf_malloc</code><a hidden class=anchor aria-hidden=true href=#2tlsf_malloc>#</a></h2><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>mem_size</span> <span class=o>=</span> <span class=n>calc_min_memblock_size</span><span class=p>(</span><span class=n>mem_size</span><span class=p>);</span>
<span class=k>const</span> <span class=k>auto</span> <span class=n>rs_search</span>   <span class=o>=</span> <span class=n>mapping_search</span><span class=p>(</span><span class=n>mem_size</span><span class=p>);</span>
<span class=k>const</span> <span class=k>auto</span> <span class=n>rs_suitable</span> <span class=o>=</span> <span class=n>find_suitable_block</span><span class=p>(</span><span class=n>p_tlsf_pool</span><span class=p>,</span> <span class=n>rs_search</span><span class=p>.</span><span class=n>flv</span><span class=p>,</span> <span class=n>rs_search</span><span class=p>.</span><span class=n>slv</span><span class=p>);</span>

<span class=n>block_header_t</span><span class=o>*</span> <span class=n>p_b</span> <span class=o>=</span> <span class=n>rs_suitable</span><span class=p>.</span><span class=n>p_block_hdr</span><span class=p>;</span>
<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>p_b</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=k>nullptr</span><span class=p>;</span> <span class=p>}</span>
<span class=k>if</span> <span class=p>(</span><span class=n>rs_suitable</span><span class=p>.</span><span class=n>flv</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span> <span class=o>||</span> <span class=n>rs_suitable</span><span class=p>.</span><span class=n>slv</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=k>nullptr</span><span class=p>;</span> <span class=p>}</span>
</code></pre></div><p>まず、TLSFプールから適当なメモリブロックを探します。一次に<code>mapping_search</code>関数で、First-IndexとSecond-Indexを取得し、最終に<code>find_suitable_block</code>で取得出来たブロックヘッダーのポインターと最終First-Index、Second-Indexを持ってくるようにします。</p><h3 id=mapping_search><code>mapping_search()</code><a hidden class=anchor aria-hidden=true href=#mapping_search>#</a></h3><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>const</span> <span class=k>auto</span> <span class=n>fl_sl</span> <span class=o>=</span> <span class=n>mapping_insert</span><span class=p>(</span><span class=n>size</span><span class=p>);</span>
<span class=n>result</span><span class=p>.</span><span class=n>flv</span> <span class=o>=</span> <span class=n>fl_sl</span><span class=p>.</span><span class=n>first_lv</span><span class=p>;</span>
<span class=n>result</span><span class=p>.</span><span class=n>slv</span> <span class=o>=</span> <span class=n>fl_sl</span><span class=p>.</span><span class=n>scnd_lv</span><span class=p>;</span>
</code></pre></div><p>まず<code>mapping_insert()</code>という関数を使って、First-Level Index（<code>flv</code>）とSecond-Level Index（<code>slv</code>）を取得します。</p><h3 id=mapping_insert><code>mapping_insert()</code><a hidden class=anchor aria-hidden=true href=#mapping_insert>#</a></h3><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>if</span> <span class=p>(</span><span class=n>size</span> <span class=o>&lt;</span> <span class=n>k_small_block</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>result</span><span class=p>.</span><span class=n>first_lv</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>result</span><span class=p>.</span><span class=n>scnd_lv</span>  <span class=o>=</span> <span class=n>size</span> <span class=o>/</span> <span class=p>(</span><span class=n>k_small_block</span> <span class=o>/</span> <span class=n>tlsf_raw_t</span><span class=o>::</span><span class=n>k_sli_max</span><span class=p>);</span>
<span class=p>}</span>
<span class=k>else</span>
<span class=p>{</span>
    <span class=n>result</span><span class=p>.</span><span class=n>first_lv</span> <span class=o>=</span> <span class=n>ms_bit</span><span class=p>(</span><span class=n>size</span><span class=p>);</span>
    <span class=n>result</span><span class=p>.</span><span class=n>scnd_lv</span>  <span class=o>=</span> 
        <span class=p>(</span><span class=n>size</span> <span class=o>&gt;&gt;</span> <span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=n>first_lv</span> <span class=o>-</span> <span class=n>tlsf_raw_t</span><span class=o>::</span><span class=n>k_sli_log2_max</span><span class=p>))</span> 
      <span class=o>-</span> <span class=n>tlsf_raw_t</span><span class=o>::</span><span class=n>k_sli_max</span><span class=p>;</span>
    <span class=n>result</span><span class=p>.</span><span class=n>first_lv</span> <span class=o>-=</span> <span class=n>tlsf_raw_t</span><span class=o>::</span><span class=n>k_fli_offset</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>この関数でFirst-Level IndexとSecond-Level Indexを持ってきます。ところで、ここで<code>size</code>は8Byte整列されたサイズです。そして定数は以下となります。</p><ul><li>k_small_block：128Byte</li><li>tlsf_raw_t::k_sli_max：32</li><li>tlsf_raw_t::k_sli_log2_max：5</li><li>tlsf_raw_t::k_fli_offset：6（2^6 == 128Bytes）</li></ul><p>まず、<code>size</code>が128Byte以下になると、TLSFプールで提供されてるメモリブロックの中で一番小さいものが確保されるようになります。しかし、それ以上になるともっと適切なFLIとSLIの数値を持って来るため、下のようなアルゴリズムを通します。
$$
\begin{align}
\text{mapping}(\text{size}) &\rightarrow (f, s) \\\<br>\text{mapping}(\text{size}) &=
\begin{cases}
f := \lfloor log_2(size) \rfloor \\\<br>s := size * \frac{2^{SLI}}{2^f} - 2^{SLI}
\end{cases}
\end{align}
$$
真ん中の<code>result.first_lv - tlsf_raw_t::k_sli_log2_max</code>は以下となります。
$$
\alpha = log_2(2^{f - SLI})
$$
上の関数では128Byte以下のブロックは全部FLIが0になるし、128Byte以上から1以上のインデックスを持つため、6を引く必要があります。最後に<code>first_lv</code>に6を引くのはそのためです。</p><h3 id=find_suitable_block><code>find_suitable_block()</code><a hidden class=anchor aria-hidden=true href=#find_suitable_block>#</a></h3><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>const</span> <span class=n>u32</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>m_sl_bitmap</span><span class=p>[</span><span class=n>fl</span><span class=p>]</span> <span class=o>&amp;</span> <span class=p>(</span><span class=o>~</span><span class=mi>0</span> <span class=o>&lt;&lt;</span> <span class=n>sl</span><span class=p>);</span>
<span class=k>if</span> <span class=p>(</span><span class=n>tmp</span><span class=p>)</span>
<span class=p>{</span>   <span class=c1>// if tmp is not 0.
</span><span class=c1></span>    <span class=n>result</span><span class=p>.</span><span class=n>flv</span> <span class=o>=</span> <span class=n>fl</span><span class=p>;</span>
    <span class=n>result</span><span class=p>.</span><span class=n>slv</span> <span class=o>=</span> <span class=n>ls_bit</span><span class=p>(</span><span class=n>tmp</span><span class=p>);</span>
    <span class=n>result</span><span class=p>.</span><span class=n>p_block_hdr</span> <span class=o>=</span> <span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>mp_matrix</span><span class=p>[</span><span class=n>result</span><span class=p>.</span><span class=n>flv</span><span class=p>][</span><span class=n>result</span><span class=p>.</span><span class=n>slv</span><span class=p>];</span>
<span class=p>}</span>
<span class=k>else</span>
<span class=p>{</span>   <span class=c1>// if tmp is 0
</span><span class=c1></span>    <span class=n>result</span><span class=p>.</span><span class=n>flv</span> <span class=o>=</span> <span class=n>ls_bit</span><span class=p>(</span><span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>m_fl_bitmap</span> <span class=o>&amp;</span> <span class=p>(</span><span class=o>~</span><span class=mi>0</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>fl</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)));</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=n>flv</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>result</span><span class=p>.</span><span class=n>slv</span> <span class=o>=</span> <span class=n>ls_bit</span><span class=p>(</span><span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>m_sl_bitmap</span><span class=p>[</span><span class=n>result</span><span class=p>.</span><span class=n>flv</span><span class=p>]);</span>
        <span class=n>result</span><span class=p>.</span><span class=n>p_block_hdr</span> <span class=o>=</span> <span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>mp_matrix</span><span class=p>[</span><span class=n>result</span><span class=p>.</span><span class=n>flv</span><span class=p>][</span><span class=n>result</span><span class=p>.</span><span class=n>slv</span><span class=p>];</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p><code>find_suitable_block()</code>関数は、<code>fl</code>と<code>sl</code>を使って最終的にマトリックスに登録されている、要請されたサイズより大きいか同じの適当なメモリブロックを返します。まず、最初にはSLI（Second-Level Index）を探索し、そしてFLIを探索する形でフリーブロックが位置されているFirst-IndexとSecond-Indexを取得します。そして、TLSF管理構造体にある配列から空いているブロックのアドレスを持って来るようにします。</p><p>ただし、この<code>flv</code>と<code>slv</code>が0より低い値になると適合なブロック探しは失敗になります。</p><h3 id=ls_bit--ms_bit><code>ls_bit()</code> & <code>ms_bit()</code><a hidden class=anchor aria-hidden=true href=#ls_bit--ms_bit>#</a></h3><ul><li>ls_bit：Find First Set（最初の１の値を持つビットの番地）を探します。</li><li>ms_bit：Find Last Set（最後に１の値を持つビットの番地）を探します。</li></ul><p>普通のアルゴリズムでも値を計算することは出来るんですが、この関数の中ではもっとビットを早く計算するためにテーブルを使ってます。</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>static</span> <span class=k>constexpr</span> <span class=n>i32</span> <span class=n>sk_table</span><span class=p>[</span><span class=mi>256</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>
    <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> 
     <span class=c1>// ...
</span><span class=c1></span>     <span class=mi>7</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>7</span>
<span class=p>};</span>

<span class=c1>// in ms_bit (tls)
</span><span class=c1></span><span class=k>const</span> <span class=n>u32</span> <span class=n>x</span> <span class=o>=</span> <span class=p>(</span><span class=n>u32</span><span class=p>)</span><span class=n>val</span><span class=p>;</span>
<span class=k>const</span> <span class=n>u32</span> <span class=n>a</span> <span class=o>=</span> <span class=p>[](</span><span class=k>const</span> <span class=n>u32</span> <span class=n>v</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>v</span> <span class=o>&lt;=</span> <span class=mh>0xFFFF</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>v</span> <span class=o>&lt;=</span> <span class=mh>0xFF</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=mi>8</span><span class=p>;</span> <span class=p>}</span>
    <span class=k>else</span>             <span class=p>{</span> <span class=k>return</span> <span class=n>v</span> <span class=o>&lt;=</span> <span class=mh>0xFFFFFF</span> <span class=o>?</span> <span class=mi>16</span> <span class=o>:</span> <span class=mi>24</span><span class=p>;</span> <span class=p>}</span>
<span class=p>}(</span><span class=n>x</span><span class=p>);</span>
<span class=k>return</span> <span class=n>sk_table</span><span class=p>[</span><span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=n>a</span><span class=p>]</span> <span class=o>+</span> <span class=n>a</span><span class=p>;</span>
</code></pre></div><hr><p>malloc関数に戻って…</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>extract_block_hdr</span><span class=p>(</span><span class=n>p_b</span><span class=p>,</span> <span class=n>p_tlsf_pool</span><span class=p>,</span> <span class=n>rs_suitable</span><span class=p>.</span><span class=n>flv</span><span class=p>,</span> <span class=n>rs_suitable</span><span class=p>.</span><span class=n>slv</span><span class=p>);</span>

<span class=n>block_header_t</span><span class=o>*</span> <span class=n>p_nb</span> <span class=o>=</span> <span class=n>p_b</span><span class=o>-&gt;</span><span class=n>get_next_block</span><span class=p>();</span>
<span class=n>mem_size</span> <span class=o>=</span> <span class=n>rs_search</span><span class=p>.</span><span class=n>rdup_size</span><span class=p>;</span>
</code></pre></div><p>有効なフリーメモリブロックを取得した後には、それをマトリックスから外す必要があります。そして、ブロックと連結されている（リンクリストとして）メモリブロックがある場合には、そのブロックをマトリックスに登録する必要があります。<code>extract_block_hdr</code>はそれをやってくれます。</p><h3 id=extract_block_hdr><code>extract_block_hdr()</code><a hidden class=anchor aria-hidden=true href=#extract_block_hdr>#</a></h3><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++> <span class=n>block_header_t</span><span class=o>*</span> <span class=n>p_item</span> <span class=o>=</span> 
     <span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>mp_matrix</span><span class=p>[</span><span class=n>final_fl</span><span class=p>][</span><span class=n>final_sl</span><span class=p>]</span> <span class=o>=</span> <span class=n>p_b</span><span class=o>-&gt;</span><span class=n>get_free_ptrs</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>p_next</span><span class=p>;</span>
 <span class=k>if</span> <span class=p>(</span><span class=n>p_item</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span>
 <span class=p>{</span>
     <span class=n>p_item</span><span class=o>-&gt;</span><span class=n>get_free_ptrs</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>p_prev</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
 <span class=p>}</span>
 <span class=k>else</span>
 <span class=p>{</span>
     <span class=n>clear_bit</span><span class=p>(</span><span class=n>final_sl</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>m_sl_bitmap</span><span class=p>[</span><span class=n>final_fl</span><span class=p>]);</span>
     <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>m_sl_bitmap</span><span class=p>[</span><span class=n>final_fl</span><span class=p>])</span>
     <span class=p>{</span>
         <span class=n>clear_bit</span><span class=p>(</span><span class=n>final_fl</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>m_fl_bitmap</span><span class=p>);</span>
     <span class=p>}</span>
 <span class=p>}</span>
</code></pre></div><p>この関数は、フリーブロック<code>p_b</code>に連結しているまた新しいフリーブロックを同じFirst、Second-Indexに連結して次のメモリ確保に対する準備を行うことをやってくれます。またインデックスに該当する新しいフリーブロックがない場合にはTLSF構造体からFirst、Second-Indexを参照するためのビットマップ（<code>m_sl_bitmap</code>、<code>m_fl_bitmap</code>）から自分のインデックス値が取得出来ないようにリセットします。</p><hr><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>if</span> <span class=p>(</span><span class=n>tmp_size</span> <span class=o>&gt;=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>block_header_t</span><span class=p>))</span>
<span class=p>{</span>   <span class=c1>// 分割する。
</span><span class=c1></span>    <span class=n>block_header_t</span><span class=o>*</span> <span class=n>p_b2</span> <span class=o>=</span> <span class=p>(</span><span class=n>block_header_t</span><span class=o>*</span><span class=p>)((</span><span class=n>u8</span><span class=o>*</span><span class=p>)</span><span class=n>p_b</span><span class=o>-&gt;</span><span class=n>get_buffer</span><span class=p>()</span> <span class=o>+</span> <span class=n>mem_size</span><span class=p>);</span>
    <span class=c1>// Set p_b2 information...
</span><span class=c1></span>  
    <span class=n>p_nb</span><span class=o>-&gt;</span><span class=n>set_prev_bhdr</span><span class=p>(</span><span class=n>p_b2</span><span class=p>);</span>
    <span class=k>const</span> <span class=k>auto</span> <span class=p>[</span><span class=n>split_fl</span><span class=p>,</span> <span class=n>split_sl</span><span class=p>]</span> <span class=o>=</span> <span class=n>mapping_insert</span><span class=p>(</span><span class=n>tmp_size</span><span class=p>);</span>
    <span class=n>insert_block</span><span class=p>(</span><span class=n>p_b2</span><span class=p>,</span> <span class=n>p_tlsf_pool</span><span class=p>,</span> <span class=n>split_fl</span><span class=p>,</span> <span class=n>split_sl</span><span class=p>);</span>
  
    <span class=c1>// p_b2の設定が終わったら、p_bのサイズを更新する。
</span><span class=c1></span><span class=p>}</span>
<span class=k>else</span>
<span class=p>{</span>
    <span class=n>p_nb</span><span class=o>-&gt;</span><span class=n>set_prev_freed</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>最後に、<code>tmp_size := p_b->block_size - mem_size</code>を計算し、確保されたメモリの量に対して新しい空きブロックが作れたら作るようにします。空きブロックが作られたら、<code>insert_block()</code>関数でTLSF構造体の空きブロック管理マトリックスに入れるようにします。</p><h3 id=insert_block><code>insert_block()</code><a hidden class=anchor aria-hidden=true href=#insert_block>#</a></h3><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>free_ptr_t</span><span class=o>*</span> <span class=n>p_free_ptr</span> <span class=o>=</span> <span class=n>p_b</span><span class=o>-&gt;</span><span class=n>get_free_ptrs</span><span class=p>();</span>
<span class=n>p_free_ptr</span><span class=o>-&gt;</span><span class=n>p_prev</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
<span class=n>p_free_ptr</span><span class=o>-&gt;</span><span class=n>p_next</span> <span class=o>=</span> <span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>mp_matrix</span><span class=p>[</span><span class=n>final_fl</span><span class=p>][</span><span class=n>final_sl</span><span class=p>];</span>

<span class=k>if</span> <span class=p>(</span><span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>mp_matrix</span><span class=p>[</span><span class=n>final_fl</span><span class=p>][</span><span class=n>final_sl</span><span class=p>])</span>
<span class=p>{</span>
    <span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>mp_matrix</span><span class=p>[</span><span class=n>final_fl</span><span class=p>][</span><span class=n>final_sl</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>get_free_ptrs</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>p_prev</span><span class=o>=</span> <span class=n>p_b</span><span class=p>;</span>
<span class=p>}</span>
<span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>mp_matrix</span><span class=p>[</span><span class=n>final_fl</span><span class=p>][</span><span class=n>final_sl</span><span class=p>]</span> <span class=o>=</span> <span class=n>p_b</span><span class=p>;</span>
</code></pre></div><p>空きブロック<code>p_b</code>を空きブロック管理マトリックスに入れます。ただし、指定されたインデックスにはすでに空きブロックがあるかもしれません。そのときにはリンクリストで２つを繋ぐようにします。こうすることで、<code>extract_block_hdr</code>などで接近した複数のブロックが一つずつ抜かれて使えるようになります。</p><hr><p>最後に、取得出来た空きブロック<code>p_b</code>の設定をし、リターン値として返せば終わります。</p><h2 id=3tlsf_realloc>3.<code>tlsf_realloc</code><a hidden class=anchor aria-hidden=true href=#3tlsf_realloc>#</a></h2><p>TLSFの<code>realloc</code>アルゴリズムは３つの分岐に分かれます。</p><ol><li>再確保するサイズが既存のサイズより小さく、使ってるブロックが使い回せる場合</li><li>確保するサイズは既存より大きいが、隣接する次のブロックを使って確保できる場合</li><li>１も２も当てはまらなく、<code>malloc</code>をして完全に新しいブロックを確保する場合</li></ol><h3 id=1-サイズが既存のサイズより小さい時>1. サイズが既存のサイズより小さい時<a hidden class=anchor aria-hidden=true href=#1-サイズが既存のサイズより小さい時>#</a></h3><p>まず、サイズが小さくて隣接したブロックが空きブロックの場合には、その空きブロックと今の余りのメモリバッファを合わせて大きい空きブロックが作れるかを判断することが出来ます。以下のロジックではそれを判断し、満足したら併合するようにしています。</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>if</span> <span class=p>(</span><span class=n>p_next_bhdr</span><span class=o>-&gt;</span><span class=n>is_freed</span><span class=p>())</span>
<span class=p>{</span>
    <span class=k>const</span> <span class=k>auto</span> <span class=p>[</span><span class=n>next_fl</span><span class=p>,</span> <span class=n>next_sl</span><span class=p>]</span> <span class=o>=</span> <span class=n>mapping_insert</span><span class=p>(</span><span class=n>p_next_bhdr</span><span class=o>-&gt;</span><span class=n>get_block_size</span><span class=p>());</span>
    <span class=n>extract_block</span><span class=p>(</span><span class=n>p_next_bhdr</span><span class=p>,</span> <span class=n>p_tlsf</span><span class=p>,</span> <span class=n>next_fl</span><span class=p>,</span> <span class=n>next_sl</span><span class=p>);</span>

    <span class=n>old_size</span> <span class=o>+=</span> <span class=n>p_next_bhdr</span><span class=o>-&gt;</span><span class=n>get_block_size_with_header</span><span class=p>();</span>
    <span class=n>p_next_bhdr</span> <span class=o>=</span> <span class=n>p_next_bhdr</span><span class=o>-&gt;</span><span class=n>get_next_block</span><span class=p>();</span>
<span class=p>}</span>

<span class=n>u64</span> <span class=n>new_free_size</span> <span class=o>=</span> <span class=n>old_size</span> <span class=o>-</span> <span class=n>new_size</span><span class=p>;</span>
<span class=k>if</span> <span class=p>(</span><span class=n>new_free_size</span> <span class=o>&gt;=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>block_header_t</span><span class=p>))</span>
<span class=p>{</span>
    <span class=n>new_free_size</span> <span class=o>-=</span> <span class=n>block_header_t</span><span class=o>::</span><span class=n>sk_block_header_ovhd</span><span class=p>;</span>
    <span class=k>auto</span><span class=o>*</span> <span class=n>p_new_bhdr</span> <span class=o>=</span> <span class=p>(</span><span class=n>block_header_t</span><span class=o>*</span><span class=p>)((</span><span class=n>u8</span><span class=o>*</span><span class=p>)</span><span class=n>p_bhdr</span><span class=o>-&gt;</span><span class=n>get_buffer</span><span class=p>()</span> <span class=o>+</span> <span class=n>new_size</span><span class=p>);</span>
    <span class=c1>// p_new_bhdrの設定
</span><span class=c1></span>    <span class=c1>// p_next_next_bhdr (既存p_next_bhdrの次ブロック)をp_newに連結
</span><span class=c1></span>　　 <span class=c1>// p_new_bhdrをマトリックスに挿入
</span><span class=c1></span>    <span class=k>const</span> <span class=k>auto</span> <span class=p>[</span><span class=n>new_fl</span><span class=p>,</span> <span class=n>new_sl</span><span class=p>]</span> <span class=o>=</span> <span class=n>mapping_insert</span><span class=p>(</span><span class=n>new_free_size</span><span class=p>);</span>
    <span class=n>insert_block</span><span class=p>(</span><span class=n>p_new_bhdr</span><span class=p>,</span> <span class=n>p_tlsf</span><span class=p>,</span> <span class=n>new_fl</span><span class=p>,</span> <span class=n>new_sl</span><span class=p>);</span>
    <span class=c1>// 最後にp_bの情報を更新
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><h3 id=extract_block><code>extract_block()</code><a hidden class=anchor aria-hidden=true href=#extract_block>#</a></h3><p>この関数は<code>extract_block_hdr()</code>に似ていますが、自分の前後ブロックを連結させて、空きブロックマトリックスから自分を抜いて参照させないようにしています。ただし、マトリックスリストに先頭に見えないとマトリックスでの削除はされません。</p><p>なぜ先頭に出てからこそ削除できるかはわからないですが、多分マトリックスに接近する時に必要となるFirst-IndexとSecond-Indexが前後同じになるから、わざとリンクリストを一通り回って削除するかを判断しなくても済ませるのではないかと思ってます。（間違ってるかもしれません）</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>if</span> <span class=p>(</span><span class=n>p_free_ptr</span><span class=o>-&gt;</span><span class=n>p_next</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>p_free_ptr</span><span class=o>-&gt;</span><span class=n>p_next</span><span class=o>-&gt;</span><span class=n>get_free_ptrs</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>p_prev</span> <span class=o>=</span> <span class=n>p_free_ptr</span><span class=o>-&gt;</span><span class=n>p_prev</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>if</span> <span class=p>(</span><span class=n>p_free_ptr</span><span class=o>-&gt;</span><span class=n>p_prev</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>p_free_ptr</span><span class=o>-&gt;</span><span class=n>p_prev</span><span class=o>-&gt;</span><span class=n>get_free_ptrs</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>p_next</span> <span class=o>=</span> <span class=n>p_free_ptr</span><span class=o>-&gt;</span><span class=n>p_next</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>if</span> <span class=p>(</span><span class=k>auto</span><span class=o>*</span> <span class=n>p_matrix_b</span> <span class=o>=</span> <span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>mp_matrix</span><span class=p>[</span><span class=n>final_fl</span><span class=p>][</span><span class=n>final_sl</span><span class=p>];</span> <span class=n>p_matrix_b</span> <span class=o>==</span> <span class=n>p_b</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>p_matrix_b</span> <span class=o>=</span> <span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>mp_matrix</span><span class=p>[</span><span class=n>final_fl</span><span class=p>][</span><span class=n>final_sl</span><span class=p>]</span> <span class=o>=</span> <span class=n>p_free_ptr</span><span class=o>-&gt;</span><span class=n>p_next</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>p_matrix_b</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>clear_bit</span><span class=p>(</span><span class=n>final_sl</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>m_sl_bitmap</span><span class=p>[</span><span class=n>final_fl</span><span class=p>]);</span>
        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>m_sl_bitmap</span><span class=p>[</span><span class=n>final_fl</span><span class=p>])</span>
        <span class=p>{</span>
            <span class=n>clear_bit</span><span class=p>(</span><span class=n>final_fl</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>m_fl_bitmap</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><hr><h3 id=2-サイズが既存より大きいが隣接空きブロックで解決できる場合>2. サイズが既存より大きいが、隣接空きブロックで解決できる場合<a hidden class=anchor aria-hidden=true href=#2-サイズが既存より大きいが隣接空きブロックで解決できる場合>#</a></h3><p>隣接した空きブロックをくっつけることでサイズの問題が解決できれば、空きブロックをマトリックスから抜いてくっつけて、そして余ったメモリ空間を新しい空きブロックとして作ります。</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>if</span> <span class=p>(</span><span class=n>new_size</span> <span class=o>&lt;=</span> <span class=p>(</span><span class=n>old_size</span> <span class=o>+</span> <span class=n>p_next_bhdr</span><span class=o>-&gt;</span><span class=n>get_block_size</span><span class=p>()))</span>
<span class=p>{</span>
    <span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>m_used_mem</span> <span class=o>-=</span> <span class=n>p_bhdr</span><span class=o>-&gt;</span><span class=n>get_block_size_with_header</span><span class=p>();</span>

    <span class=k>const</span> <span class=k>auto</span> <span class=p>[</span><span class=n>next_fl</span><span class=p>,</span> <span class=n>next_sl</span><span class=p>]</span> <span class=o>=</span> <span class=n>mapping_insert</span><span class=p>(</span><span class=n>p_next_bhdr</span><span class=o>-&gt;</span><span class=n>get_block_size</span><span class=p>());</span>
    <span class=n>extract_block</span><span class=p>(</span><span class=n>p_next_bhdr</span><span class=p>,</span> <span class=n>p_tlsf</span><span class=p>,</span> <span class=n>next_fl</span><span class=p>,</span> <span class=n>next_sl</span><span class=p>);</span>
    <span class=c1>// ...
</span><span class=c1></span>    <span class=n>p_next_bhdr</span> <span class=o>=</span> <span class=n>p_bhdr</span><span class=o>-&gt;</span><span class=n>get_next_block</span><span class=p>();</span>
    <span class=c1>// ...
</span><span class=c1></span>
    <span class=n>u64</span> <span class=n>new_free_size</span> <span class=o>=</span> <span class=n>p_bhdr</span><span class=o>-&gt;</span><span class=n>get_block_size</span><span class=p>()</span> <span class=o>-</span> <span class=n>new_size</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>new_free_size</span> <span class=o>&gt;=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>block_header_t</span><span class=p>))</span>
    <span class=p>{</span>
        <span class=n>new_free_size</span> <span class=o>-=</span> <span class=n>block_header_t</span><span class=o>::</span><span class=n>sk_block_header_ovhd</span><span class=p>;</span>
        <span class=k>auto</span><span class=o>*</span> <span class=n>p_new_bhdr</span> <span class=o>=</span> <span class=p>(</span><span class=n>block_header_t</span><span class=o>*</span><span class=p>)((</span><span class=n>u8</span><span class=o>*</span><span class=p>)</span><span class=n>p_bhdr</span><span class=o>-&gt;</span><span class=n>get_buffer</span><span class=p>()</span> <span class=o>+</span> <span class=n>new_size</span><span class=p>);</span>
        <span class=c1>// ...
</span><span class=c1></span>        <span class=c1>// ...
</span><span class=c1></span>
        <span class=k>const</span> <span class=k>auto</span> <span class=p>[</span><span class=n>new_fl</span><span class=p>,</span> <span class=n>new_sl</span><span class=p>]</span> <span class=o>=</span> <span class=n>mapping_insert</span><span class=p>(</span><span class=n>new_free_size</span><span class=p>);</span>
        <span class=n>insert_block</span><span class=p>(</span><span class=n>p_new_bhdr</span><span class=p>,</span> <span class=n>p_tlsf</span><span class=p>,</span> <span class=n>new_fl</span><span class=p>,</span> <span class=n>new_sl</span><span class=p>);</span>
        <span class=c1>// ...
</span><span class=c1></span>    <span class=p>}</span>
  
    <span class=c1>// ...
</span><span class=c1></span>    <span class=k>return</span> <span class=n>p_data</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h3 id=3-mallocで新しいブロックを探すしかない場合>3. mallocで新しいブロックを探すしかない場合<a hidden class=anchor aria-hidden=true href=#3-mallocで新しいブロックを探すしかない場合>#</a></h3><p>どうしようもないので<code>malloc</code>で新しいブロックを探します。探すことが出来たら、<code>memcpy</code>で既存のブロックの内容を新しいブロックにコピーします。ただし、この場合だとPODでしかちゃんとコピーが出来ないのでC++のクラスの情報が入ったブロックをコピーしたい場合には特殊なロジックが要るかもしれません。</p><p>最後には既存のブロックを<code>free</code>します。（<code>tlsf_free()</code>）</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// Otherwise, we need to find another free-block.
</span><span class=c1></span><span class=n>block_buffer_t</span><span class=o>*</span> <span class=n>p_new_buffer</span> <span class=o>=</span> <span class=p>(</span><span class=n>block_buffer_t</span><span class=o>*</span><span class=p>)</span><span class=n>tlsf_malloc</span><span class=p>(</span><span class=n>new_size</span><span class=p>,</span> <span class=n>p_tlsf</span><span class=p>);</span>
<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>p_new_buffer</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=k>nullptr</span><span class=p>;</span> <span class=p>}</span>

<span class=k>const</span> <span class=n>u64</span> <span class=n>copy_size</span> <span class=o>=</span> <span class=n>p_bhdr</span><span class=o>-&gt;</span><span class=n>get_block_size</span><span class=p>()</span> <span class=o>&gt;</span> <span class=n>new_size</span> 
    <span class=o>?</span> <span class=nl>new_size</span> 
    <span class=p>:</span> <span class=n>p_bhdr</span><span class=o>-&gt;</span><span class=n>get_block_size</span><span class=p>();</span>
<span class=n>memcpy</span><span class=p>(</span><span class=n>p_new_buffer</span><span class=p>,</span> <span class=n>p_buffer</span><span class=p>,</span> <span class=n>copy_size</span><span class=p>);</span>
<span class=n>tlsf_free</span><span class=p>(</span><span class=n>p_buffer</span><span class=p>,</span> <span class=n>p_tlsf</span><span class=p>);</span>
</code></pre></div><h2 id=4tlsf_free>4.<code>tlsf_free()</code><a hidden class=anchor aria-hidden=true href=#4tlsf_free>#</a></h2><p>確保したメモリブロックを解除したい場合にはこの関数を使います。（ただし、PODタイプのみ）しかしメモリ解除をする時に、今解除するメモリブロックに隣接したブロックが空き（フリー）かを確認し、空きだったら併合して一つのブロックに纏めさせることも出来ます。</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// 消す前に次のブロックがFreeなのかを確認する。
</span><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>block_header_t</span><span class=o>*</span> <span class=n>p_temp_bhdr</span> <span class=o>=</span> <span class=n>p_bhdr</span><span class=o>-&gt;</span><span class=n>get_next_block</span><span class=p>();</span>
    <span class=n>p_temp_bhdr</span><span class=o>-&gt;</span><span class=n>is_freed</span><span class=p>())</span>
<span class=p>{</span>   <span class=c1>// 併合
</span><span class=c1></span>    <span class=k>const</span> <span class=k>auto</span> <span class=p>[</span><span class=n>fl</span><span class=p>,</span> <span class=n>sl</span><span class=p>]</span> <span class=o>=</span> <span class=n>mapping_insert</span><span class=p>(</span><span class=n>p_temp_bhdr</span><span class=o>-&gt;</span><span class=n>get_block_size</span><span class=p>());</span>
    <span class=n>extract_block</span><span class=p>(</span><span class=n>p_temp_bhdr</span><span class=p>,</span> <span class=n>p_tlsf_pool</span><span class=p>,</span> <span class=n>fl</span><span class=p>,</span> <span class=n>sl</span><span class=p>);</span>
    <span class=c1>// 後処理
</span><span class=c1></span><span class=p>}</span>

<span class=c1>// 消す前に前のブロックがFreeなのかを確認する。
</span><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>p_bhdr</span><span class=o>-&gt;</span><span class=n>is_prev_freed</span><span class=p>())</span>
<span class=p>{</span>
    <span class=n>block_header_t</span><span class=o>*</span> <span class=n>p_prev_bhdr</span> <span class=o>=</span> <span class=n>p_bhdr</span><span class=o>-&gt;</span><span class=n>get_prev_bhdr</span><span class=p>();</span>
    <span class=c1>// 併合
</span><span class=c1></span>    <span class=k>const</span> <span class=k>auto</span> <span class=p>[</span><span class=n>fl</span><span class=p>,</span> <span class=n>sl</span><span class=p>]</span> <span class=o>=</span> <span class=n>mapping_insert</span><span class=p>(</span><span class=n>p_prev_bhdr</span><span class=o>-&gt;</span><span class=n>get_block_size</span><span class=p>());</span>
    <span class=n>extract_block</span><span class=p>(</span><span class=n>p_prev_bhdr</span><span class=p>,</span> <span class=n>p_tlsf_pool</span><span class=p>,</span> <span class=n>fl</span><span class=p>,</span> <span class=n>sl</span><span class=p>);</span>
    <span class=c1>// 後処理
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>最後に空いたブロックを空きブロック管理マトリックスに入れます。</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>// Final mapping insert.
</span><span class=c1></span><span class=k>const</span> <span class=k>auto</span> <span class=p>[</span><span class=n>fl</span><span class=p>,</span> <span class=n>sl</span><span class=p>]</span> <span class=o>=</span> <span class=n>mapping_insert</span><span class=p>(</span><span class=n>p_bhdr</span><span class=o>-&gt;</span><span class=n>get_block_size</span><span class=p>());</span>
<span class=n>insert_block</span><span class=p>(</span><span class=n>p_bhdr</span><span class=p>,</span> <span class=n>p_tlsf_pool</span><span class=p>,</span> <span class=n>fl</span><span class=p>,</span> <span class=n>sl</span><span class=p>);</span>
</code></pre></div><h2 id=5tlsf_raw_destroy>5.<code>tlsf_raw_destroy</code><a hidden class=anchor aria-hidden=true href=#5tlsf_raw_destroy>#</a></h2><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>tlsf_raw_t</span><span class=o>*</span> <span class=n>p_tlsf</span> <span class=o>=</span> <span class=p>(</span><span class=n>tlsf_raw_t</span><span class=o>*</span><span class=p>)</span><span class=n>p_pool</span><span class=p>;</span>
<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>has_signature</span><span class=p>())</span>
<span class=p>{</span>
    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>return</span> <span class=n>p_tlsf</span><span class=o>-&gt;</span><span class=n>m_used_mem</span> <span class=o>==</span> <span class=mi>0</span><span class=p>;</span>
</code></pre></div><p>TLSF構造体のシグニチャーを無効化します。それだけです。</p><h1 id=改善点>改善点<a hidden class=anchor aria-hidden=true href=#改善点>#</a></h1><h3 id=ビットシフトアルゴリズムがまだ完全に理解できてない>・ビットシフトアルゴリズムがまだ完全に理解できてない<a hidden class=anchor aria-hidden=true href=#ビットシフトアルゴリズムがまだ完全に理解できてない>#</a></h3><p>First-IndexとSecond-Indexの数値をビットマップ変数に更新するためのアルゴリズムが完全には理解できませんでした。テストケースを作って、どのようにフラグ値が変わるのかを詳しく調べてみたいですね。</p><h3 id=まだscalableではない>・まだScalableではない<a hidden class=anchor aria-hidden=true href=#まだscalableではない>#</a></h3><p>TLSFの特徴の一つである、メモリプールをくっつけて更に多くのメモリが確保出来るようにするための機能がまだ実装してませんでした。次の記事を書くときには今抜かれた機能まで付けて、それの説明までしたいです。</p><h1 id=まとめ>まとめ<a hidden class=anchor aria-hidden=true href=#まとめ>#</a></h1><p>最後までがんばります。（適当）</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://liliilli.github.io/tags/untagged/>untagged</a></li></ul><nav class=paginav><a class=prev href=https://liliilli.github.io/posts/dinput8/><span class=title>« Prev Page</span><br><span>DirectInput8 導入メモ</span></a>
<a class=next href=https://liliilli.github.io/posts/matrix_name/><span class=title>Next Page »</span><br><span>行列変数のネーミングについて</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share TLSF Allocatorを作ってみた on twitter" href="https://twitter.com/intent/tweet/?text=TLSF%20Allocator%e3%82%92%e4%bd%9c%e3%81%a3%e3%81%a6%e3%81%bf%e3%81%9f&url=https%3a%2f%2fliliilli.github.io%2fposts%2ftlsf_basic%2f&hashtags=untagged"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share TLSF Allocatorを作ってみた on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fliliilli.github.io%2fposts%2ftlsf_basic%2f&title=TLSF%20Allocator%e3%82%92%e4%bd%9c%e3%81%a3%e3%81%a6%e3%81%bf%e3%81%9f&summary=TLSF%20Allocator%e3%82%92%e4%bd%9c%e3%81%a3%e3%81%a6%e3%81%bf%e3%81%9f&source=https%3a%2f%2fliliilli.github.io%2fposts%2ftlsf_basic%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share TLSF Allocatorを作ってみた on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fliliilli.github.io%2fposts%2ftlsf_basic%2f&title=TLSF%20Allocator%e3%82%92%e4%bd%9c%e3%81%a3%e3%81%a6%e3%81%bf%e3%81%9f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share TLSF Allocatorを作ってみた on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fliliilli.github.io%2fposts%2ftlsf_basic%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share TLSF Allocatorを作ってみた on whatsapp" href="https://api.whatsapp.com/send?text=TLSF%20Allocator%e3%82%92%e4%bd%9c%e3%81%a3%e3%81%a6%e3%81%bf%e3%81%9f%20-%20https%3a%2f%2fliliilli.github.io%2fposts%2ftlsf_basic%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share TLSF Allocatorを作ってみた on telegram" href="https://telegram.me/share/url?text=TLSF%20Allocator%e3%82%92%e4%bd%9c%e3%81%a3%e3%81%a6%e3%81%bf%e3%81%9f&url=https%3a%2f%2fliliilli.github.io%2fposts%2ftlsf_basic%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright © 2008–2019, Steve Francia and the Hugo Authors; all rights reserved.</span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>