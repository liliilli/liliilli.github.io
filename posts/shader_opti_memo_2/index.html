<!doctype html><html lang=en dir=" auto"><head><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=DotGothic16&family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel=stylesheet><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Low-level shader optimization for next-gen and D3D11のメモ | neuromantic</title><meta name=keywords content><meta name=description content="メモの基になる原文は2014年GDCで発表されたもので、翻訳ミスによる間違いがある可能性があります。また、GCN（AMD）アーキテクチャの重"><meta name=author content="Jongmin Yun, Neu."><link rel=canonical href=https://liliilli.github.io/posts/shader_opti_memo_2/><link crossorigin=anonymous href=/assets/css/stylesheet.min.80dbcc80c00cba63b71a6526cb77f5aab60620dd3fecc491bc3a5da1af3d4c62.css integrity="sha256-gNvMgMAMumO3GmUmy3f1qrYGIN0/7MSRvDpdoa89TGI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://liliilli.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://liliilli.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://liliilli.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://liliilli.github.io/apple-touch-icon.png><link rel=mask-icon href=https://liliilli.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.0"><meta property="og:title" content="Low-level shader optimization for next-gen and D3D11のメモ"><meta property="og:description" content="メモの基になる原文は2014年GDCで発表されたもので、翻訳ミスによる間違いがある可能性があります。また、GCN（AMD）アーキテクチャの重"><meta property="og:type" content="article"><meta property="og:url" content="https://liliilli.github.io/posts/shader_opti_memo_2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-06-18T10:27:48+09:00"><meta property="article:modified_time" content="2020-06-18T19:42:58+09:00"><meta property="og:site_name" content="neuromantic"><meta name=twitter:card content="summary"><meta name=twitter:title content="Low-level shader optimization for next-gen and D3D11のメモ"><meta name=twitter:description content="メモの基になる原文は2014年GDCで発表されたもので、翻訳ミスによる間違いがある可能性があります。また、GCN（AMD）アーキテクチャの重"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://liliilli.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Low-level shader optimization for next-gen and D3D11のメモ","item":"https://liliilli.github.io/posts/shader_opti_memo_2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Low-level shader optimization for next-gen and D3D11のメモ","name":"Low-level shader optimization for next-gen and D3D11のメモ","description":"メモの基になる原文は2014年GDCで発表されたもので、翻訳ミスによる間違いがある可能性があります。また、GCN（AMD）アーキテクチャの重","keywords":[],"articleBody":"メモの基になる原文は2014年GDCで発表されたもので、翻訳ミスによる間違いがある可能性があります。また、GCN（AMD）アーキテクチャの重点的に扱っているので、NVIDIAなどのハードウェアについては挙動が違うかもしれません。\n 本文 Low Level Thinking in High Shader Languagesの原文が出てから１年後、2014年に現世代（Xbox One、PS4）で搭載されたGCNアーキテクチャの登場、DirectX11の本格的な使用（当時SteamでのD3D11使用割合が70%）によって以前までの最適化も新しく考えなかればならなくなったそうだ。\nIntroduction ~ More Lessons   Xbox One（Durango）、PS4（Orbis）はAMDのスーパーSIMDのGCNを使っている。（GCNの前まではVLIWを使い回していた）＋次世代もAMDのNAVI（GCN1.5として分類されるらしい）を使ってるので基本的な骨子は変わらないのでは…と\n  コンパイラが高級言語で書いたコードをなんでも最適化してくれると思わないでほしい。コンパイラは文法的な部分を破壊せず出来るだけの最適化だけ行う。\n  以前まではできればMAD命令になるようにコードを書くべきであった。\n  スカラとベクトルの演算を分離すべき。ビルトイン関数の中ではベクトルとスカラを混じって使ってる実装があるので、注意すべき。\n  VLIWを採用したアーキテクチャの場合には演算の依存性が強いので、できれば分類して「（）」を取ること。\n  abs()と-符号（Negation）を使う際には既存の変数に、saturate()は演算したものを入れて使わなければ命令の最適化がされない。\n  rcp()、rsqrt()、sqrt()、exp2()、log2()、そして一般三角関数はHWにマッピングされている。ただ、逆三角関数は慎重に使うこと。\n  高級言語での最適化はローレベルの最適化に影響をする。\n  A look at modern hardware ~ Sampling a cubemap キューブマップから３次元UVWでサンプリングをするコードがあるとして、\nTextureCube Cube;\rSamplerState Samp;\rfloat4 main(float3 tex_coord: TEXCOORD) : SV_Target\r{\rreturn Cube.Sample(Samp, tex_coord);\r}\rD3D9までは射影マッピング（tex2Dproj）と同じく、一つの命令としてテクセルをサンプリングすることが出来た。しかしD3D10からは射影マッピングをさせる関数がなくなり、実装するためには直接wで割り算しなければならなかった。\nハードウェアが発展するにつれて射影マッピングなどをするための特殊なトランジスターなどを植え込む必要がなくなり、その代わりにいくつかの演算で同じことを出来るようALUをもっと植え付けるようになったそうだ。\nこれはキューブマップも同じで、キューブマップで使うUVWを平準化（ノーマライズ）するに特殊なトランジスターなどを使わず以前より沢山になったALUの一部を使って演算させるようになったらしい。もちろん原文（p5）の右画像のバイトコードは、命令が一つしか生成されなくてこれでOKのようだが、実際に生成されるコードは結構グロいようだ。（もちろんハードウェアによって生成されるインストラクションはそれぞれ違う）\n画像ではベクトル演算が15個、スカラ演算が6個、テクスチャに接近して色をとり、またそれを返す命令がそれぞれ1個で色々と膨らんでいることがわかる。\nHardware evolution 固定関数（Fixed Function）のためのユニットがALUに編入されつつある傾向が持続しているそうだ。D3D11_FILTER（ミップマップのフィルタリング）で線形補間などをすることもD3D11からはALUに任せているらしい。（またハードウェアによって挙動は違うかもしれない）\nVertex Fetchも見た目は固定関数で、実はシェーダーの中でFetchingを行っているそうだ。（前世代のXbox 360は既にやっていたと…）\n https://stackoverflow.com/questions/56581141/direct3d11-gradient-instruction-used-in-a-loop-with-varying-iteration-forcing\n 射影とキューブマップのための演算もALUに移り、テクスチャのサンプリングをする時に内部で使うddx/ddyなどのグラディエント（Gradient）もGCNでは最終的にはALUの方で演算されるようになったそうだ。\nこういった固定関数のような要素たちがALUの演算に全部依存することになって、比較的コストが増えてしまってるので、それに関する注意もやらざるを得なくなった。\nまた以前までのGPUハードウェアは内部でいくつかの全域状態を保持するためのレジスターなどを持って、そこからハードウェアが必要となる時に読んだりして演算を処理したらしい。（多分SM3までの話だと思う）最新（当時）のハードウェアはそれがなくなり、ほぼすべてのリソースをVRAMメモリまたはL1、L2キャッシュから読み込んで演算しなければならない。（Constant Bufferなどが生まれた理由かな…と思ってる）\nまたSM6（D3D12）になってもリソースを割り当てる時にはスロット（Slot）を書かなければならないが、実際のHWではスロットというのはもうなくなり、その代わりにメモリにスロットの代わりに使えるリストを作って、そこにシェーダーのリソースまたは何らかのポインターを入れて使うようにしているそうだ。\nということは、数の制約がなければシェーダーから接近できるリソースの数の制約っていうのはもうなくなっていたということである。また、リソースのアクセスには関連したサンプラーの状態（Sampler state）とリソーステクスチャへのディスクリプタ（Descriptor）への明示的に参照をするための追加コストが要るようになったことでもある。しかしGCNアーキテクチャではVALUが動いてる途中で独立的にSALUでやってくれるのでコストはないらしい。\nまたGCNのCompute Unitは完全な無状態（Stateless）である。ということで一つのCompute Shaderで使うリソースなどはほかのCompute Shaderに干渉されてなく、データレースなどをうまくコントロールすればほぼ並列でシェーダーを動作させることが出来るという。\nしかしGraphics pipelineはCompute Shaderとは違ってパイプライン制御のための状態を保持しなければならないため、並列に演算させることは出来ないらしい。（RDNA2とかAmpereではどうなのかな）\nNULL shader ~ Not so NULL shader anymore float4 main(float4 tex_coord: TEXCOORD0) : SV_Target\r{\rreturn tex_coord;\r}\rNULL shaderはハードウェア上でAPIの基本的な基本的な特性を把握するに適切だ。原文によれば、AMDのD3D10ではR0レジスタをピクセルに書き込むだけの一つ命令で終わるが、AMDのD3D11からは補完（interpolation）自体がシェーダーの方で行っているため、p10の画像のようにインストラクションが増えたことがわかる。（またGCNの最後でf32→f16のexport conversionをしていることもわかる）\nということで、AMDのD3D11でD3D10のようなNULL Shaderを作るには以下のようにしなければならないらしい。\nfloat4 main(float4 scr_pos: SV_Position) : SV_Target\r{\rreturn scr_pos;\r}\r// in GCN...\r// exp mrt0, v2, v3, v4, v5 vm done (v0 and v1 are for barycentric coords for interpolation)\r// s_endpgm\r https://www.dictionary.com/browse/freebees\n Shader inputs シェーダーを実行するスケジューラでは書くシェーダーステージごとにコストがないリソースを用意している。上のPSコードで使ったSV_Positionもその一部である。\n VS - Vertex Index（SV_VertexID） PS - Barycentric coordinates、SV_Position CS - SV_DispatchThreadID、SV_GroupID  しかし使っているハードウェアまたはAPIによって上のリストとはサポートするものが違うかもしれない。兎に角、コストがないリソース以外のリソースはメモリに載っており、接近しようとしたらコストが発生する。\nまた前述の通りAPIはVertex Fetchを固定関数の扱いしているが、GCN以降のHWでは固定関数ではなくなり、シェーダーから直接命令を叩いて実行するようになった。実はこれはXbox 360でも同じでシェーダーから頂点をFetchしているそうだ。ただ、Xbox 360の場合にはそれを実現するための大量のインストラクションを入れておかないといけないらしく、相当コストがあったそうだ。\nGCNでは普通にs_swappc_b64というSubroutineにジャンプする命令を使って頂点を取得している。しかしVertex組を使わないとこのジャンプはいらないためなくなっている。\nまたドライバーソフトはリソースの数が少なく、16個のユーザーSGPR（Scalar General Purpose Register）に収めることが出来たら、ポインターでリソースを探させるのではなくリソースのディスクリプタを直接シェーダーの中に入れて参照させる。しかしテクスチャのディスクリプタは８SGRPを消耗するため、１個だけ入れられるっていう結構厳しい感じはある。\np17）昔にはUV座標の補完の命令を減らすためにUV２個をfloat4のようなベクトルに全部入れとく最適化があったが、GCNでは通用しないらしい。すなわち最適化してないコードとコストが同じになってしまう。解決策は低数値に補完をしないようにフラグをかけることである。\nまたSV_Positionのことだが、短いコードなどで使おうとするとシステムからSV_Positionを生成する時間によってボトルネックになることがあるそうだ。勿論SV_系は予めシェーダーのレジスタにロードされるようになるため、シェーダーから見るとコスト無しに見えるけれど実際にはそうではないらしい。長いコードで使うのは、どこかでの要素によってボトルネックが掛かることがある可能性が高いため、気にしなくて良いらしい。\n https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-struct\nDo not perform perspective-correction during interpolation. The noperspective modifier can be combined with the centroid modifier.\n そして属性として付けられる[noperspective]はGCNではあんまり影響がないそうだ。ただ、Rasterizer以前の段階でwをPSまで持っていって、そこで割り算などを使う時にはこれを入れるとxyz(w)へのPerspective-Correctionをしないため、ALUの軽減が低下するらしい。\nfloat4 main(nointerpolation float4 tc: TC) : SV_Target\r{\rreturn tc * rcp(tc.w);\r}\rGCNアーキテクチャではboolが実装されていないらしく、そして全てのレジスタは32bitであるためSV_IsFrontFaceのようなboolは0xFFFFFFFFか0x0になる。これを使ってback-face lightingが最適化できる。\nreturn face ? normal : -normal;\r// or...\rreturn asfloat(BitFieldInsert(face, asuint(normal), asuint(-normal)));\rGCN instructions GCNアーキテクチャは以前のVLIWのようなものすごく長い命令を持たなく、32bitまたは64bitの命令だけを持つようになっている。そして命令一つに一つのスカラレジスタだけ読み込みできるようになったため、MADが効率が悪くなる可能性ができてしまう。\nただ、ハードウェア的にコスト無しの定数をいくつ内蔵している。\n 0.5, 1.0, 2.0, 4.0, -0.5, -1.0, -2.0, -4.0（Single-point floating） [-64, 64]（Integer）  最初にも技術したあったがGCNは以前までのAMDのVLIW-4から完全に変わったScalarベースのSIMDアーキテクチャである。ということはシェーダーで演算の単位をスカラ数値一つとして扱うことになる。（ベクトル命令がなくなるということではない）\nしかしハードウェアではWavefrontという64個のスレッド組があって、スレッド一つ一つがスカラ値を演算するように構成されている。そしてこれをSIMD化されたベクトルという。ここでベクトル命令が働き出すそうだ。\nベクトル命令で構成されないスカラは、スカラ演算を行うユニットで演算される。そしてスカラ演算のためのユニットはベクトルとは独立的に動くので、もしシェーダーでベクトル演算またはテクスチャのサンプリングが多かったら負荷はあんまりない。\np22）ハードウェア命令とはどの命令かによって実行速度が違う。2014年以降のGPUでは単精度浮動小数点数の演算は割り算を除き最大限の速度で演算される。しかしGCNでは整数に限って32bitsのMULとMADはフールではない。\nそれと、タイプの変換は以前までのAMDでは1/4の速度だったが、GCNからは最大限の速度になる。またfloor()、ceil()、round()も速度低下がない。\n Full Rate  Float add/sub/mul/mad/fma Integer add/sub/mul24/mad24/logic Type conversion, floor, ceil, round   1/2 Rate  Double add   1/4 Rate  rcp, rsqrt, sqrt Double mul/fma Integer 32-bit mul   Super Expensive  Integer div asin, acos, atan…    スカラ値の場合にはベクトル演算とは違うユニットで独立で演算されるため、シェーダーがどのような演算が主な演算になっているかによってコストなしまたはコストありに分かれる。\nまた以前までのAMDハードウェアではVLIWスロットの個数などで処理速度を測ることが出来たが、GCNからは命令の速度がそれぞれ違うし、命令の個数が表示されなくなったため（普通のx86のようになった）処理速度を測るには一つ一つ判別するしかなくなった。\np25）そしてMADの対してGCNではVLIWのように長い命令を持てなくなったため、MADが下手すると一つの64bit命令に収まらなくむしろADD + MULより速度が落ちてしまう。\n 画像でのv_mac_f32 v1, s0, v0はv1 = s0 * v0 + v1を実装している。つまい本来のMADのように命令になる。\n ただアーキテクチャが変わったといってMADはまだ使えるし、注意して書けば効率はよくなるそうだ。ただ注意するところがあって、\n inline constantを使う時 インプットがベクトルである時 適合した命令に被演算子が入れられる時  といった条件下でMADは効率を保障する。\nreturn x * 3.0f + y; // x and y is scalar = v_madmk_f32 v0, v2, 0x40400000, v0\rreturn x * 0.5f + 1.5f // x is scalar = v_madak_f32 v0, 0.5(l), v0, 0x3fc00000\r下の0.5はliteral constantであるため、MADになれた。上は3.0fだけ定数であるため、ギリギリでMADすることが出来た。\nしかしベクトルを使ってる時には若干最適化が劣るけど、v_mad_f32とv_mac_f32を使ってある程度の速度向上となっている。\nreturn v4 * c.x + c.y;\r// v_mov_b32 v1, s1\r// 3 of v_mad_f32\r// and v_mac_f32 end...\rVectorization 昔GPUのアーキテクチャ自体がSuper-ScalarまたはVLIWベースではなかった時には、ベクトル演算の力を借りてreturn 1.0f - dot(v.xy, v.xy)みたいにむりやり最適化を催そうとしたが、今のGPUはだいたいSuper-ScalarまたはモバイルさえもVLIWベースであるため、やらない方がむしろ最適化されやすい。\nROPs ROPとは？  https://en.wikipedia.org/wiki/Render_output_unit\n レンダリングパイプラインのRasterization、そしてフレームバッファにピクセルを書き込む時に使われるもので、ブレンディング、AAなどに使われる。\nクロックごとにどれだけのピクセルを表示することが出来るかの指標として扱える。（後はメモリBandwidth）\n 2020年今までゲーミンググラボの中で一番高いやつの「2080ti」はROPが88個だが、PS4は32個（PROはわからない）、そしてXBOX ONEは16個であるため、短いシェーダーの場合には性能が発揮しにくい。また性能のボトルネックを測るにはVRAMメモリへの帯域幅も念頭しなければならない。\n原文では「GPUのクロック＊ROPs＊フレームバッファの各ピクセルのBytes」で理論上の処理速度を測定している。\nとにかくなんとかかんとか大体のフレームバッファはRGBA8であるため（HDRなどは例外）、普通の状況ではROPsボトルネックになってしまう。出来ればメモリのボトルネックにする方が良いので、演算速度を上げるにはCompute Shaderをものすごく使うのが良いらしい。\nBranching ~ Registers GCNでの分岐の処理は基本的に一番遅いレーンに合わせることと、ThenとElseの分岐を全部試してみるという骨子からあんまり変わっていないが、速いので速度が落ちることがあんまりないそうだ。分岐の処理はスカラ演算ユニットで処理される。\nしかし問題は分岐によってGRP（General Purpose Register）の使用が増えてしまうことである。分岐よりはこのGRPの使用増加により性能が落ちるらしい。\n小さい分岐にはFull branchを防ぐため?:を使う。ただ、あるプラットフォームまたはHWでは?:さえFull branchされてしまい、GRPの増加による性能落ちが発生するらしく、その時にはCndMask()を使うと言っている。（拡張か、それともなんらかのIntrinsicみたい）\np34）整数でmul24()が使えるなら、普通のMULの代わりにmul24(a,b)を使う方が速い。24bitだけを取り出し、32bitをの結果値を返す。またはハードウェアのサポートによってmul24_hi()もあるという。\nまたHWのサポートによってMADを24bits、24bits、そしてADDに使う32bitsとして1サイクルを終わらせるものもあるらしい。\nそして整数への割り算はデバイスからサポートしてない場合が多く、やるとしても最適化がかからなかったら~40サイクルまで掛かるのでやらないべきであるという。最適化されるとしても、5~8クロックはかかるそうだ。\np38）GCNは倍精度浮動小数点（Double）をサポートするが、使うとこがない。\n https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/f32tof16--sm5---asm-\n D3D11以上でdoubleとfloatを変換する際にはf32tof16()またはf16tof32()を使う。\nR5G5B5圧縮カラー（DXT1）から各チャンネルの色を取りたい時には以下のようにする。\nint r = s \u0026 0x1F; // 1 cycle maybe\rint g = (s  5) \u0026 0x3F; // 1 cycle maybe\rint b = (s  11) \u0026 0x1F; // 1 cycle maybe\rp41）sign()とstep()の代わりに?:を使うこと。（in D3D11）原文ではsign()ビルトイン関数は遅いのでいっそ(x = 0) ? 1 : -1のように使うべきだと言っている。またstep()も(x = a) ? 1 : 0にすべきらしい。\nGCNはベクトルに対して実行サイクルをへらすためにmin3()、max3()、med3()らしきものを実装している。\np44）シェーダーの各ステージで使っているレジスタの数は処理速度に影響を与える。しかしレジスタの使用を最適化することはブラックボックス化された中身を最適化することと同じで、もっとも難しい。ただ、経験上からはシェーダーの横負荷を減らして、ある時点で使っているレジスタの数を減らせば性能は上がるらしい。（HWによって違う可能性ある）\nfor (each) { WorkA(); }\rfor (each) { WorkB(); }\r// not for (each) { WorkA(); WorkB(); }\rそしてこの最適化はCPUの方でも通用されるのだが、変数データの寿命を最大限に短くすること。また、#ifdefを積極的に活用してランタイムの分岐よりはシェーダープログラムを作る際に静的に分岐して性能の低下を防ぐようにすること。最悪Uber-shaderの中にマクロ分岐を仕込んでレンダリングさせるほうが良い。\nThings shader author should stop doing やるなスペシャル\n pow(color, 2.2f) normal = Normal.Sample(...) * 2.0f - 1.0f  参考 GDC2017-Advanced-Shader-Programming-On-GCN\nGS-4106 The AMD GCN Architecture - A Crash Course, by Layla Mah\nAMD Southern Island Instruction Set Architecture\n","wordCount":"7646","inLanguage":"en","datePublished":"2020-06-18T10:27:48+09:00","dateModified":"2020-06-18T19:42:58+09:00","author":{"@type":"Person","name":"Jongmin Yun, Neu."},"mainEntityOfPage":{"@type":"WebPage","@id":"https://liliilli.github.io/posts/shader_opti_memo_2/"},"publisher":{"@type":"Organization","name":"neuromantic","logo":{"@type":"ImageObject","url":"https://liliilli.github.io/favicon.ico"}}}</script></head><body id=" top"><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://liliilli.github.io accesskey=h title="neuromantic (Alt + H)">neuromantic</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://liliilli.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://liliilli.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://liliilli.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://liliilli.github.io/series/ title=Series><span>Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://liliilli.github.io>Home</a>&nbsp;»&nbsp;<a href=https://liliilli.github.io/posts/>Posts</a></div><h1 class=post-title>Low-level shader optimization for next-gen and D3D11のメモ</h1><div class=post-meta>2020, June 18&nbsp;·&nbsp;Jongmin Yun, Neu.</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e6%9c%ac%e6%96%87 aria-label=本文>本文</a><ul><li><a href=#introduction--more-lessons aria-label="Introduction ~ More Lessons">Introduction ~ More Lessons</a></li><li><a href=#a-look-at-modern-hardware--sampling-a-cubemap aria-label="A look at modern hardware ~ Sampling a cubemap">A look at modern hardware ~ Sampling a cubemap</a></li><li><a href=#hardware-evolution aria-label="Hardware evolution">Hardware evolution</a></li><li><a href=#null-shader--not-so-null-shader-anymore aria-label="NULL shader ~ Not so NULL shader anymore">NULL shader ~ Not so NULL shader anymore</a></li><li><a href=#shader-inputs aria-label="Shader inputs">Shader inputs</a></li><li><a href=#gcn-instructions aria-label="GCN instructions">GCN instructions</a></li><li><a href=#vectorization aria-label=Vectorization>Vectorization</a></li><li><a href=#rops aria-label=ROPs>ROPs</a><ul><li><a href=#rop%e3%81%a8%e3%81%af aria-label=ROPとは？>ROPとは？</a></li></ul></li><li><a href=#branching--registers aria-label="Branching ~ Registers">Branching ~ Registers</a></li><li><a href=#things-shader-author-should-stop-doing aria-label="Things shader author should stop doing">Things shader author should stop doing</a></li></ul></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div><div class=post-content><p>メモの基になる<a href=https://www.gdcvault.com/browse/gdc-14/play/1020352>原文</a>は2014年GDCで発表されたもので、翻訳ミスによる間違いがある可能性があります。また、GCN（AMD）アーキテクチャの重点的に扱っているので、NVIDIAなどのハードウェアについては挙動が違うかもしれません。</p><hr><h1 id=本文>本文<a hidden class=anchor aria-hidden=true href=#本文>#</a></h1><p><a href=https://liliilli.github.io/posts/shader_opti_memo/>Low Level Thinking in High Shader Languages</a>の原文が出てから１年後、2014年に現世代（Xbox One、PS4）で搭載されたGCNアーキテクチャの登場、DirectX11の本格的な使用（当時SteamでのD3D11使用割合が70%）によって以前までの最適化も新しく考えなかればならなくなったそうだ。</p><h2 id=introduction--more-lessons>Introduction ~ More Lessons<a hidden class=anchor aria-hidden=true href=#introduction--more-lessons>#</a></h2><ul><li><p>Xbox One（Durango）、PS4（Orbis）はAMDのスーパーSIMDのGCNを使っている。（GCNの前まではVLIWを使い回していた）＋次世代もAMDのNAVI（GCN1.5として分類されるらしい）を使ってるので基本的な骨子は変わらないのでは…と</p></li><li><p>コンパイラが高級言語で書いたコードをなんでも最適化してくれると思わないでほしい。コンパイラは文法的な部分を破壊せず出来るだけの最適化だけ行う。</p></li><li><p>以前まではできれば<code>MAD</code>命令になるようにコードを書くべきであった。</p></li><li><p>スカラとベクトルの演算を分離すべき。ビルトイン関数の中ではベクトルとスカラを混じって使ってる実装があるので、注意すべき。</p></li><li><p>VLIWを採用したアーキテクチャの場合には演算の依存性が強いので、できれば分類して「（）」を取ること。</p></li><li><p><code>abs()</code>と<code>-</code>符号（Negation）を使う際には既存の変数に、<code>saturate()</code>は演算したものを入れて使わなければ命令の最適化がされない。</p></li><li><p><code>rcp()</code>、<code>rsqrt()</code>、<code>sqrt()</code>、<code>exp2()</code>、<code>log2()</code>、そして一般三角関数はHWにマッピングされている。ただ、逆三角関数は慎重に使うこと。</p></li><li><p>高級言語での最適化はローレベルの最適化に影響をする。</p></li></ul><h2 id=a-look-at-modern-hardware--sampling-a-cubemap>A look at modern hardware ~ Sampling a cubemap<a hidden class=anchor aria-hidden=true href=#a-look-at-modern-hardware--sampling-a-cubemap>#</a></h2><p>キューブマップから３次元UVWでサンプリングをするコードがあるとして、</p><pre><code class=language-hlsl data-lang=hlsl>TextureCube Cube;
SamplerState Samp;

float4 main(float3 tex_coord: TEXCOORD) : SV_Target
{
	return Cube.Sample(Samp, tex_coord);
}
</code></pre><p>D3D9までは射影マッピング（<code>tex2Dproj</code>）と同じく、一つの命令としてテクセルをサンプリングすることが出来た。しかしD3D10からは射影マッピングをさせる関数がなくなり、実装するためには直接<code>w</code>で割り算しなければならなかった。</p><p>ハードウェアが発展するにつれて射影マッピングなどをするための特殊なトランジスターなどを植え込む必要がなくなり、その代わりにいくつかの演算で同じことを出来るようALUをもっと植え付けるようになったそうだ。</p><p>これはキューブマップも同じで、キューブマップで使うUVWを平準化（ノーマライズ）するに特殊なトランジスターなどを使わず以前より沢山になったALUの一部を使って演算させるようになったらしい。もちろん原文（p5）の右画像のバイトコードは、命令が一つしか生成されなくてこれでOKのようだが、実際に生成されるコードは結構グロいようだ。（もちろんハードウェアによって生成されるインストラクションはそれぞれ違う）</p><p>画像ではベクトル演算が15個、スカラ演算が6個、テクスチャに接近して色をとり、またそれを返す命令がそれぞれ1個で色々と膨らんでいることがわかる。</p><h2 id=hardware-evolution>Hardware evolution<a hidden class=anchor aria-hidden=true href=#hardware-evolution>#</a></h2><p>固定関数（Fixed Function）のためのユニットがALUに編入されつつある傾向が持続しているそうだ。<code>D3D11_FILTER</code>（ミップマップのフィルタリング）で線形補間などをすることもD3D11からはALUに任せているらしい。（またハードウェアによって挙動は違うかもしれない）</p><p>Vertex Fetchも見た目は固定関数で、実はシェーダーの中でFetchingを行っているそうだ。（前世代のXbox 360は既にやっていたと…）</p><blockquote><p><a href=https://stackoverflow.com/questions/56581141/direct3d11-gradient-instruction-used-in-a-loop-with-varying-iteration-forcing>https://stackoverflow.com/questions/56581141/direct3d11-gradient-instruction-used-in-a-loop-with-varying-iteration-forcing</a></p></blockquote><p>射影とキューブマップのための演算もALUに移り、テクスチャのサンプリングをする時に内部で使う<code>ddx/ddy</code>などのグラディエント（Gradient）もGCNでは最終的にはALUの方で演算されるようになったそうだ。</p><p>こういった固定関数のような要素たちがALUの演算に全部依存することになって、比較的コストが増えてしまってるので、それに関する注意もやらざるを得なくなった。</p><p>また以前までのGPUハードウェアは内部でいくつかの全域状態を保持するためのレジスターなどを持って、そこからハードウェアが必要となる時に読んだりして演算を処理したらしい。（多分SM3までの話だと思う）最新（当時）のハードウェアはそれがなくなり、ほぼすべてのリソースをVRAMメモリまたはL1、L2キャッシュから読み込んで演算しなければならない。（Constant Bufferなどが生まれた理由かな…と思ってる）</p><p>またSM6（D3D12）になってもリソースを割り当てる時にはスロット（Slot）を書かなければならないが、実際のHWではスロットというのはもうなくなり、その代わりにメモリにスロットの代わりに使えるリストを作って、そこにシェーダーのリソースまたは何らかのポインターを入れて使うようにしているそうだ。</p><p>ということは、数の制約がなければシェーダーから接近できるリソースの数の制約っていうのはもうなくなっていたということである。また、リソースのアクセスには関連したサンプラーの状態（Sampler state）とリソーステクスチャへのディスクリプタ（Descriptor）への明示的に参照をするための追加コストが要るようになったことでもある。しかしGCNアーキテクチャではVALUが動いてる途中で独立的にSALUでやってくれるのでコストはないらしい。</p><p>またGCNのCompute Unitは完全な無状態（Stateless）である。ということで一つのCompute Shaderで使うリソースなどはほかのCompute Shaderに干渉されてなく、データレースなどをうまくコントロールすればほぼ並列でシェーダーを動作させることが出来るという。</p><p>しかしGraphics pipelineはCompute Shaderとは違ってパイプライン制御のための状態を保持しなければならないため、並列に演算させることは出来ないらしい。（RDNA2とかAmpereではどうなのかな）</p><h2 id=null-shader--not-so-null-shader-anymore>NULL shader ~ Not so NULL shader anymore<a hidden class=anchor aria-hidden=true href=#null-shader--not-so-null-shader-anymore>#</a></h2><pre><code class=language-hlsl data-lang=hlsl>float4 main(float4 tex_coord: TEXCOORD0) : SV_Target
{
	return tex_coord;
}
</code></pre><p>NULL shaderはハードウェア上でAPIの基本的な基本的な特性を把握するに適切だ。原文によれば、AMDのD3D10ではR0レジスタをピクセルに書き込むだけの一つ命令で終わるが、AMDのD3D11からは補完（interpolation）自体がシェーダーの方で行っているため、p10の画像のようにインストラクションが増えたことがわかる。（またGCNの最後でf32→f16のexport conversionをしていることもわかる）</p><p>ということで、AMDのD3D11でD3D10のようなNULL Shaderを作るには以下のようにしなければならないらしい。</p><pre><code class=language-hlsl data-lang=hlsl>float4 main(float4 scr_pos: SV_Position) : SV_Target
{
	return scr_pos;
}

// in GCN...
// exp mrt0, v2, v3, v4, v5 vm done (v0 and v1 are for barycentric coords for interpolation)
// s_endpgm
</code></pre><blockquote><p><a href=https://www.dictionary.com/browse/freebees>https://www.dictionary.com/browse/freebees</a></p></blockquote><h2 id=shader-inputs>Shader inputs<a hidden class=anchor aria-hidden=true href=#shader-inputs>#</a></h2><p>シェーダーを実行するスケジューラでは書くシェーダーステージごとにコストがないリソースを用意している。上のPSコードで使った<code>SV_Position</code>もその一部である。</p><ul><li>VS - Vertex Index（SV_VertexID）</li><li>PS - Barycentric coordinates、SV_Position</li><li>CS - SV_DispatchThreadID、SV_GroupID</li></ul><p>しかし使っているハードウェアまたはAPIによって上のリストとはサポートするものが違うかもしれない。兎に角、コストがないリソース以外のリソースはメモリに載っており、接近しようとしたらコストが発生する。</p><p>また前述の通りAPIはVertex Fetchを固定関数の扱いしているが、GCN以降のHWでは固定関数ではなくなり、シェーダーから直接命令を叩いて実行するようになった。実はこれはXbox 360でも同じでシェーダーから頂点をFetchしているそうだ。ただ、Xbox 360の場合にはそれを実現するための大量のインストラクションを入れておかないといけないらしく、相当コストがあったそうだ。</p><p>GCNでは普通に<code>s_swappc_b64</code>というSubroutineにジャンプする命令を使って頂点を取得している。しかしVertex組を使わないとこのジャンプはいらないためなくなっている。</p><p>またドライバーソフトはリソースの数が少なく、16個のユーザーSGPR（Scalar General Purpose Register）に収めることが出来たら、ポインターでリソースを探させるのではなくリソースのディスクリプタを直接シェーダーの中に入れて参照させる。しかしテクスチャのディスクリプタは８SGRPを消耗するため、１個だけ入れられるっていう結構厳しい感じはある。</p><p>p17）昔にはUV座標の補完の命令を減らすためにUV２個を<code>float4</code>のようなベクトルに全部入れとく最適化があったが、GCNでは通用しないらしい。すなわち最適化してないコードとコストが同じになってしまう。解決策は低数値に補完をしないようにフラグをかけることである。</p><p>また<code>SV_Position</code>のことだが、短いコードなどで使おうとするとシステムから<code>SV_Position</code>を生成する時間によってボトルネックになることがあるそうだ。勿論<code>SV_</code>系は予めシェーダーのレジスタにロードされるようになるため、シェーダーから見るとコスト無しに見えるけれど実際にはそうではないらしい。長いコードで使うのは、どこかでの要素によってボトルネックが掛かることがある可能性が高いため、気にしなくて良いらしい。</p><blockquote><p><a href=https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-struct>https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-struct</a></p><p>Do not perform perspective-correction during interpolation. The <strong>noperspective</strong> modifier can be combined with the <strong>centroid</strong> modifier.</p></blockquote><p>そして属性として付けられる<code>[noperspective]</code>はGCNではあんまり影響がないそうだ。ただ、Rasterizer以前の段階で<code>w</code>をPSまで持っていって、そこで割り算などを使う時にはこれを入れると<code>xyz(w)</code>へのPerspective-Correctionをしないため、ALUの軽減が低下するらしい。</p><pre><code class=language-hlsl data-lang=hlsl>float4 main(nointerpolation float4 tc: TC) : SV_Target
{
	return tc * rcp(tc.w);
}
</code></pre><p>GCNアーキテクチャではboolが実装されていないらしく、そして全てのレジスタは32bitであるため<code>SV_IsFrontFace</code>のような<code>bool</code>は<code>0xFFFFFFFF</code>か<code>0x0</code>になる。これを使って<code>back-face lighting</code>が最適化できる。</p><pre><code class=language-hlsl data-lang=hlsl>return face ? normal : -normal;
// or...
return asfloat(BitFieldInsert(face, asuint(normal), asuint(-normal)));
</code></pre><h2 id=gcn-instructions>GCN instructions<a hidden class=anchor aria-hidden=true href=#gcn-instructions>#</a></h2><p>GCNアーキテクチャは以前のVLIWのようなものすごく長い命令を持たなく、32bitまたは64bitの命令だけを持つようになっている。そして命令一つに一つのスカラレジスタだけ読み込みできるようになったため、<code>MAD</code>が効率が悪くなる可能性ができてしまう。</p><p>ただ、ハードウェア的にコスト無しの定数をいくつ内蔵している。</p><ul><li>0.5, 1.0, 2.0, 4.0, -0.5, -1.0, -2.0, -4.0（Single-point floating）</li><li>[-64, 64]（Integer）</li></ul><p>最初にも技術したあったがGCNは以前までのAMDのVLIW-4から完全に変わったScalarベースのSIMDアーキテクチャである。ということはシェーダーで演算の単位をスカラ数値一つとして扱うことになる。（ベクトル命令がなくなるということではない）</p><p>しかしハードウェアではWavefrontという64個のスレッド組があって、スレッド一つ一つがスカラ値を演算するように構成されている。そしてこれをSIMD化されたベクトルという。ここでベクトル命令が働き出すそうだ。</p><p>ベクトル命令で構成されないスカラは、スカラ演算を行うユニットで演算される。そしてスカラ演算のためのユニットはベクトルとは独立的に動くので、もしシェーダーでベクトル演算またはテクスチャのサンプリングが多かったら負荷はあんまりない。</p><p>p22）ハードウェア命令とはどの命令かによって実行速度が違う。2014年以降のGPUでは単精度浮動小数点数の演算は割り算を除き最大限の速度で演算される。しかしGCNでは整数に限って32bitsの<code>MUL</code>と<code>MAD</code>はフールではない。</p><p>それと、タイプの変換は以前までのAMDでは1/4の速度だったが、GCNからは最大限の速度になる。また<code>floor()</code>、<code>ceil()</code>、<code>round()</code>も速度低下がない。</p><ul><li>Full Rate<ul><li>Float add/sub/mul/mad/fma</li><li>Integer add/sub/mul24/mad24/logic</li><li>Type conversion, floor, ceil, round</li></ul></li><li>1/2 Rate<ul><li>Double add</li></ul></li><li>1/4 Rate<ul><li>rcp, rsqrt, sqrt</li><li>Double mul/fma</li><li>Integer 32-bit mul</li></ul></li><li>Super Expensive<ul><li>Integer div</li><li>asin, acos, atan&mldr;</li></ul></li></ul><p>スカラ値の場合にはベクトル演算とは違うユニットで独立で演算されるため、シェーダーがどのような演算が主な演算になっているかによってコストなしまたはコストありに分かれる。</p><p>また以前までのAMDハードウェアではVLIWスロットの個数などで処理速度を測ることが出来たが、GCNからは命令の速度がそれぞれ違うし、命令の個数が表示されなくなったため（普通のx86のようになった）処理速度を測るには一つ一つ判別するしかなくなった。</p><p>p25）そして<code>MAD</code>の対してGCNではVLIWのように長い命令を持てなくなったため、MADが下手すると一つの64bit命令に収まらなくむしろ<code>ADD + MUL</code>より速度が落ちてしまう。</p><blockquote><p>画像での<code>v_mac_f32 v1, s0, v0</code>はv1 = s0 * v0 + v1を実装している。つまい本来のMADのように命令になる。</p></blockquote><p>ただアーキテクチャが変わったといって<code>MAD</code>はまだ使えるし、注意して書けば効率はよくなるそうだ。ただ注意するところがあって、</p><ul><li>inline constantを使う時</li><li>インプットがベクトルである時</li><li>適合した命令に被演算子が入れられる時</li></ul><p>といった条件下で<code>MAD</code>は効率を保障する。</p><pre><code class=language-gcn data-lang=gcn>return x * 3.0f + y; // x and y is scalar =&gt; v_madmk_f32 v0, v2, 0x40400000, v0
return x * 0.5f + 1.5f // x is scalar =&gt; v_madak_f32 v0, 0.5(l), v0, 0x3fc00000
</code></pre><p>下の<code>0.5</code>はliteral constantであるため、<code>MAD</code>になれた。上は<code>3.0f</code>だけ定数であるため、ギリギリで<code>MAD</code>することが出来た。</p><p>しかしベクトルを使ってる時には若干最適化が劣るけど、<code>v_mad_f32</code>と<code>v_mac_f32</code>を使ってある程度の速度向上となっている。</p><pre><code class=language-gcn data-lang=gcn>return v4 * c.x + c.y;
// v_mov_b32 v1, s1
// 3 of v_mad_f32
// and v_mac_f32 end...
</code></pre><h2 id=vectorization>Vectorization<a hidden class=anchor aria-hidden=true href=#vectorization>#</a></h2><p>昔GPUのアーキテクチャ自体がSuper-ScalarまたはVLIWベースではなかった時には、ベクトル演算の力を借りて<code>return 1.0f - dot(v.xy, v.xy)</code>みたいにむりやり最適化を催そうとしたが、今のGPUはだいたいSuper-ScalarまたはモバイルさえもVLIWベースであるため、やらない方がむしろ最適化されやすい。</p><h2 id=rops>ROPs<a hidden class=anchor aria-hidden=true href=#rops>#</a></h2><h3 id=ropとは>ROPとは？<a hidden class=anchor aria-hidden=true href=#ropとは>#</a></h3><blockquote><p><a href=https://en.wikipedia.org/wiki/Render_output_unit>https://en.wikipedia.org/wiki/Render_output_unit</a></p></blockquote><p>レンダリングパイプラインのRasterization、そしてフレームバッファにピクセルを書き込む時に使われるもので、ブレンディング、AAなどに使われる。</p><p>クロックごとにどれだけのピクセルを表示することが出来るかの指標として扱える。（後はメモリBandwidth）</p><hr><p>2020年今までゲーミンググラボの中で一番高いやつの「2080ti」はROPが88個だが、PS4は32個（PROはわからない）、そしてXBOX ONEは16個であるため、短いシェーダーの場合には性能が発揮しにくい。また性能のボトルネックを測るにはVRAMメモリへの帯域幅も念頭しなければならない。</p><p>原文では「GPUのクロック＊ROPs＊フレームバッファの各ピクセルのBytes」で理論上の処理速度を測定している。</p><p>とにかくなんとかかんとか大体のフレームバッファはRGBA8であるため（HDRなどは例外）、普通の状況ではROPsボトルネックになってしまう。出来ればメモリのボトルネックにする方が良いので、演算速度を上げるにはCompute Shaderをものすごく使うのが良いらしい。</p><h2 id=branching--registers>Branching ~ Registers<a hidden class=anchor aria-hidden=true href=#branching--registers>#</a></h2><p>GCNでの分岐の処理は基本的に一番遅いレーンに合わせることと、ThenとElseの分岐を全部試してみるという骨子からあんまり変わっていないが、速いので速度が落ちることがあんまりないそうだ。分岐の処理はスカラ演算ユニットで処理される。</p><p>しかし問題は分岐によってGRP（General Purpose Register）の使用が増えてしまうことである。分岐よりはこのGRPの使用増加により性能が落ちるらしい。</p><p>小さい分岐にはFull branchを防ぐため<code>?:</code>を使う。ただ、あるプラットフォームまたはHWでは<code>?:</code>さえFull branchされてしまい、GRPの増加による性能落ちが発生するらしく、その時には<code>CndMask()</code>を使うと言っている。（拡張か、それともなんらかのIntrinsicみたい）</p><p>p34）整数で<code>mul24()</code>が使えるなら、普通の<code>MUL</code>の代わりに<code>mul24(a,b)</code>を使う方が速い。24bitだけを取り出し、32bitをの結果値を返す。またはハードウェアのサポートによって<code>mul24_hi()</code>もあるという。</p><p>またHWのサポートによって<code>MAD</code>を24bits、24bits、そしてADDに使う32bitsとして1サイクルを終わらせるものもあるらしい。</p><p>そして整数への割り算はデバイスからサポートしてない場合が多く、やるとしても最適化がかからなかったら~40サイクルまで掛かるのでやらないべきであるという。最適化されるとしても、5~8クロックはかかるそうだ。</p><p>p38）GCNは倍精度浮動小数点（Double）をサポートするが、使うとこがない。</p><blockquote><p><a href=https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/f32tof16--sm5---asm->https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/f32tof16--sm5---asm-</a></p></blockquote><p>D3D11以上でdoubleとfloatを変換する際には<code>f32tof16()</code>または<code>f16tof32()</code>を使う。</p><p>R5G5B5圧縮カラー（DXT1）から各チャンネルの色を取りたい時には以下のようにする。</p><pre><code class=language-hlsl data-lang=hlsl>int r = s &amp; 0x1F;         // 1 cycle maybe
int g = (s &gt;&gt; 5) &amp; 0x3F;  // 1 cycle maybe
int b = (s &gt;&gt; 11) &amp; 0x1F; // 1 cycle maybe
</code></pre><p>p41）<code>sign()</code>と<code>step()</code>の代わりに<code>?:</code>を使うこと。（in D3D11）原文では<code>sign()</code>ビルトイン関数は遅いのでいっそ<code>(x >= 0) ? 1 : -1</code>のように使うべきだと言っている。また<code>step()</code>も<code>(x >= a) ? 1 : 0</code>にすべきらしい。</p><p>GCNはベクトルに対して実行サイクルをへらすために<code>min3()</code>、<code>max3()</code>、<code>med3()</code>らしきものを実装している。</p><p>p44）シェーダーの各ステージで使っているレジスタの数は処理速度に影響を与える。しかしレジスタの使用を最適化することはブラックボックス化された中身を最適化することと同じで、もっとも難しい。ただ、経験上からはシェーダーの横負荷を減らして、ある時点で使っているレジスタの数を減らせば性能は上がるらしい。（HWによって違う可能性ある）</p><pre><code class=language-hlsl data-lang=hlsl>for (each) { WorkA(); }
for (each) { WorkB(); }
// not for (each) { WorkA(); WorkB(); }
</code></pre><p>そしてこの最適化はCPUの方でも通用されるのだが、変数データの寿命を最大限に短くすること。また、<code>#ifdef</code>を積極的に活用してランタイムの分岐よりはシェーダープログラムを作る際に静的に分岐して性能の低下を防ぐようにすること。最悪<a href=https://www.gamedev.net/forums/topic/659145-what-is-a-uber-shader/>Uber-shader</a>の中にマクロ分岐を仕込んでレンダリングさせるほうが良い。</p><h2 id=things-shader-author-should-stop-doing>Things shader author should stop doing<a hidden class=anchor aria-hidden=true href=#things-shader-author-should-stop-doing>#</a></h2><p>やるなスペシャル</p><ul><li><code>pow(color, 2.2f)</code></li><li><code>normal = Normal.Sample(...) * 2.0f - 1.0f</code></li></ul><h1 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h1><p><a href=https://gpuopen.com/wp-content/uploads/2017/03/GDC2017-Advanced-Shader-Programming-On-GCN.pdf>GDC2017-Advanced-Shader-Programming-On-GCN</a></p><p><a href=https://www.slideshare.net/DevCentralAMD/gs4106-the-amd-gcn-architecture-a-crash-course-by-layla-mah>GS-4106 The AMD GCN Architecture - A Crash Course, by Layla Mah</a></p><p><a href=https://developer.amd.com/wordpress/media/2012/12/AMD_Southern_Islands_Instruction_Set_Architecture.pdf>AMD Southern Island Instruction Set Architecture</a></p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://liliilli.github.io/posts/week25_2020/><span class=title>« Prev Page</span><br><span>最近簡単に読んだポスト</span></a>
<a class=next href=https://liliilli.github.io/posts/sfinae_afaid/><span class=title>Next Page »</span><br><span>SFINAEの活用、ざっくりメモ</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Low-level shader optimization for next-gen and D3D11のメモ on twitter" href="https://twitter.com/intent/tweet/?text=Low-level%20shader%20optimization%20for%20next-gen%20and%20D3D11%e3%81%ae%e3%83%a1%e3%83%a2&url=https%3a%2f%2fliliilli.github.io%2fposts%2fshader_opti_memo_2%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Low-level shader optimization for next-gen and D3D11のメモ on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fliliilli.github.io%2fposts%2fshader_opti_memo_2%2f&title=Low-level%20shader%20optimization%20for%20next-gen%20and%20D3D11%e3%81%ae%e3%83%a1%e3%83%a2&summary=Low-level%20shader%20optimization%20for%20next-gen%20and%20D3D11%e3%81%ae%e3%83%a1%e3%83%a2&source=https%3a%2f%2fliliilli.github.io%2fposts%2fshader_opti_memo_2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Low-level shader optimization for next-gen and D3D11のメモ on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fliliilli.github.io%2fposts%2fshader_opti_memo_2%2f&title=Low-level%20shader%20optimization%20for%20next-gen%20and%20D3D11%e3%81%ae%e3%83%a1%e3%83%a2"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Low-level shader optimization for next-gen and D3D11のメモ on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fliliilli.github.io%2fposts%2fshader_opti_memo_2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Low-level shader optimization for next-gen and D3D11のメモ on whatsapp" href="https://api.whatsapp.com/send?text=Low-level%20shader%20optimization%20for%20next-gen%20and%20D3D11%e3%81%ae%e3%83%a1%e3%83%a2%20-%20https%3a%2f%2fliliilli.github.io%2fposts%2fshader_opti_memo_2%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Low-level shader optimization for next-gen and D3D11のメモ on telegram" href="https://telegram.me/share/url?text=Low-level%20shader%20optimization%20for%20next-gen%20and%20D3D11%e3%81%ae%e3%83%a1%e3%83%a2&url=https%3a%2f%2fliliilli.github.io%2fposts%2fshader_opti_memo_2%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>Copyright © 2008–2019, Steve Francia and the Hugo Authors; all rights reserved.</span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>