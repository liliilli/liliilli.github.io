<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>ShaderToyでPBRを書いてから、自ら解説してみた。</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
</head>
<body>
	<header>
	=================<br>
	== <a href="https://liliilli.github.io">neuromantic</a> ==<br>
	=================
	<div style="float: right;"></div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/about-hugo/"><b>About</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>ShaderToyでPBRを書いてから、自ら解説してみた。</h1>
			<b><time>16.11.2019 19:51</time></b>
		       
		           <a href="/tags/untagged">untagged</a>
        	       

			<div>
				

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/WsdSDf?gui=true&t=10&paused=true&muted=false" allowfullscreen></iframe>
実は2週前に、ShaderToyというウェブでGLSLがかけて、それをレンダリングすることができるサイトで、上のシェーダーを書いてました。前にもShaderToyで色々と書いたんですが、PBRを本格に適用して書いたのは今が初めてです。</p>

<p>なんで、このシェーダーを書きながら、どうやってPBRのDiffuseとSpecularを実装したのかを簡単と大雑把に書きたいと思います。図形の作り方、またはレイマーチングのやり方に関しては説明いたしません。</p>

<h1 id="本編">本編</h1>

<p>PBRレンダリングを勉強するときによく見られるDisneyの<code>Physical-Based Shading at Disney</code>、または色々のPBRが基づく理論文書を読みますと、光と視点のよるある地点の色は以下になります。</p>

<p>$$
f(\pmb{l}, \pmb{v}) = \text{diffuse} + \text{specular}
$$
<code>Diffuse</code>と<code>Specular</code>はそれぞれの特性を独立的に持てると言えます。なので、実施に最終色を入れるときに次のように単純に<code>Diffuse</code>と<code>Specular</code>を入れます。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="c1">// fragColorは[0,1]のvec4(R,G,B,A)です。</span>
<span class="n">fragColor</span> <span class="o">=</span> <span class="k">vec4</span><span class="p">(</span><span class="n">dif</span> <span class="o">+</span> <span class="n">spc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></code></pre></div>
<blockquote>
<p>$$ f(\pmb{l}, \pmb{v}) $$ は実際には色そのまのを表してはいません。あくまでBRDF（Bidirectional-Reflectance Distribution Funciton）のモデルを表したものであり、実際にはぶつかった入射光線と表面の法線での半球で、すべての反射光線がどの角度とエナジーを持つのかを調べて、全部合わせないと正確な数値が計算できません。</p>

<p>ただし、今はもっと抽象化した数式を使ってレンダリングをしようとします。リアルタイムで完全な数式を解いて色を得ることはほぼ不可能だし、もっと抽象化したモデルでもだいたい通じます。</p>
</blockquote>

<h2 id="diffuse">Diffuse</h2>

<p>普通よく使うのは<code>Lambertian</code>ですが<code>Oren-Nayar</code>っていう、もっと正確なPBRモデルもあります。僕は最初は<code>Lambertian</code>を使いましたが、最終は<code>Oren-Nayar</code>にしました。</p>

<h3 id="lambertian">Lambertian</h3>

<p>$$
f(\pmb{l}, \pmb{v}) = \frac{\rho_{ss}}{\pi}
$$</p>

<p><code>Diffuse</code>モデルの中で一番簡単なモデルです。色だけでモデルBRDFが決まりますし、だとしてもそれっぽく見えるようになるので普通のゲームでもよく使います。</p>

<p>ここで
$$
\rho_{ss}
$$
は、表面のアルベド（物体が光を弾いたときの反射率）を表します。これだけがLambertianのモデルの数値になります。</p>

<p>下のコードはLambertianモデルを使って、実際のピクセルのカラーを表現するコードです。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">FactorDiffLambertian</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">/</span> <span class="n">pi</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">vec3</span> <span class="n">DiffuseLambertian</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> 
                       <span class="k">in</span> <span class="k">vec3</span> <span class="n">diffuse</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">ambient</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mix</span><span class="p">(</span><span class="n">ambient</span><span class="p">,</span> <span class="n">diffuse</span><span class="p">,</span> <span class="n">FactorDiffLambertian</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>注意するとこは、<code>FactorDiffLamberitan</code>の中の<code>dot(l, n)</code>は実際はLambertianのモデルの数式に含まれていません。<code>mix(ambient, diffuse, ...)</code>の<code>diffuse</code>が上記の
$$
\rho_{ss}
$$
になります。
そして、<code>FactorDiffLambertian</code>関数は、以下の数式
$$
L_o(\mathbf{v}) = \int_{\mathbf{l}\in\Omega}{f(\mathbf{l}, \mathbf{v})L_i(\mathbf{l})(\mathbf{n}\cdot\mathbf{l})d\mathbf{l}}
$$
の<code>dot(l, n)</code>項を表しています。（ただし、πは事前に入れときました。反省するとこですね。）</p>

<p>このモデルの特徴は表面が平坦だと見なしてレンダリングを行うところです。Roughnessが関与するとこが無く、単純にアルベドと光と表面の法線ベクトルによる明度だけをレンダリングします。ということで、ちょっと単純だけどコストが速いし、それなりにごまかせば他のモデルとあんまり違いは出ないと思います。</p>

<h3 id="oren-nayar">Oren-Nayar</h3>

<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model">https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model</a>
<a href="https://mimosa-pudica.net/improved-oren-nayar.html">https://mimosa-pudica.net/improved-oren-nayar.html</a></p>
</blockquote>

<p>このモデルは上のLambertianとは違って、表面の粗さによって明度の違いのレンダリングを調節できます。Oren-Nayarとともに表面の粗さによるDiffuseレンダリングモデルを総じて、<code>Rough-surface diffuse BRDF</code>と呼びます。</p>

<p>とりあえずOren-Nayarは論文をみますとFull-Model（完全モデル）とQuantitive-Model（ある程度省略したモデル）に分かれています。ウィキペディアに乗っているのはQuantitive-Modelだし、僕もフールモデルじゃなくてQuantitive-Modelを使ってOren-Nayarを実装してます。</p>

<p>Oren-Nayar（Quantitiveバージョン）は以下の数式となります。
$$
\begin{align}
L_{r} &amp;=
    \frac{\rho}{\pi}
    \cdot (\mathbf{l} \cdot \mathbf{n})
    \cdot (A + (B \cdot \max[0, \cos(\phi_{i} - \phi_{v})]
        \cdot \sin\alpha
        \cdot \tan\beta))
    \cdot E_0
\\<br />
A &amp;= 1 - 0.5\frac{\sigma^2}{\sigma^2 + 0.33}
\\<br />
B &amp;= 0.45 \frac{\sigma^2}{\sigma^2 + 0.09}
\\<br />
\alpha &amp;= \max(
    \theta_{\mathbf{l} \cdot \mathbf{n}},
    \theta_{\mathbf{v} \cdot \mathbf{n}})
\\<br />
\beta &amp;= \min(
    \theta_{\mathbf{l} \cdot \mathbf{n}},
    \theta_{\mathbf{v} \cdot \mathbf{n}})
\end{align}
$$
しかし僕は2番目のリンクにあるベクトルを使った数式を使いました。
$$
\begin{align}
L_o &amp;= \frac{\rho}{\pi}\cdot(\mathbf{l}\cdot\mathbf{n})(A + B\frac{\mathbf{s}}{t})
\\<br />
s &amp;= \mathbf{l}\cdot\mathbf{v} - (\mathbf{n}\cdot\mathbf{l})(\mathbf{n}\cdot\mathbf{v})
\\<br />
t &amp;=
\begin{cases}
1 &amp; \text{if $s \le 0$} \\<br />
\max(\mathbf{n}\cdot\mathbf{v}, \mathbf{n}\cdot\mathbf{l}) &amp; \text{if $s \gt 0$}
\end{cases}
\\<br />
A &amp;= (1 - 0.5\frac{\sigma^2}{\sigma^2 + 0.33} + 0.17\rho\frac{\sigma^2}{\sigma^2 + 0.13})
\\<br />
B &amp;= 0.45\frac{\sigma^2}{\sigma^2 + 0.09}
\end{align}
$$
なぜなら、上の数式を直接反映してみたらところどころでバグによる明るい曲線が見えるからです。多分<code>tan()</code>項でバグったりして不具合が描画されると思いますが、直せずに下のベクトル形態の数式を使ってOren-NayarのQuantitive-Modelを実装しました。</p>

<p>数式で見れる<code>\rho</code>（$ \rho $ ）はアルベドを表します。普通Lamberitanのアルベドのように、アルベドカラーを入れます。そして<code>\sigma</code>（$ \sigma $）は表面の粗さ（Roughness）を示します。だいたい０～１の値を持ちます。</p>

<p>上の数式を表したコードは下にあります。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">OrenNayarAlpha</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">OrenNayarBeta</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mix</span><span class="p">(</span>
        <span class="mf">1.</span><span class="n">f</span><span class="p">,</span>
        <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)),</span>
        <span class="n">step</span><span class="p">(</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">OrenNayarAlpha</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">OrenNayarA</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">-</span> <span class="mf">0.5</span><span class="n">f</span> <span class="o">*</span> <span class="p">(</span>
         		<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
    <span class="o">/</span> <span class="c1">// ----------------------</span>
        	<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.33</span><span class="n">f</span><span class="p">)</span>           
    <span class="p">)</span>
    <span class="o">+</span> <span class="mf">0.17</span><span class="n">f</span> <span class="o">*</span> <span class="p">(</span>
        		<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
    <span class="o">/</span> <span class="c1">// ----------------------</span>
        	<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.13</span><span class="n">f</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">OrenNayarB</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mf">0.45</span><span class="n">f</span> <span class="o">*</span> <span class="p">(</span>
         		<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
    <span class="o">/</span> <span class="c1">// ----------------------</span>
        	<span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.09</span><span class="n">f</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">FactorDiffOrenNayar</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">float</span> <span class="n">A</span>  	<span class="o">=</span> <span class="n">OrenNayarA</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    <span class="k">float</span> <span class="n">B</span> 	<span class="o">=</span> <span class="n">OrenNayarB</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    <span class="k">float</span> <span class="n">_a</span> 	<span class="o">=</span> <span class="n">OrenNayarAlpha</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">float</span> <span class="n">_b</span> 	<span class="o">=</span> <span class="n">OrenNayarBeta</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">FactorDiffLambertian</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span> <span class="o">*</span> <span class="p">(</span><span class="n">_a</span> <span class="o">/</span> <span class="n">_b</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">vec3</span> <span class="n">DiffuseOrenNayar</span><span class="p">(</span><span class="k">in</span> <span class="k">vec3</span> <span class="n">l</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> 
                      <span class="k">in</span> <span class="k">vec3</span> <span class="n">diffuse</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">ambient</span><span class="p">,</span> 
                      <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mix</span><span class="p">(</span><span class="n">ambient</span><span class="p">,</span> <span class="n">diffuse</span><span class="p">,</span> <span class="n">FactorDiffOrenNayar</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>一気にコードの量が増えましたが、分析していただきましたら大したものはないことがわかります。</p>

<p>実は、2番目のリンク先で投稿した方の改良したOren-Nayarモデルも実装はしたんですが、光が表面全体を照らすときの描画が好きじゃなかったので断念してOren-NayarのQuantitive-Modelを最終採用しました。</p>

<h2 id="specular">Specular</h2>

<p>SpecularのBRDFも、上のDiffuseのようにMicrofacet理論に基づいたモデルを使っています。Specular（ハイライト）は、Diffuseとは違ってカメラの目線によってある位置にハイライトの陰影がつけられるかが異なります。（なんで、Lambertianみたいな単純なモデルは無いです）</p>

<p>普通に使ってるPBRのSpecularモデルは、以下の<strong>Cook-Torrance Model</strong>です。
$$
f_{spec}(\mathbf{l}, \mathbf{v}) = \frac
    {F(\mathbf{h}, \mathbf{l})G_{2}(\mathbf{l},\mathbf{v},\mathbf{h})D(\mathbf{h})}
    {4|\mathbf{n}\cdot\mathbf{l}||\mathbf{n}\cdot\mathbf{v}|}
$$</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">cn</span> <span class="o">=</span> <span class="mf">4.</span><span class="n">f</span> <span class="o">*</span> <span class="n">max</span><span class="p">(</span><span class="mf">.25</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ld</span><span class="p">))</span> <span class="o">*</span> <span class="n">max</span><span class="p">(</span><span class="mf">.25</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="n">fwd</span><span class="p">));</span>
            
<span class="k">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">GTR</span><span class="p">(</span><span class="mi">9</span><span class="n">e</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="n">kBx1</span><span class="p">.</span><span class="n">mRough</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="mf">2.</span><span class="n">f</span><span class="p">);</span>
<span class="k">float</span> <span class="n">f</span> <span class="o">=</span> <span class="n">Schlick</span><span class="p">(</span><span class="n">kBx1</span><span class="p">.</span><span class="n">mR0</span><span class="p">,</span> <span class="n">td</span><span class="p">);</span>
<span class="k">float</span> <span class="n">g</span> <span class="o">=</span> <span class="n">SeparableMaskingShadowing</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">kBx1</span><span class="p">.</span><span class="n">mRough</span><span class="p">);</span>
            
<span class="n">spc</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">f</span> <span class="o">*</span> <span class="n">g</span> <span class="o">/</span> <span class="n">cn</span><span class="p">;</span></code></pre></div>
<h3 id="fresnel-reflection">Fresnel Reflection</h3>

<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Fresnel_equations">https://en.wikipedia.org/wiki/Fresnel_equations</a>
<a href="https://en.wikipedia.org/wiki/Schlick%27s_approximation">https://en.wikipedia.org/wiki/Schlick%27s_approximation</a></p>
</blockquote>

<p>上記のCook-Torrance Modelにて、分子の
$$
F(\mathbf{h}, \mathbf{l})
$$
はフレネルの式を示します。要するに、光の入射光線がある物体の表面にぶつかるときの正反射率を表す数式です。全ての物質は自分のIOR（屈折率）と外部のIORによってそれぞれ違う反射率を持ちます。</p>

<p>ウィキペディアを見ていただきますと正確な数式がありますが、CGでシェーダープログラムにフレネルの式の全部をやらせるには負担がかかりすぎます。なので、下の単純なモデルを使いながらある程度フレネルの式を従います。
$$
F(\mathbf{h}, \mathbf{l}) \approx F_0 + (1 - F_0)(1 - (\mathbf{h}\cdot\mathbf{l})^+)^5
$$
この数式は<strong>Schlick-Approximation</strong>と言います。空気中の物質に対するフレネルの式の数値を得たいときの使います。もちろん、抽象化されたモデルなので正確ではありません。ですがフレネルの式の数値のグラフでの変動をある程度沿っています。</p>

<p>ここで、
$$
F_0
$$
は垂直入射の時のFresnel反射係数の実部です。この数値はRGBまたは普通のグレースケールの数値として入れられます。グレースケールになる場合には、物質が金属ではない場合で使えます。RGBは金属の物質のフレネルの数値を求めたい場合に使えます。（大雑把でしたけど、もっと詳しくお調べしたい方々は*Real-Time Rendering 4th*のChapter9をお読みくださいませ）
$$
\mathbf{h} = \text{normalize($\mathbf{l} + \mathbf{v}$)}
$$
<code>h</code>はハーフウェイベクトル（Halfway Vector）と言います。DiffuseとSpecularを一つに統合したレンダリングモデルである、Blinn-Phong Reflectance Modelでも使うやつです。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">Schlick</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r0</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">n</span><span class="p">,</span> <span class="k">in</span> <span class="k">vec3</span> <span class="n">v</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">r0</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">r0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)),</span> <span class="mf">5.</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// または</span>

<span class="k">float</span> <span class="n">Schlick</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">r0</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">td</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="n">r0</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">r0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="n">cos</span><span class="p">(</span><span class="n">td</span><span class="p">)),</span> <span class="mf">5.</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>上のコードはSchlick Approximationを2つのバージョンで実装したものです。下のバージョンの<code>td</code>は、<code>n</code>と<code>v</code>の角度差を表します。</p>

<h3 id="normal-distribution-function">Normal Distribution Function</h3>

<p>法線分布関数だと呼ばれる<strong>Normal Distribution Function</strong>は、微小面の法線がどうやって分布されているかを示す関数です。この関数は統計的に測定されて使っているか、それともある抽象化した数学関数を用いて使います。詳しくはmicrofacet理論の触れますので割愛します。</p>

<p>ですけどこのNDFに特徴の一つは、あるNDF関数があって、そしてある表面の法線ベクトル <code>N</code> があった時に、球面を覆う単位ベクトルを入れたNDFの値の積分は、<code>N</code> を持つ微細表面の面積になります。ということで、
$$
\int_{\mathbf{m} \in \Theta} {D(\mathbf{m})(\mathbf{n} \cdot \mathbf{m})d\mathbf{m}} = 1
$$
になります。</p>

<p>また、カメラまたは目線のベクトル<code>v</code>があるとき、ある表面の法線ベクトルが<code>n</code>で、そして微細表面の球体の単位ベクトルが<code>m</code>だとしたら、
$$
\int_{\mathbf{m} \in \Theta}{D(\mathbf{m})(\mathbf{v}\cdot\mathbf{m})d\mathbf{m}} = \mathbf{v}\cdot\mathbf{n}
$$
です。目によって実際に見える微小面の面積は微小面の凸凹の法線ベクトルたちを目線のベクトルとの内積し、結果値を全部足したのと同じです。<code>v * m</code>で目に見えない微小面はなくなりまし、見える表面は残ります。</p>

<p>一応これもリアルタイムでは計算しにくいので、上の特性から派生した様々な抽象化したモデルがあります。僕はDisney BRDFで使った<strong>GTR (Generalized-Trowbridge-Reitz）</strong>モデルを使いました。このモデルはGGX（Trowbridge-Reitz）モデルを一般化したものです。
$$
D_{GTR} = \frac{c}{(a^2\cos^2(\theta_{h})+\sin^2(\theta_{h}))^\gamma}
$$</p>

<blockquote>
<p>実はこの数式も実使用で使うために簡略化された数式です。Realtime-RenderingでGTRの完全数式を見てみますと結構ひどいです。（白目）</p>
</blockquote>

<p>上の数式で、<code>gamma</code>が2ならGGXと同じになります。以下はGTRをコードに写したものです。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">GTR</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">c</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">dh</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">gamma</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> 
        						 <span class="n">c</span>
    <span class="o">/</span> <span class="c1">//--------------------------------------------------------</span>
        <span class="n">pow</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">dh</span><span class="p">),</span> <span class="n">gamma</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h3 id="joint-masking-shadowing-function">Joint Masking Shadowing Function</h3>

<p>Joint Masking Shadowing Functionを説明する前に、簡単に一般Masking Function <code>G</code>を説明させていただきたいと思います。日本語でいうと<strong>幾何減衰項</strong>（読み方はわかりません）と言います。Masking Functionは微小面（Microfacet）によって発生するシャドウィング（自己陰影）、マスキング（自己遮蔽）を表したものです。</p>

<p>幾何減衰項は上で説明したNDFに（法線分布関数）と密接に関連されます。上の表面の法線・微小面の法線・目線の法線との関係がある数式は、以下のように変形できます。
$$
\int_{\in\Theta}{G_1(\mathbf{m}, \mathbf{v})D(\mathbf{m})(\mathbf{v}\cdot\mathbf{m})^+d\mathbf{m}} = \mathbf{v}\cdot\mathbf{n}
$$
ここで <code>G_1(m, v)</code>は<strong>Smith Function</strong>といい、<code>v</code>に対して見える<code>m</code>の比率を表します。ですけど、G1は実際には<code>m</code>が目線の反対方向を向いていなければ、G1の数値に全然影響がない特徴を持ちます。なのでSmith Function G1の数式は
$$
G_1(\mathbf{m}, \mathbf{v}) = \frac{\chi^+(\mathbf{m}\cdot\mathbf{v})}{1 + \Lambda(\mathbf{v})}
$$
となります。コードでは上の分子の項は、<code>m</code>と<code>v</code>の内積が0より大きければ1として置換できます。ですがこれをこのまま使うのではなく、BRDFを建てる時には以下のようにG1の代わりにG2を使います。
$$
f(\mathbf{l}, \mathbf{v}) =
    \int_{\mathbf{m}\in\Theta}
        f_{\mu}(\mathbf{l}, \mathbf{v}, \mathbf{m})
        G_2(\mathbf{l}, \mathbf{v}, \mathbf{m})
        D(\mathbf{m})
        \frac{(\mathbf{m}\cdot\mathbf{l})^+}{|\mathbf{n}\cdot\mathbf{l}|}
        \frac{(\mathbf{m}\cdot\mathbf{v})^+}{|\mathbf{n}\cdot\mathbf{v}|}
        d\mathbf{m}
\\<br />
\\<br />
G_2(\mathbf{l}, \mathbf{v}, \mathbf{m}) =
    G_1(\mathbf{v}, \mathbf{m})
    G_1(\mathbf{l}, \mathbf{m})
$$
上のG2の形以外に、様々な変形数式が存在します。G1を2つくっつけて掛け算する数式が一番だったりしますが、不具合が存在しますので下のも使われるそうです。（下は*Smith Height-Correlated Masking-Shadowing Function*）と言います。
$$
G_2(\mathbf{l}, \mathbf{v}, \mathbf{m}) = \frac{\chi^+(\mathbf{v}\cdot\mathbf{m})\chi^+(\mathbf{l}\cdot\mathbf{m})}{1 + \Lambda(\mathbf{v}) + \Lambda(\mathbf{l})}
$$
僕は一番簡単な分離型G2を使いました。</p>
<div class="highlight"><pre class="chroma"><code class="language-glsl" data-lang="glsl"><span class="k">float</span> <span class="n">Lambda</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">rad</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> 
        <span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="n">f</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span><span class="n">f</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="n">f</span> <span class="o">/</span> <span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span><span class="n">f</span><span class="p">)))</span> <span class="o">*</span> <span class="mf">.5</span><span class="n">f</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">SmithMasking</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">rad</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span>
        		<span class="mf">1.</span><span class="n">f</span>
    <span class="o">/</span> <span class="c1">//-----------------------</span>
        <span class="p">(</span><span class="mf">1.</span><span class="n">f</span> <span class="o">+</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">rad</span><span class="p">,</span> <span class="n">r</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">float</span> <span class="n">SeparableMaskingShadowing</span><span class="p">(</span><span class="k">in</span> <span class="k">float</span> <span class="n">tl</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">tv</span><span class="p">,</span> <span class="k">in</span> <span class="k">float</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">SmithMasking</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">SmithMasking</span><span class="p">(</span><span class="n">tv</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h1 id="まとめ">まとめ</h1>

<p>以上、大雑把にコードを振り返りながらPBRの書き方、中身についてメモをしてみました。</p>

<h1 id="もっと詳しく調べたい方に">もっと詳しく調べたい方に</h1>

<ul>
<li><a href="https://qiita.com/mebiusbox2/items/1cd65993ffb546822213">https://qiita.com/mebiusbox2/items/1cd65993ffb546822213</a></li>

<li><p><a href="https://qiita.com/mebiusbox2/items/8db00cdcaf263992a5ce">https://qiita.com/mebiusbox2/items/8db00cdcaf263992a5ce</a></p></li>

<li><p><a href="https://qiita.com/emadurandal/items/3a8db7bc61438245654d">https://qiita.com/emadurandal/items/3a8db7bc61438245654d</a></p></li>
</ul>

			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/posts/shader_opti_memo/">Low Level Thinking in High Shader Languages</a></li>
				
				<li><a href="/posts/dinput8/">DirectInput8 導入メモ</a></li>
				
				<li><a href="/posts/tlsf_basic/">TLSF Allocatorを作ってみた</a></li>
				
				<li><a href="/posts/matrix_name/">行列変数のネーミングについて</a></li>
				
				<li><a href="/posts/dy_cmake/">自分でやるDyのCMakeListsファイル説明</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2020 <a href="https://liliilli.github.io"><b>neuromantic</b></a>.
	<a href="https://github.com/liliilli"><b>Github</b></a>.
	<a href="https://twitter.com/NeuliliilliD"><b>Twitter</b></a>.
	</p>
</footer>

</body>
</html>
